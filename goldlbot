import os
import sys
import time
import math
import csv
import re
import logging
import random
import traceback
import warnings
from dataclasses import dataclass, field
from typing import Optional
from datetime import datetime, timedelta
from datetime import datetime, timezone
from datetime import time as _dt_time
from zoneinfo import ZoneInfo
import types
import requests
import pandas as pd
import numpy as np
import MetaTrader5 as mt5
from dotenv import load_dotenv
import schedule
import time as _time
import sys, shutil, time as _time
import os, time as _time, requests
import os, time, requests
from os import getenv
from types import SimpleNamespace
from MetaTrader5 import symbol_info_tick
from datetime import datetime
import inspect
import builtins


def run_master_diagnostic():
    results = []

    # === 1. MT5 bağlantısı ===
    try:
        if mt5.initialize():
            acc = mt5.account_info()
            if acc:
                results.append("[OK] MT5 bağlantısı sağlandı")
            else:
                results.append("[FAIL] MT5 account_info alınamadı")
        else:
            results.append("[FAIL] MT5 initialize başarısız")
    except Exception as e:
        results.append(f"[FAIL] MT5 initialize exception -> {e}")

    # === 2. ATR Testi ===
    try:
        df = get_ohlc("GOLD", mt5.TIMEFRAME_H1, 100)
        atr = calculate_atr(df)
        if atr is not None and not atr.empty:
            results.append("[OK] ATR hesaplama çalışıyor")
        else:
            results.append("[FAIL] ATR hesaplama boş döndü")
    except Exception as e:
        results.append(f"[FAIL] ATR exception -> {e}")

    # === 3. Stop Loss / Take Profit Guard ===
    try:
        si = mt5.symbol_info("GOLD")
        tick = mt5.symbol_info_tick("GOLD")
        guard = compute_sl_tp_guard(
            symbol="GOLD",
            direction="LONG",
            entry=tick.ask,  
            sl=None, 
            tp=None, 
            si=si, 
            tick=tick
        )
        if guard:
            results.append("[OK] SL/TP Guard çalışıyor")
        else:
            results.append("[FAIL] SL/TP Guard boş döndü")
    except Exception as e:
        results.append(f"[FAIL] SL/TP Guard exception -> {e}")

    try:
        entry = 3880.0  # test için sahte değer
        tp = 3890.0
        symbol = "GOLD"
        ok = check_tp_bucket("M15", entry, tp, symbol)
        if ok:
            print("[OK] TP kovası çalışıyor")
        else:
            print("[FAIL] TP kovası hata: False döndü")
    except Exception as e:
        print(f"[FAIL] TP kovası exception -> {e}")

    # === 4. RR (Risk/Reward) Sistemi ===
    try:
        entry = 1900.0
        sl = 1890.0
        tp = 1920.0
        rr = (tp - entry) / (entry - sl) if (entry - sl) != 0 else None
        if rr and rr > 0:
            results.append(f"[OK] RR hesaplama çalışıyor (RR={rr:.2f})")
        else:
            results.append("[FAIL] RR hesaplama sıfır/negatif")
    except Exception as e:
        results.append(f"[FAIL] RR hesaplama exception -> {e}")

    # === 5. TP Kovaları ===
    try:
        tf = "M15"
        entry = 1900.0
        tp = 1910.0
        if check_tp_bucket(tf, entry, tp):
            results.append("[OK] TP kovası geçerli")
        else:
            results.append("[FAIL] TP kovası geçersiz")
    except Exception as e:
        results.append(f"[FAIL] TP kovası exception -> {e}")

    # === 6. Formasyonlar ===
    formasyonlar = [
        "hammer",
        "engulfing",
        "double_top",
        "double_bottom",
        "head_shoulders",
        "inverse_head_shoulders",
        "triangle",
        "flag",
        "wedge",
        "doji",
    ]
    for f in formasyonlar:
        try:
            func = globals().get(f"detect_{f}")
            if func:
                results.append(f"[OK] Formasyon: {f}")
            else:
                results.append(f"[FAIL] Formasyon fonksiyonu eksik: {f}")
        except Exception as e:
            results.append(f"[FAIL] Formasyon {f} exception -> {e}")

    # === 7. Konfirmasyon Bölgeleri ===
    teyit_bolgeleri = [
        "support_resistance",
        "supply_demand",
        "trendline_break",
        "fibonacci_levels",
        "moving_average_cross",
    ]
    for t in teyit_bolgeleri:
        try:
            func = globals().get(f"check_{t}")
            if func:
                results.append(f"[OK] Teyit bölgesi: {t}")
            else:
                results.append(f"[FAIL] Teyit fonksiyonu eksik: {t}")
        except Exception as e:
            results.append(f"[FAIL] Teyit {t} exception -> {e}")

    # === 8. Timeframe Kontrol ===
    timeframes = [
        ("M15", check_signals_m15),
        ("M30", check_signals_m30),
        ("M45", check_signals_m45),
        ("H1", check_signals_h1),
        ("H2", check_signals_h2),
        ("H3", check_signals_h3),
        ("H4", check_signals_h4),
        ("H12", check_signals_h12),
    ]
    for name, func in timeframes:
        try:
            func("GOLD")
            results.append(f"[OK] Timeframe: {name}")
        except Exception as e:
            results.append(f"[FAIL] Timeframe: {name} -> {e}")

    # === 9. Risk Hesaplama ===
    try:
        lot = calculate_lot(1900.0, 1890.0, 0.02)
        if lot > 0:
            results.append(f"[OK] Risk/Lot hesaplama çalışıyor (lot={lot})")
        else:
            results.append("[FAIL] Risk/Lot hesaplama sıfır")
    except Exception as e:
        results.append(f"[FAIL] Risk hesaplama exception -> {e}")

    # === 10. Spread Gate ===
    try:
        allow, why, pts, ratio = spread_gate("GOLD", 1900.0, 1890.0)
        if allow:
            results.append("[OK] Spread gate çalışıyor")
        else:
            results.append(f"[FAIL] Spread gate blocked: {why}")
    except Exception as e:
        results.append(f"[FAIL] Spread gate exception -> {e}")

    # === SONUÇ ===
    print("\n=== MASTER DIAGNOSTIC SONUÇ ===")
    for r in results:
        print(r)
    print("==============================\n")


def now_tr():
    """Türkiye saati (Europe/Istanbul) döner"""
    return datetime.now(ZoneInfo("Europe/Istanbul"))


# ======= RESILIENT DISTANCE/YÖN GUARD (hotfix v2: pos+kw compatible) =======
# ===== RR-ONLY VALIDATOR (2-tuple, hiç bloklamaz) =====
def _validate_positive_distances(*_args, **_kwargs):
    """
    RR-ONLY mode: mesafe/side/broker/env kontrollerini KAPAT.
    Hep (True, "ok") döndürür ki çağıran yer 2'li unpack ile çalışsın.
    """
    return True, "ok"


# ======================================================

# ==== Optional contract helpers: type hints + safe fallbacks ====
from typing import TYPE_CHECKING

if TYPE_CHECKING:

    def normalize_signal(res: dict) -> dict: ...
    def assert_contract(res: dict) -> bool: ...


try:
    normalize_signal  # type: ignore[name-defined]
except NameError:

    def normalize_signal(res: dict) -> dict:
        return res or {}


try:
    assert_contract  # type: ignore[name-defined]
except NameError:

    def assert_contract(res: dict) -> bool:
        return True


# ===============================================================

print("[BOOT] GOLD BOT FILE:", __file__)  # running file path

# ---- Defensive fallbacks to ensure runtime stability (hotfix) ----
try:
    normalize_signal
except NameError:  # pragma: no cover

    def normalize_signal(res: dict) -> dict:
        # No-op: return as-is so runtime never crashes if helpers are absent
        return res or {}


try:
    assert_contract
except NameError:  # pragma: no cover

    def assert_contract(res: dict) -> bool:
        # Fail-soft: skip strict contract validation; gates will still apply
        return True


# ---------------------------------------------------------------


# safety: eğer tanımlı değilse no-op sürümü oluştur
if "should_block_trade" not in globals():

    def should_block_trade(*_a, **_k):
        return False, "ok"


# === Early lightweight logger (safe) ===


warnings.simplefilter(action="ignore", category=FutureWarning)


LAST_LOGGED_DEALS = set()
last_signal_minute = None  # en son sinyal zamanı
pending_signal = None
LAST_BAR_TIME = {}
LAST_MSG_SIG = {}
LAST_TRAIL_CHECK = {}
LAST_MGMT_RUN = 0
MODE_HB_NEXT = 0
LAST_CLOSED_CHECK = 0
STARTUP_SENT = False
LAST_TIME = {}
# removed duplicate MIN_TG_INTERVAL (using env-based definition)
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)
LAST_TG_SENT = {}
_last_trade_time = {}
LAST_STATUS_LINE = ""
LAST_STATUS_TIME = 0.0
STATUS_MIN_INTERVAL = 1.0
HANDLE_SIGNAL_LOCK = False
LAST_FORCE_TS = 0
DEBUG = int(os.getenv("DEBUG", "0")) == 1
load_dotenv()


SYMBOL = "GOLD"
LOT_SIZE = 0.10  # her işlemde kullanılacak lot miktarı
RISK_PERCENT = 0.02  # her işlemde bakiyenin %2’si risklenecek
PIP_VALUE = 0.01  # XAUUSD → 1 pip = 0.01 USD
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")
MIN_TG_INTERVAL = int(os.getenv("TG_MIN_INTERVAL", "3"))  # sn
_LAST_TG_SENT = 0.0
_STARTUP_SENT = False
BOOT_STARTED_AT = now_tr()
BOOT_GRACE_SEC = int(os.getenv("BOOT_GRACE_SEC", "60"))
POINTS_PER_PIP = float(os.getenv("POINTS_PER_PIP", "1"))


# === Pip Kovaları ===
pip_buckets = {
    "M15": (100, 200),
    "M30": (200, 300),
    "M45": (300, 400),
    "H1": (400, 500),
    "H2": (500, 600),
    "H3": (600, 700),
    "H4": (700, 1000),
    "H12": (1000, float("inf")),
}


# --- Pip helpers (tek doğru kaynak) ---
def _pip_size(si) -> float:
    point = getattr(si, "point", 0.01) or 0.01
    div = float(os.getenv("POINTS_PER_PIP", "1") or 1.0)
    return point * div


def _abs_pips(a: float, b: float, si) -> float:
    return abs(float(b) - float(a)) / _pip_size(si)


def ensure_sltp_and_request(
    symbol, si, side_txt: str, tf: str, res: dict, request: dict = None
):
    print(f"[TRACE] ensure_sltp_and_request ÇAĞRILDI -> side={side_txt}, tf={tf}")

    min_stop = si.trade_stops_level * si.point
    try:
        tick = mt5.symbol_info_tick(symbol)
        if not tick:
            print("[TRACE] tick bilgisi alınamadı")
            return "block", 0.0, 0.0, {"reasons": ["no_tick"], "retcode": None}

        entry = tick.ask if side_txt.upper() == "LONG" else tick.bid
        print(f"[TRACE] entry fiyatı belirlendi: {entry}")

        if res is None:
            res = {}
        sl = float(res.get("sl_price", 0.0))
        tp = float(res.get("tp_price", 0.0))
        print(f"[TRACE] başta sl={sl}, tp={tp}")

        # Burada RR fallback var
        rr_ratio = float(os.getenv("RR_RATIO", "2.0"))
        if sl > 0.0 and tp == 0.0:
            risk = abs(entry - sl)
            tp = entry + (
                risk * rr_ratio if side_txt.upper() == "LONG" else -risk * rr_ratio
            )
            print(f"[TRACE] RR fallback sonrası tp={tp}")

        # ATR fallback
        rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_H1, 0, 100)
        df = pd.DataFrame(rates)
        atr = calculate_atr(df, 14).iloc[-1]
        print(f"[TRACE] ATR={atr}")

        if sl == 0.0 or tp == 0.0:
            if atr and atr > 0:
                off = atr
                if side_txt.upper() == "LONG":
                    sl = entry - off
                    tp = entry + (off * rr_ratio)
                else:
                    sl = entry + off
                    tp = entry - (off * rr_ratio)
                print(f"[TRACE] ATR fallback sonrası sl={sl}, tp={tp}")
            else:
                return "block", 0.0, 0.0, {"reasons": ["no_sl_tp"], "retcode": None}

        print(f"[TRACE] SON KONTROL: entry={entry}, sl={sl}, tp={tp}")

        # Burada yön hatasını test ediyoruz
        if side_txt.upper() == "LONG":
            if sl >= entry:
                print(f"[🚨 HATA] LONG ama SL entry üstünde -> entry={entry}, sl={sl}")
            if tp <= entry:
                print(f"[🚨 HATA] LONG ama TP entry altında -> entry={entry}, tp={tp}")

        elif side_txt.upper() == "SHORT":
            if sl <= entry:
                print(f"[🚨 HATA] SHORT ama SL entry altında -> entry={entry}, sl={sl}")
            if tp >= entry:
                print(f"[🚨 HATA] SHORT ama TP entry üstünde -> entry={entry}, tp={tp}")

        return entry, sl, tp, request

    except Exception as e:
        print(f"[TRACE] EXCEPTION: {e}")
        return "block", 0.0, 0.0, {"reasons": [f"ensure_exc:{e}"], "retcode": None}


def debug_log(*args, force=False, **kwargs):
    """Safe logger: only prints when DEBUG=1/true or force=True; never raises."""
    try:
        dbg_env = os.getenv("DEBUG", "")
        dbg_flag = False
        if isinstance(dbg_env, str):
            dbg_flag = dbg_env.strip().lower() in ("1", "true", "on", "yes")
        elif isinstance(dbg_env, (int, float)):
            dbg_flag = bool(dbg_env)
        try:
            dbg_flag = dbg_flag or bool(globals().get("DEBUG", 0))
        except Exception:
            pass
        if not (dbg_flag or force):
            return
        ts = now_tr()(ZoneInfo("Europe/Istanbul")).strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{ts}]", *map(str, args), **kwargs)
    except Exception:
        pass


def active_trade_count(symbol: str = None) -> int:
    """Açık pozisyon sayısını döner. Sembol verilirse sadece o sembol için sayar."""
    try:
        positions = mt5.positions_get()
        if not positions:
            return 0
        if symbol:
            return sum(1 for p in positions if p.symbol == symbol)
        return len(positions)
    except Exception:
        return 0


def _patch_logger_safe():
    """Logging % formatting hatalarında çökmesin; gerekirse metni birleştirip bas."""
    _old_log = logging.Logger._log

    def _safe_log(self, level, msg, args, **kw):
        try:
            return _old_log(self, level, msg, args, **kw)
        except TypeError:
            # % yer tutucu yoksa argümanları string olarak ekle
            try:
                if args:
                    msg = f"{msg} " + " ".join(str(a) for a in args)
                return _old_log(self, level, msg, (), **kw)
            except Exception:
                print("[LOGSAFE FAIL]", msg, args)

    logging.Logger._log = _safe_log


_patch_logger_safe()  # << erken çağır


# --- GOLD/XAU sembolü çözümleyici -------------------------------------------
def resolve_gold_symbol() -> str | None:

    env = os.getenv("SYMBOL", os.getenv("GOLD_SYMBOL", "")).strip()
    if env:
        try:
            if mt5.symbol_select(env, True):
                return env
        except Exception:
            pass
    candidates = [
        "GOLD",
        "GOLDmicro",
        "GOLD.xm",
        "GOLDm",
        "XAUUSD",
        "XAUUSD.a",
        "XAUUSD.m",
        "XAUUSDmicro",
        "XAUUSD.xm",
        "XAUUSDm",
    ]
    for s in candidates:
        si = mt5.symbol_info(s)
        if si and mt5.symbol_select(s, True):
            return s
    for pat in ("GOLD*", "XAU*"):
        for si in mt5.symbols_get(pat) or []:
            if mt5.symbol_select(si.name, True):
                return si.name
    return None


# ---------------------------------------------------------------------------

MT5_ORDER_SEND = mt5.order_send
MT5_ORDER_CHECK = mt5.order_check


def is_paper() -> bool:
    return os.getenv("PAPER", "0") == "1"


# --- Güvenli sarmalayıcılar ---
def order_check_safe(request):
    if is_paper():
        # Broker'a dokunmadan "başarılı" retcode döndür
        return SimpleNamespace(retcode=0, comment="paper-check")
    return MT5_ORDER_CHECK(request)


def order_send_safe(request: dict, *, base_sleep: float = 0.3):
    """Emir gönderimi için güvenli kapı:
    - PAPER modda sahte başarı döndürür (broker'a gitmez)
    - İsteği normalize eder
    - BUY->ask, SELL->bid düzeltmesi yapar (fiyat yok/0 ise)
    - RETURN/IOC/FOK doldurma modlarını sırasıyla dener
    """
    # 0) PAPER: hiç broker'a gitme
    if is_paper():
        debug_log(f"[PAPER] would send: {request}")
        return SimpleNamespace(retcode=0, comment="paper-send", order=0)

    # 1) normalize
    req = _sanitize_request_plus(request)

    # 2) fiyatı garanti altına al (BUY->ask, SELL->bid)
    try:
        t = mt5.symbol_info_tick(req.get("symbol"))
        if t:
            if req.get("type") == mt5.ORDER_TYPE_BUY:
                if not req.get("price") or float(req["price"]) <= 0:
                    req["price"] = float(t.ask)
            elif req.get("type") == mt5.ORDER_TYPE_SELL:
                if not req.get("price") or float(req["price"]) <= 0:
                    req["price"] = float(t.bid)
    except Exception:
        pass

    # 3) broker’ın destekleyebileceği doldurma modlarını sırayla dene
    fillings = (
        getattr(mt5, "ORDER_FILLING_RETURN", 2),
        getattr(mt5, "ORDER_FILLING_IOC", 1),
        getattr(mt5, "ORDER_FILLING_FOK", 3),
    )
    last_result = None
    for f in fillings:
        req["type_filling"] = f
        result = MT5_ORDER_SEND(req)
        last_result = result
        if result and getattr(result, "retcode", -1) == getattr(
            mt5, "TRADE_RETCODE_DONE", 10009
        ):
            return result
        time.sleep(base_sleep)

    # Son denemenin sonucunu döndür (başarısızsa da)
    return last_result


# --- Proje genelinde kullanılacak alias'lar ---
RAW_ORDER_CHECK = order_check_safe
RAW_ORDER_SEND = order_send_safe
debug_log("[BOOT] RAW_ORDER_SEND ->", RAW_ORDER_SEND.__name__)


res = locals().get("res", globals().get("res", {}))

try:
    res
except NameError:
    res = {}
print(res.get("entry_price"))


# ===================== SL/TP seçici (SEVİYE-BAZLI) =====================
def _pick_levels_sltp(
    levels: dict,
    direction: str,
    entry: float,
    *,
    point: float,
    pip_div: float,
    atr_pips: float | None,
):
    PRIOR = ["OB", "BRK", "FVG", "FTR", "SD", "MSB", "LQ"]
    side = (direction or "LONG").upper()
    pip = point * (pip_div or 1.0)

    def _nearest(prices, want_gt):
        try:
            ps = sorted(float(x) for x in (prices or []) if x is not None)
        except Exception:
            ps = []
        if want_gt:
            cand = [p for p in ps if p > entry]
            return cand[0] if cand else None
        cand = [p for p in ps if p < entry]
        return cand[-1] if cand else None

    # SL
    sl_price = None
    for k in PRIOR:
        lvl = (levels or {}).get(k) or []
        sl_price = _nearest(lvl, want_gt=(side == "SHORT"))
        if sl_price:
            break

    # TP
    tp_price = None
    for k in PRIOR:
        lvl = (levels or {}).get(k) or []
        tp_price = _nearest(lvl, want_gt=(side == "LONG"))
        if tp_price:
            break

    sl_pips = abs(entry - sl_price) / pip
    tp_pips = abs(tp_price - entry) / pip
    return float(sl_price), float(tp_price), int(round(sl_pips)), int(round(tp_pips))


# fallback tanımlar (None kalmasın)
entry_price = float(res.get("entry_price") or res.get("entry", 0.0) or 0.0)
sl_price = float(res.get("sl_price") or 0.0)
tp_price = float(res.get("tp_price") or 0.0)


def compute_sl_tp_guard(
    symbol: str,
    direction: str,
    entry: float,
    sl: float = None,
    tp: float = None,
    si = None,
    tick = None
) -> dict:
    """
    SL/TP değerlerini güvenli şekilde hesaplar ve kontrol eder.
    
    Args:
        symbol (str): İşlem sembolü (örn: "GOLD")
        direction (str): İşlem yönü ("LONG" veya "SHORT")
        entry (float): Giriş fiyatı
        sl (float, optional): Stop Loss fiyatı. Varsayılan None.
        tp (float, optional): Take Profit fiyatı. Varsayılan None.
        si: Sembol bilgisi. Varsayılan None.
        tick: Anlık fiyat bilgisi. Varsayılan None.
    
    Returns:
        dict: SL/TP ve diğer bilgileri içeren sözlük
    """
    try:
        # Timestamp için
        ts = now_tr().strftime("%Y-%m-%d %H:%M:%S")
        debug_log(f"[{ts}] 🔄 compute_sl_tp_guard başladı: {direction} @ {entry}")

        # Sembol bilgilerini al
        if si is None:
            si = mt5.symbol_info(symbol)
        
        # Temel değerleri ayarla
        digits = getattr(si, "digits", 2) if si else 2
        point = getattr(si, "point", 0.01) if si else 0.01
        pip_div = float(os.getenv("POINTS_PER_PIP", "1") or 1.0)
        pip = point * pip_div

        # ATR hesaplama
        try:
            rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_H1, 0, 100)
            df = pd.DataFrame(rates)
            atr = df['high'].rolling(14).max() - df['low'].rolling(14).min()
            atr = float(atr.iloc[-1])
            debug_log(f"[{ts}] 📏 ATR: {atr}")
        except Exception as e:
            atr = pip * 10 # Varsayılan değer
            debug_log(f"[{ts}] ⚠️ ATR hesaplanamadı: {e}, varsayılan: {atr}")

        # Yuvarlama fonksiyonu
        def round_price(price):
            if price is None:
                return None
            return round(float(price), digits)

        side = direction.upper()
        debug_log(f"[{ts}] Yön: {side}, Entry: {entry}")

        # LONG pozisyonlar için SL/TP ayarla
        if side == "LONG":
            if sl is None or sl >= entry:
                sl = entry - (atr * 1.5)
                debug_log(f"[{ts}] ⚠️ LONG SL düzeltildi: {sl}")
            
            if tp is None or tp <= entry:
                tp = entry + (atr * 2.0)
                debug_log(f"[{ts}] ⚠️ LONG TP düzeltildi: {tp}")

        # SHORT pozisyonlar için SL/TP ayarla
        elif side == "SHORT":
            if sl is None or sl <= entry:
                sl = entry + (atr * 1.5)
                debug_log(f"[{ts}] ⚠️ SHORT SL düzeltildi: {sl}")
            
            if tp is None or tp >= entry:
                tp = entry - (atr * 2.0)
                debug_log(f"[{ts}] ⚠️ SHORT TP düzeltildi: {tp}")

        # Risk/Ödül oranını hesapla
        risk = abs(entry - sl)
        reward = abs(tp - entry)
        rr = reward / risk if risk > 0 else 0
        debug_log(f"[{ts}] 📊 Risk/Ödül oranı: {rr:.2f}")

        # Son kontroller
        entry = round_price(entry)
        sl = round_price(sl)
        tp = round_price(tp)

        debug_log(f"[{ts}] ✅ Son değerler -> Entry: {entry}, SL: {sl}, TP: {tp}")

        return {
            "price": entry,
            "sl_price": sl,
            "tp_price": tp,
            "pip": pip,
            "point": point,
            "digits": digits,
            "atr": atr,
            "rr_ratio": rr
        }

    except Exception as e:
        debug_log(f"[{ts}] 🚨 compute_sl_tp_guard HATA: {str(e)}")
        # Hata durumunda güvenli değerler döndür
        return {
            "price": entry if entry else 0.0,
            "sl_price": 0.0,
            "tp_price": 0.0,
            "pip": 0.01,
            "point": 0.01,
            "digits": 2,
            "atr": 0.0,
            "rr_ratio": 0.0
        }


# kabul edilen alanlar
_ALLOWED_REQ_KEYS = {
    "action",
    "position",
    "symbol",
    "volume",
    "type",
    "entry",
    "sl",
    "tp",
    "deviation",
    "magic",
    "comment",
    "type_time",
    "type_filling",
    "request_id",
}


# --- Hardened request sanitization & guards ---
def _get_symbol_meta(symbol):
    try:
        si = mt5.symbol_info(symbol)
        tick = mt5.symbol_info_tick(symbol)
        point = float(getattr(si, "point", 0.01) or 0.01) if si else 0.01
        digits = int(getattr(si, "digits", 2) or 2) if si else 2
        vol_min = float(getattr(si, "volume_min", 0.01) or 0.01) if si else 0.01
        vol_step = float(getattr(si, "volume_step", 0.01) or 0.01) if si else 0.01
        vol_max = float(getattr(si, "volume_max", 100.0) or 100.0) if si else 100.0
        return (si, tick, point, digits, vol_min, vol_step, vol_max)
    except Exception:
        return None, None, 0.01, 2, 0.01, 0.01, 100.0, 0, 0


def _round_to_step(x, step, minimum=None, maximum=None):
    try:
        if step <= 0:
            return x
        n = round((float(x) - (minimum or 0.0)) / step)
        val = (minimum or 0.0) + n * step
        if minimum is not None:
            val = max(val, minimum)
        if maximum is not None:
            val = min(val, maximum)
        return float(val)
    except Exception:
        return x


def _dir_from_type(t):
    # t may be int (mt5.ORDER_TYPE_*) or string
    try:
        if t == mt5.ORDER_TYPE_BUY:
            return "BUY"
        if t == mt5.ORDER_TYPE_SELL:
            return "SELL"
    except Exception:
        pass
    ts = str(t).upper()
    if "BUY" in ts:
        return "BUY"
    if "SELL" in ts:
        return "SELL"
    return "BUY"


def _sanitize_request(req: dict) -> dict:
    """Temel normalize: tip düzelt, defaultları ata."""
    base = dict(req or {})
    # sayı alanları
    for k in ("price", "sl", "tp", "volume"):
        if k in base and base[k] is not None:
            try:
                base[k] = float(base[k])
            except Exception:
                base[k] = 0.0
    # sapma & filling default
    if "deviation" in base:
        try:
            base["deviation"] = int(base["deviation"])
        except Exception:
            base["deviation"] = 20
    if "type_filling" not in base:
        # MT5 sabiti yoksa 2 (ORDER_FILLING_RETURN) varsay
        try:
            base["type_filling"] = getattr(mt5, "ORDER_FILLING_RETURN", 2)
        except Exception:
            base["type_filling"] = 2
    return base


def _sanitize_request_plus(req: dict) -> dict:
    """Genişletilmiş normalize: asla recurse etme; istenmeyen key'leri at."""
    # 🔒 kritik: burada _sanitize_request_plus(req) **DEĞİL**, _sanitize_request(req) çağrılır
    try:
        base = _sanitize_request(req)
    except NameError:
        # çok nadir: _sanitize_request henüz tanımlı değilse, güvenli kopya
        base = dict(req) if isinstance(req, dict) else req

    # burada ekstra “temizlikler”
    base.pop("retries", None)
    base.pop("raw", None)  # varsa log/artık veri
    base.pop("client", None)  # istemci nesnesini asla göndermeyelim

    # SL/TP float güvencesi (idempotent)
    for k in ("sl", "tp"):
        if k in base and base[k] is not None:
            try:
                base[k] = float(base[k])
            except Exception:
                base[k] = None

    return base


def fix_order_price(req: dict, guard: dict | None = None, tick=None):
    """BUY için price=ask, SELL için price=bid olacak şekilde emri normalize et.
    guard.price varsa onu, yoksa canlı tick'i kullanır. digits'e göre yuvarlar."""
    try:
        import MetaTrader5 as mt5
    except Exception:
        return req
    if not isinstance(req, dict):
        return req

    sym = req.get("symbol")
    si = mt5.symbol_info(sym) if sym else None
    digits = int(getattr(si, "digits", 2) or 2)

    if tick is None and sym:
        try:
            tick = mt5.symbol_info_tick(sym)
        except Exception:
            tick = None

    typ = req.get("type")

    def _roundf(x):
        try:
            return round(float(x), digits)
        except Exception:
            return req.get("price")

    if typ == getattr(mt5, "ORDER_TYPE_BUY", None):
        p = (guard or {}).get("price")
        if p is None and tick is not None:
            p = getattr(tick, "ask", None)
        if p is not None:
            req["price"] = _roundf(p)
    elif typ == getattr(mt5, "ORDER_TYPE_SELL", None):
        p = (guard or {}).get("price")
        if p is None and tick is not None:
            p = getattr(tick, "bid", None)
        if p is not None:
            req["price"] = _roundf(p)

    return req


def send_telegram_message(text: str) -> bool:
    """Telegram'a raw text gönder. Tüm gönderimler buradan geçsin."""
    global _LAST_TG_SENT
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        debug_log("[TG] token/chat id yok")
        return False
    now = time.time()
    if now - _LAST_TG_SENT < MIN_TG_INTERVAL:
        return False  # anti-spam
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text}
        r = requests.post(url, json=payload, timeout=6)
        ok = r.ok and r.json().get("ok", False)
        if ok:
            _LAST_TG_SENT = now
            return True
        debug_log(f"[TG ERROR] status={r.status_code} resp={r.text[:200]}")
    except Exception as e:
        debug_log(f"[TG EXC] {e}")
    return False


def send_full_diagnostic():
    try:
        report = []
        report.append("🛠 GOLD BOT DIAGNOSTIC REPORT 🛠\n")

        # Telegram bağlantısı
        report.append(
            f"📡 Telegram: {'OK' if TELEGRAM_TOKEN and TELEGRAM_CHAT_ID else 'MISSING'}"
        )

        # Saat
        now_local = now_tr()(ZoneInfo("Europe/Istanbul")).strftime("%Y-%m-%d %H:%M:%S")
        report.append(f"⏱ Local Time (Istanbul): {now_local}")

        # Limits
        report.append(
            f"\n⚖ Max Concurrent Trades: {os.getenv('MAX_CONCURRENT_TRADES','?')}"
        )
        report.append(f"⏳ Trade Cooldown: {os.getenv('TRADE_COOLDOWN_SEC','?')} sec")
        report.append(
            f"🔁 Allow Multiple Positions: {os.getenv('ALLOW_MULTIPLE_POSITIONS','?')}"
        )

        # Risk / lot
        report.append(f"\n💰 Lot Size: {LOT_SIZE} | Risk: {RISK_PERCENT*100:.2f}%")
        report.append(f"📊 Points per Pip: {POINTS_PER_PIP} | Pip Value: {PIP_VALUE}")

        # Aktif trade’ler
        trades = mt5.positions_get()
        report.append(f"\n📂 Active Trades: {len(trades)}")
        for t in trades or []:
            report.append(
                f" {t.symbol} {'BUY' if t.type==0 else 'SELL'} | "
                f"Entry:{t.price_open} | SL:{t.sl} | TP:{t.tp} | PnL:{t.profit:.2f} USD"
            )

        # TP kovaları
        report.append("\n🎯 TP Buckets:")
        for tf, rng in pip_buckets.items():
            report.append(f" {tf}: {rng}")

        # Son sinyal örneği (res dict varsa)
        if "res" in globals() and res:
            tf = res.get("timeframe")
            direction = res.get("direction")
            formasyon = res.get("formasyon")
            trues = res.get("trues", [])
            spread = res.get("spread_pts")
            atr = res.get("atr")
            rr = res.get("rr_ratio")
            passed = res.get("ok", False)

            report.append(f"\n📑 Son Sinyal ({tf}):")
            report.append(f" Yön: {direction}")
            report.append(f" Formasyon: {formasyon}")
            report.append(f" Teyitler: {', '.join(trues)}")
            report.append(f" Spread: {spread}")
            report.append(f" ATR: {atr}")
            report.append(f" RR: {rr}")
            report.append(f" Durum: {'PASS ✅' if passed else 'DROP ❌'}")

        # Mesajı gönder
        text = "\n".join(report)
        send_telegram_message(text)

    except Exception as e:
        debug_log(f"[DIAG ERROR] {e}")


def send_signal_message(tf: str, msg: str) -> bool:
    """Sadece LONG/SHORT giriş sinyali. (tf öne eklenmiyor.)"""
    if int(os.getenv("SEND_SIGNALS", "1")) != 1:
        return False
    text = str(msg)  # başına [tf] K O Y M A
    return send_telegram_message(text)


def send_target_message(
    side: str, target_pips, close_time, close_price: float, profit: float
) -> bool:
    """TP 'HEDEFTE' mesajı."""
    if int(os.getenv("SEND_TARGETS", "1")) != 1:
        return False
    try:
        when = close_time.astimezone(ZoneInfo("Europe/Istanbul")).strftime(
            "%Y-%m-%d %H:%M:%S"
        )
    except Exception:
        when = now_tr()(ZoneInfo("Europe/Istanbul")).strftime("%Y-%m-%d %H:%M:%S")
    text = (
        f"🎯XAUUSD {side} {int(target_pips)} PİP HEDEFTE | "
        f"ZAMAN: {now_tr()} | "
        f"KAPANIŞ: {close_price:.2f} 💰Kâr:{profit:.2f} USD"
    )
    return send_telegram_message(text)


def send_boot_once() -> None:
    """Bot başlatıldı mesajını 1 kez at."""
    global _STARTUP_SENT
    if _STARTUP_SENT or int(os.getenv("SEND_STARTUP", "1")) != 1:
        return
    if send_telegram_message("🚀 GOLDBot başlatıldı!"):
        _STARTUP_SENT = True
    send_full_diagnostic()


def rca_order(symbol: str, res: dict, tf: str = "", request: dict | None = None):
    """
    Order/sinyal neden gitmiyor? -> kök sebep raporu.
    SL/TP yanlış veya sıfır ise işlemi bloklar.
    """

    try:
        si = mt5.symbol_info(symbol)
        if not si:
            print(f"[RCA][{tf}] DROP: symbol_info yok -> {symbol}")
            return {"block": True, "reasons": ["no_symbol_info"], "retcode": None}

        tick = mt5.symbol_info_tick(symbol)
        bid = getattr(tick, "bid", 0.0) or 0.0
        ask = getattr(tick, "ask", 0.0) or 0.0

        direction = str((res or {}).get("direction", "LONG")).upper()
        side_txt = direction
        if direction == "LONG":
            side = mt5.ORDER_TYPE_BUY
            entry = ask
        else:
            side = mt5.ORDER_TYPE_SELL
            entry = bid

        # -------------------------------
        # SL / TP değerlerini al
        # -------------------------------
        sl = float((res or {}).get("sl_price") or 0.0)
        tp = float((res or {}).get("tp_price") or 0.0)

        # ❌ Eğer SL veya TP yoksa → işlemi blokla
        if sl == 0.0 or tp == 0.0:
            print(
                f"[RCA][{tf}] HATA: SL veya TP eksik! entry={entry}, sl={sl}, tp={tp}"
            )
            return {"block": True, "reasons": ["missing_sl_tp"], "retcode": None}

        # -------------------------------
        # LONG kontrolü
        # -------------------------------
        if side_txt == "LONG":
            if sl >= entry:
                print(
                    f"[RCA][{tf}] HATA: LONG ama SL entry üzerinde! entry={entry}, sl={sl}"
                )
                return {"block": True, "reasons": ["invalid_sl_long"], "retcode": None}
            if tp <= entry:
                print(
                    f"[RCA][{tf}] HATA: LONG ama TP entry altında! entry={entry}, tp={tp}"
                )
                return {"block": True, "reasons": ["invalid_tp_long"], "retcode": None}

        # -------------------------------
        # SHORT kontrolü
        # -------------------------------
        if side_txt == "SHORT":
            if sl <= entry:
                print(
                    f"[RCA][{tf}] HATA: SHORT ama SL entry altında! entry={entry}, sl={sl}"
                )
                return {"block": True, "reasons": ["invalid_sl_short"], "retcode": None}
            if tp >= entry:
                print(
                    f"[RCA][{tf}] HATA: SHORT ama TP entry üzerinde! entry={entry}, tp={tp}"
                )
                return {"block": True, "reasons": ["invalid_tp_short"], "retcode": None}

        # -------------------------------
        # Eğer buraya geldiyse SL/TP doğru
        # -------------------------------
        print(f"[RCA][{tf}] PASS ✅ entry={entry}, sl={sl}, tp={tp}")
        return {
            "block": False,
            "reasons": [],
            "side": side_txt,
            "entry": entry,
            "sl": sl,
            "tp": tp,
        }

    except Exception as e:
        print(f"[RCA][{tf}] EXC: {e}")
        return {"block": True, "reasons": [f"rca_exc:{e}"], "retcode": None}


def _safe_float(x, d=0.0):
    try:
        return float(x)
    except Exception:
        return d


def compute_rr_ratio(entry, sl, tp, point):
    """
    RR = reward / risk (pip cinsinden).
    Girişler string gelse bile float’a çevirir; point<=0 ise 0.01’e düşer.
    entry==sl veya entry==tp ise 0’a bölme yerine rr=0 döner.
    """
    e = _safe_float(entry, 0.0)
    s = _safe_float(sl, 0.0)
    t = _safe_float(tp, 0.0)
    p = _safe_float(point, 0.01)
    if p <= 0:
        p = 0.01

    risk_pips = abs(e - s) / p if e != s else 0.0
    reward_pips = abs(t - e) / p if t != e else 0.0

    if risk_pips <= 0:
        return 0.0, risk_pips, reward_pips

    return (reward_pips / risk_pips), risk_pips, reward_pips


def diagnose_and_maybe_order(
    tf: str, res: dict, *, send: bool = False, mode: str | None = None
):

    reasons: list[str] = []  # init once, before any append
    # --- Contract normalization & validation (optional) ---
    try:
        if "normalize_signal" in globals() and callable(normalize_signal):
            res = normalize_signal(res)
        if "assert_contract" in globals() and callable(assert_contract):
            if not assert_contract(res):
                try:
                    reasons.append("contract_missing")
                except Exception:
                    reasons = ["contract_missing"]
                print(f"[RCA][{tf}] DROP: contract_missing")
                return {"status": "DROP", "reasons": reasons}
    except Exception as _exc:
        # Helpers missing or failing: do not DROP; let downstream gates decide
        print(f"[RCA][{tf}] WARN: contract_check_skipped:{_exc}")
    """
    Sinyali teşhis eder, kapılardan (confirm, spread, rr, broker guard) geçirir,
    gerekiyorsa güvenli emir isteği hazırlar ve *opsiyonel* olarak gönderir.

    Bu sürüm, önceki dosyada görülen `UnboundLocalError: local variable 'j'` ve
    `dict object is not iterable` gibi hataları gidermek için sade/sağlam
    bir akış uygular. Eski anahtarlar korunmuştur: res['timeframe'],
    res['direction'], res['entry_price'], res['sl_price'], res['tp_price'], res['symbol'].
    """

    # --- SAFE CAST HELPERS (moved up to avoid _F UnboundLocalError) ---
    def _F(x, d=0.0):
        try:
            return float(x)
        except Exception:
            try:
                return float(str(x).replace(",", "."))
            except Exception:
                return d

    def _I(x, default=2):
        try:
            if x is None:
                return default
            if isinstance(x, int):
                return x
            if isinstance(x, float):
                return int(round(x))
            s = str(x).strip()
            return int(s) if s.lstrip("-").isdigit() else default
        except Exception:
            return default

    # ------------------------------------------------------------------

    try:
        import MetaTrader5 as mt5
    except Exception:  # test ortamı

        class _MT5:
            pass

        mt5 = _MT5()
        mt5.ORDER_TYPE_BUY = 0
        mt5.ORDER_TYPE_SELL = 1
        mt5.TRADE_ACTION_DEAL = 1

        def _noop(*a, **k):
            return None

        mt5.symbol_info = _noop
        mt5.symbol_info_tick = _noop

    # ---- Güvenli getter'lar ----
    def _get_si(symbol):
        try:
            return mt5.symbol_info(symbol)
        except Exception:
            return None

    def _get_tick(symbol):
        try:
            return mt5.symbol_info_tick(symbol)
        except Exception:
            return None

    symbol = (
        (res or {}).get("symbol")
        or os.getenv("GOLD_SYMBOL")
        or os.getenv("SYMBOL")
        or "GOLD"
    )
    si = _get_si(symbol)
    point = float(getattr(si, "point", 0.01) or 0.01)
    digits = int(getattr(si, "digits", 2) or 2)

    direction = str((res or {}).get("direction", "")).upper()
    is_short = direction == "SHORT"
    is_long = direction == "LONG"

    entry_price = float(res.get("entry_price") or 0.0)
    sl_price = float(res.get("sl_price") or 0.0)
    tp_price = float(res.get("tp_price") or 0.0)

    # Spread kontrolü sonuçları üst akıştan gelebilir; yoksa varsayılan serbest
    allow_spread = True
    spread_reason = "OK"
    if isinstance(res, dict) and "spread_why" in res:
        spread_reason = res.get("spread_why") or "OK"
        allow_spread = spread_reason in ("OK", "OFF", None, "")

    # RR hesapla (varsa)
    rr_ratio = 0.0

    try:
        risk = abs(entry_price - sl_price)
        reward = abs(tp_price - entry_price)
        if risk > 0:
            rr_ratio = reward / risk
    except Exception as e:
        rr_ratio = 0.0

    # --- SL/TP GUARD --- (compute_sl_tp_guard dict döndürür)
    try:
        guard = compute_sl_tp_guard(
            symbol=symbol,
            direction=("SHORT" if is_short else "LONG" if is_long else direction),
            entry=entry_price,
            sl=sl_price,
            tp=tp_price,
            si=si,
            tick=_get_tick(symbol),
        )
        if isinstance(guard, dict):
            sl_price = float(guard.get("sl_price", sl_price) or sl_price)
            tp_price = float(guard.get("tp_price", tp_price) or tp_price)
            digits = int(guard.get("digits", digits) or digits)
            point = float(guard.get("point", point) or point)
    except Exception as e:
        debug_log(f"[GUARD ERR] {e}")

    # --- Min RR filtresi ---
    try:
        min_rr = float(os.getenv("MIN_RR", "1.6") or 1.6)
    except Exception:
        min_rr = 1.6
    rr_ok = (rr_ratio is None) or (rr_ratio >= min_rr)

    # --- Confirm filtresi (TF bazlı) ---
    tf_used = str(res.get("timeframe") or tf or "?")

    # Yalnızca *sinyal aşamasında* (mum kapanışı) terminale detay bas:
    # res['phase'] == 'signal' ise veya PRINT_ON=1 ise yaz.
    _phase = str((res or {}).get("phase", "")).lower()
    _override = str(os.getenv("PRINT_ON", "0")).strip() in ("1", "true", "on", "yes")
    should_print = (_phase == "signal") or _override
    need_conf = get_confirm_threshold(tf_used)
    got_conf = 0
    try:
        got_conf = sum(1 for k, v in res.items() if isinstance(v, bool) and v)
    except Exception:
        got_conf = 0
    confirm_ok = got_conf >= need_conf

    # --- Final gate ---
    reasons = []
    if not allow_spread:
        reasons.append(f"spread:{spread_reason}")
    if not confirm_ok:
        reasons.append(f"confirm {got_conf}/{need_conf}")
    if not rr_ok:
        reasons.append(f"rr:{0.0 if rr_ratio is None else round(rr_ratio,2)}<{min_rr}")

    # RCA kaydı
    try:
        rca_order(symbol, res, tf=tf_used)
    except Exception:
        pass

    # Özet metni (terminal içi)
    try:
        summary = build_signal_msg(tf_used, res)
        debug_log(summary, force=True)
    except Exception as e:
        debug_log(f"[SUMMARY ERR] {e}")

    info = {
        "timeframe": tf_used,
        "allow": not reasons,
        "reasons": reasons,
        "entry_price": round(entry_price, digits),
        "sl_price": round(sl_price, digits),
        "tp_price": round(tp_price, digits),
        "rr": rr_ratio,
        "digits": digits,
        "point": point,
    }


def _extract_true_count(res) -> int | None:
    """Return TRUE count from res dict (flexible keys)."""
    if not isinstance(res, dict):
        return None
    for k in ("true_cols", "TRUE", "true_list", "true_count", "TRUE kolonlar", "true"):
        v = res.get(k)
        if isinstance(v, (list, tuple)):  # liste ise uzunluk
            return len(v)
        if isinstance(v, int):  # direkt sayı verilmişse
            return v
    return None


TF_ORDER = ["M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]  # ihtiyaca göre düzenle


def _status_line_str(by_tf: dict[str, dict]) -> str:
    parts = []
    for tf in TF_ORDER:
        need = get_confirm_threshold(tf)  # .env’den geliyor
        got = _extract_true_count(by_tf.get(tf, {}))
        parts.append(f"{tf}:{'-' if got is None else got}/{need}")
    return " | ".join(parts)


def _print_status_line(s: str):
    """Tek satırı terminalde güncelle (Windows uyumlu)."""
    cols = shutil.get_terminal_size((120, 20)).columns
    s = s[: max(10, cols - 1)]  # taşmayı engelle
    sys.stdout.write("\r" + s + " " * max(0, cols - len(s) - 1))
    sys.stdout.flush()


def deal_field(d, *names):
    """namedtuple/deal içinden alanı esnek al (reason/deal_reason/Reason vs.)."""
    for n in names:
        if hasattr(d, n):
            return getattr(d, n)
    if hasattr(d, "_asdict"):
        a = d._asdict()
        for n in names:
            if n in a:
                return a[n]
    return None


# === MT5 RETCODE açıklayıcı yardımcılar ============================


RETCODE_MAP = {
    getattr(mt5, "TRADE_RETCODE_DONE", 10009): "İŞLEM TAMAM (DONE)",
    getattr(mt5, "TRADE_RETCODE_PLACED", 10008): "EMİR YERLEŞTİ (PLACED)",
    getattr(mt5, "TRADE_RETCODE_REQUOTE", 10004): "REQUOTE (fiyat değişti)",
    getattr(mt5, "TRADE_RETCODE_PRICE_CHANGED", 10032): "FİYAT DEĞİŞTİ",
    getattr(mt5, "TRADE_RETCODE_OFFQUOTES", 10027): "OFFQUOTES (akış yok)",
    getattr(mt5, "TRADE_RETCODE_MARKET_CLOSED", 10018): "PİYASA KAPALI",
    getattr(mt5, "TRADE_RETCODE_NO_CONNECTION", 10006): "BAĞLANTI YOK",
    getattr(mt5, "TRADE_RETCODE_INVALID_EXPIRATION", 10019): "GEÇERSİZ EXPIRATION",
    getattr(mt5, "TRADE_RETCODE_INVALID_PRICE", 10015): "GEÇERSİZ FİYAT",
    getattr(mt5, "TRADE_RETCODE_TRADE_DISABLED", 10026): "SEMBOLDE TRADE KAPALI",
    getattr(mt5, "TRADE_RETCODE_NO_MONEY", 10031): "YETERSİZ BAKİYE",
}


def explain_retcode(code: int) -> str:
    return RETCODE_MAP.get(code, f"Bilinmeyen retcode {code}")


# ===================================================================


# --- TP kapanışını tanıyan helper ---------------------------------
def _is_tp_close(deal) -> bool:
    try:
        entry = getattr(deal, "entry", None)
        reason = getattr(deal, "reason", None)
        comment = (getattr(deal, "comment", "") or "").lower()
        is_out = entry == getattr(mt5, "DEAL_ENTRY_OUT", 1)
        is_tp_reason = reason == getattr(mt5, "DEAL_REASON_TP", 0)
        is_tp_comment = "tp" in comment
        return bool(is_out and (is_tp_reason or is_tp_comment))
    except Exception:
        return False


# -------------------------------------------------------------------


def calc_volume_by_risk(
    symbol: str, entry_price: float, sl_price: float, risk_percent: float
) -> float:
    """Calc volume by risk."""

    try:
        si = mt5.symbol_info(symbol)
        if not si:
            raise RuntimeError(f"symbol_info yok: {symbol}")

        point = si.point or 0.01
        # SL mesafesi (point cinsinden)
        risk_pts = abs(float(entry_price) - float(sl_price)) / point
        if risk_pts <= 0:
            return float(os.getenv("LOT", "0.10"))

        ai = mt5.account_info()
        balance = getattr(ai, "balance", 0.0) or getattr(ai, "equity", 0.0)
        risk_usd = balance * (float(risk_percent) / 100.0)

        # 1 lot için 1 point USD değeri
        if getattr(si, "trade_tick_value", 0) and getattr(si, "trade_tick_size", 0):
            usd_per_point_1lot = si.trade_tick_value / si.trade_tick_size
        else:
            # Fallback: projede varsa PIP_VALUE/ USD_PER_POINT kullan
            usd_per_point_1lot = float(
                globals().get("USD_PER_POINT", globals().get("PIP_VALUE", 1.0))
            )

        if usd_per_point_1lot <= 0:
            return float(os.getenv("LOT", "0.10"))

        vol = risk_usd / (risk_pts * usd_per_point_1lot)

        # Min/Max ve adım’a uydur
        vmin = getattr(si, "volume_min", 0.01) or 0.01
        vmax = getattr(si, "volume_max", 100.0) or 100.0
        vstep = getattr(si, "volume_step", 0.01) or 0.01

        vol = max(vmin, min(vol, vmax))
        vol = math.floor(vol / vstep) * vstep
        # görsellik için 2 ondalık (gerekirse artır)
        return round(vol, 2)
    except Exception:
        # Her ihtimale karşı sabit LOT’a dön
        return float(os.getenv("LOT", "0.10"))


def RAW_ORDER_SEND(request: dict, *, base_sleep: float = 0.3):
    """
    Order gönderme fonksiyonu.
    - Önce order_check ile broker kontrolü yapılır (neden reddettiğini görürüz).
    - Ardından order_send ile emir gönderilir.
    - Hatalı olursa alternatif filling modları denenir.
    - Geçici hatalarda retry yapılır.
    """

    def _explain(rc: int) -> str:
        """MT5 retcode açıklayıcı."""
        table = {
            getattr(mt5, "TRADE_RETCODE_DONE", 10009): "Emir işlendi",
            getattr(mt5, "TRADE_RETCODE_PLACED", 10008): "Emir yerleştirildi",
            getattr(mt5, "TRADE_RETCODE_REQUOTE", 10004): "Requote (fiyat değişti)",
            getattr(mt5, "TRADE_RETCODE_PRICE_CHANGED", 10032): "Fiyat değişti",
            getattr(mt5, "TRADE_RETCODE_OFF_QUOTES", 10027): "Off quotes",
            getattr(mt5, "TRADE_RETCODE_NO_CONNECTION", 10006): "Bağlantı yok",
            getattr(mt5, "TRADE_RETCODE_SERVER_BUSY", 10003): "Sunucu meşgul",
            getattr(mt5, "TRADE_RETCODE_TIMEOUT", 10010): "Zaman aşımı",
            getattr(
                mt5, "TRADE_RETCODE_INVALID_STOPS", 10030
            ): "Geçersiz SL/TP (stops)",
            getattr(
                mt5, "TRADE_RETCODE_INVALID_FILLING", 10028
            ): "Geçersiz filling modu",
            getattr(mt5, "TRADE_RETCODE_MARKET_CLOSED", 10018): "Piyasa kapalı",
            getattr(mt5, "TRADE_RETCODE_TRADE_DISABLED", 10017): "Trading kapalı",
        }
        return table.get(rc, f"Bilinmeyen retcode {rc}")

    try:
        # DEBUG: Gönderilen request parametrelerini yaz
        debug_log(f"[ORDER SEND] request={request}", force=True)

        # Broker’a order_check gönder → SL/TP hatası vs. öğren
        check = mt5.order_check(request)
        debug_log(f"[ORDER CHECK RESULT] {check}", force=True)

        if check:
            debug_log(f"[ORDER CHECK RETCODE] {check.retcode}", force=True)
            debug_log(
                f"[ORDER CHECK COMMENT] {getattr(check, 'comment', '')}", force=True
            )
            debug_log(
                f"[ORDER CHECK REQUEST] {getattr(check, 'request', {})}", force=True
            )
            debug_log(
                f"[ORDER CHECK RESULT] {getattr(check, 'result', {})}", force=True
            )

    except Exception as e:
        debug_log(f"[ORDER CHECK EXC] {e}", force=True)

    # filling mod sırası
    seq = [
        getattr(mt5, "ORDER_FILLING_IOC", None),
        getattr(mt5, "ORDER_FILLING_FOK", None),
        getattr(mt5, "ORDER_FILLING_RETURN", None),
    ]
    seq = [x for x in seq if x is not None]

    last_result = None
    req = dict(request)  # kopya

    for attempt in range(1, 4):  # max 3 deneme
        try:
            debug_log(f"[ORDER SEND CALL] attempt={attempt} req={req}", force=True)
            result = mt5.order_send(req)
            last_result = result

            if result is None:
                err = mt5.last_error()
                debug_log(
                    f"[ORDER SEND ERROR] None returned! last_error={err}", force=True
                )
                time.sleep(base_sleep * attempt)
                continue

            rc = int(getattr(result, "retcode", -1))
            desc = _explain(rc)
            debug_log(
                f"[ORDER SEND RESULT] retcode={rc} ({desc}) comment={getattr(result, 'comment', '')}",
                force=True,
            )

            # Başarılı sonuçlar
            if rc in (
                getattr(mt5, "TRADE_RETCODE_DONE", 10009),
                getattr(mt5, "TRADE_RETCODE_PLACED", 10008),
            ):
                return result

            # INVALID_FILLING → diğer doldurma moduna geç
            if rc == getattr(mt5, "TRADE_RETCODE_INVALID_FILLING", 10028):
                alt = None
                if req.get("type_filling") in seq:
                    i = seq.index(req.get("type_filling"))
                    alt = seq[(i + 1) % len(seq)] if len(seq) > 1 else None
                if alt is not None:
                    req["type_filling"] = alt
                    debug_log(
                        f"[ORDER SEND] filling mode switched to {alt}", force=True
                    )
                    time.sleep(0.1)
                    continue

            # Geçici hatalar → retry
            transient = {
                getattr(mt5, "TRADE_RETCODE_REQUOTE", 10004),
                getattr(mt5, "TRADE_RETCODE_PRICE_CHANGED", 10032),
                getattr(mt5, "TRADE_RETCODE_OFF_QUOTES", 10027),
                getattr(mt5, "TRADE_RETCODE_NO_CONNECTION", 10006),
                getattr(mt5, "TRADE_RETCODE_SERVER_BUSY", 10003),
                getattr(mt5, "TRADE_RETCODE_TIMEOUT", 10010),
            }
            if rc in transient:
                debug_log(
                    f"[ORDER SEND] transient error, retrying... rc={rc}", force=True
                )
                time.sleep(base_sleep * attempt)
                continue

            # Kalıcı hata → döngü kır
            break

        except Exception as e:
            debug_log(f"[ORDER SEND EXC] {e}", force=True)
            time.sleep(base_sleep * attempt)
            continue

    # Tüm denemeler başarısız oldu
    return last_result


def _order_send_proxy(request: dict):
    """Single safe entry-point for sending orders.
    - Sanitizes request
    - Always routes through RAW_ORDER_SEND (safe path)
    """
    req = _sanitize_request_plus(request)
    return RAW_ORDER_SEND(req)  # mt5.order_send/MT5_ORDER_SEND kullanma


# Tüm mevcut çağrıları otomatik güvenli hâle getir
RAW_ORDER_SEND = _order_send_proxy
# -------------------------------------------------------------------

# Trailing Stop mesafesi
TRAILING_DISTANCE = 200  # pip cinsinden

# Timeframe süreleri (saniye cinsinden)
TF_SECONDS = {
    "M15": 900,  # 15 dk
    "M30": 1800,  # 30 dk
    "M45": 2700,  # 45 dk
    "H1": 3600,  # 1 saat
    "H2": 7200,  # 2 saat
    "H3": 10800,  # 3 saat
    "H4": 14400,  # 4 saat
    "H12": 43200,  # 12 saat
    "D1": 86400,  # 1 gün
}


def get_latest_signals(signals_df: pd.DataFrame) -> dict:
    if signals_df is None or signals_df.empty:
        return {}

    # zaman: index'in son değeri → timezone'suz Timestamp
    t = signals_df.index[-1]
    t = pd.to_datetime(t, errors="coerce")
    if t is not None and hasattr(t, "tzinfo") and t.tzinfo is not None:
        t = t.tz_localize(None)

    last = signals_df.iloc[-1]

    clean = {"time": t}
    for col in signals_df.columns:
        if col == "score":
            continue
        val = last[col]
        # değer bool’a indirgenir
        if hasattr(val, "iloc"):
            val = val.iloc[-1]
        clean[col] = bool(val)

    return clean


def get_server_time():
    tick = mt5.symbol_info_tick(SYMBOL)
    if not tick:
        return now_tr()(ZoneInfo("Europe/Istanbul"))  # fallback: lokal saat
    return datetime.fromtimestamp(tick.time)


def is_candle_closing(tf, df: pd.DataFrame):
    if df is None or df.empty:
        return False

    # Son barın zamanını index’ten al
    last_candle_time = df.index[-1]

    # Eğer int tipindeyse → datetime’a çevir
    if isinstance(last_candle_time, (int, float)):
        last_candle_time = pd.to_datetime(last_candle_time, unit="s")

    # Şu anki zamanı al
    now = get_server_time()

    # O timeframe için mum kapanışını hesapla
    candle_close_time = last_candle_time + timedelta(seconds=TF_SECONDS[tf])

    # Mum kapanışına 1 dakika kala true dönsün
    return now >= candle_close_time - timedelta(seconds=60)


def check_tp_bucket(tf: str, entry: float, tp: float, symbol: str) -> bool:
    """
    TF bazlı TP pip kovası kontrolü.
    XAUUSD için 1 pip = 0.01 (PIP_VALUE).
    Aralık kuralı: [low, high) → alt sınır dahil, üst sınır hariç.
    Sınırda kalan 199.999999 gibi değerler için küçük bir tolerans (EPS) kullanılır.
    """
    EPS = 1e-6  # sınır toleransı

    # Kovayı al
    try:
        low, high = pip_buckets[tf]
    except KeyError:
        debug_log(f"[TP-KOVASI] Tanımsız TF: {tf}")
        return False

    # Hedef pips
    si = si if ("si" in locals() and si) else mt5.symbol_info(symbol)
    entry = float(locals().get("entry", locals().get("entry_price", 0.0)) or 0.0)
    tp = float(locals().get("tp", locals().get("tp_price", 0.0)) or 0.0)

    hedef_pip = round(_abs_pips(entry, tp, si), 1)
    # Üyelik testi (üst sınır hariç)
    inside = (hedef_pip + EPS) >= low and (hedef_pip - EPS) < high

    # Debug
    debug_log(
        f"[TP-KOVASI] tf={tf} | hedef_pip={hedef_pip:.1f} | aralık=({low},{high}) | "
        f"entry={entry:.2f} tp={tp:.2f} -> {'OK' if inside else 'RED'}"
    )

    return inside


def choose_target_pips(tf: str, mode: str = "fixed") -> int | None:

    if tf not in pip_buckets:
        return None  # ❌ tanımlı olmayan TF için pip döndürme
    low, high = pip_buckets[tf]

    if mode == "low":
        return low
    elif mode == "high":
        return low if high == float("inf") else high - 1  # üst sınır hariç
    elif mode == "mid":
        h = low if high == float("inf") else high - 1
        return (low + h) // 2
    elif mode == "random":
        return (
            low if high == float("inf") else random.randint(low, high - 1)
        )  # üst sınırı dışla
    else:
        return None


def choose_stop_loss(tf_df, direction, levels, tf="H1"):
    # ATR hesapla
    atr_values = calculate_atr(tf_df, period=14)
    atr_value = (
        float(atr_values.iloc[-1])
        if atr_values is not None and not atr_values.empty
        else 0
    )
    pip_value = 0.01  # XAUUSD -> 1 pip = 0.01 USD

    buffer_table = {
        "M15": atr_value * 0.5,
        "M30": atr_value * 0.5,
        "M45": atr_value * 0.5,
        "H1": atr_value * 0.5,
        "H2": atr_value * 0.5,
        "H3": atr_value * 0.5,
        "H4": atr_value * 0.5,
        "H12": atr_value * 0.5,
    }
    pip_buffer = buffer_table.get(tf, atr_value * 0.5)

    # Küçük TF'lerde farklı öncelik
    if tf in ["M15", "M30", "M45"]:
        priority = ["LQ", "SWING"]
    else:
        priority = ["OB", "BRK", "FVG", "FTR", "SD", "MSB", "LQ"]

    # Öncelikli seviyelerden SL seç
    for key in priority:
        level = levels.get(key)
        if level is not None:
            if isinstance(level, pd.Series):
                level = float(level.iloc[-1])
            else:
                level = float(level)
            return level, key

    # Eğer hiç seviye yoksa fallback → ATR
    last = tf_df.iloc[-1]
    if direction == "LONG":
        return float(last["low"]) - pip_buffer, "ATR-Fallback"
    else:
        return float(last["high"]) + pip_buffer, "ATR-Fallback"


try:

    load_dotenv()
except Exception:
    pass


def should_open_trade(eval_ctx: dict) -> bool:
    force_open = str(getenv("FORCE_OPEN", "0")) == "1"

    rr_ok = bool(eval_ctx.get("rr_ok", True))
    confirm_ok = bool(eval_ctx.get("confirm_ok", True))
    score_ok = bool(eval_ctx.get("score_ok", True))
    spread_ok = bool(eval_ctx.get("spread_ok", True))

    if force_open:
        rr_ok = confirm_ok = score_ok = spread_ok = True
        why = eval_ctx.get("why", [])
        why.append("FORCE_OPEN: tüm filtreler baypas")
        eval_ctx["why"] = why

    return rr_ok and confirm_ok and score_ok and spread_ok

    print("DBG-open:", should_open_trade)


# --- unified should_block_trade: TF rate-limit + eval_ctx desteği ---
def should_block_trade(arg=None):
    """
    arg bir dict (eval_ctx) ya da string (tf_used) olabilir.
    - dict gelirse: should_open_trade(eval_ctx) sonucunu tersine çevirir, 'why' notunu döner.
    - TF adı elde edilirse: MAX_TRADES_PER_TF_PER_DAY'a göre rate-limit uygular.
    Dönüş: (block: bool, why: str)
    """
    tf = None
    allow_ctx = None
    why = ""

    # 1) arg türünü çöz
    if isinstance(arg, dict):
        # eval_ctx → trade açılmalı mı?
        allow_ctx = should_open_trade(arg)
        wh = arg.get("why", "")
        if isinstance(wh, (list, tuple)):
            why = ";".join(str(x) for x in wh)
        elif isinstance(wh, str):
            why = wh or ""
        # tf adı varsa al
        tf = (
            arg.get("tf")
            or arg.get("timeframe")
            or arg.get("tf_used")
            or arg.get("tf_name")
        )
    elif isinstance(arg, str):
        tf = arg  # eski stil: sadece timeframe string

    # 2) eval_ctx ile geldiyse onun kararını uygula
    if allow_ctx is not None:
        return (not allow_ctx), (why or "ok")

    # 3) Aksi halde bloklama yok
    return False, "ok"

    print("DBG-block:", should_block_trade)


# --- /unified should_block_trade ---


# --- Trailing (.env) ---
TRAILING_MODE = os.getenv("TRAILING_MODE", "OFF").strip().upper()  # OFF | PIPS | ATR

# PIPS tabanlı trailing mesafesi
try:
    TRAILING_DISTANCE_PIPS = float(os.getenv("TRAILING_DISTANCE_PIPS", "150"))
except Exception:
    TRAILING_DISTANCE_PIPS = 150.0
TRAILING_DISTANCE_PIPS = max(0.0, TRAILING_DISTANCE_PIPS)

# ATR tabanlı trailing çarpanı
try:
    TRAILING_ATR_MULT = float(os.getenv("TRAILING_ATR_MULT", "1.0"))
except Exception:
    TRAILING_ATR_MULT = 1.0
TRAILING_ATR_MULT = max(0.0, TRAILING_ATR_MULT)

# Geriye dönük uyum (eski kod TRAILING_DISTANCE kullanıyorsa kırılmasın)
TRAILING_DISTANCE = int(TRAILING_DISTANCE_PIPS)

debug_log(
    "[ENV] TRAIL:",
    TRAILING_MODE,
    "| PIPS:",
    TRAILING_DISTANCE_PIPS,
    "| DIST:",
    TRAILING_DISTANCE,
    "| ATRx:",
    TRAILING_ATR_MULT,
)


def _env_list(key, default=""):
    s = os.getenv(key, default) or ""
    return [x.strip().upper() for x in s.split(",") if x.strip()]


# .env: TELEGRAM_WHITELIST=BOOT,SIGNAL,TARGET
_whitelist = set(_env_list("TELEGRAM_WHITELIST", "BOOT,SIGNAL,TARGET"))

# Tek kaynak: ALLOWED_TG
ALLOWED_TG = _whitelist or {"BOOT", "SIGNAL", "TARGET"}

# Eski kod TRAILING_DISTANCE kullanıyorsa kırılmasın:
TRAILING_DISTANCE = int(TRAILING_DISTANCE_PIPS)


# --- Confirm eşikleri (.env) ---------------------------------------


def _env_int(key, default):
    try:
        return int(os.getenv(key, str(default)))
    except:
        return default


TF_LIST = ["M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]
CONFIRM_DEFAULT = _env_int("CONFIRM_DEFAULT", 3)

CONFIRM_NEEDED = {tf: _env_int(f"CONFIRM_{tf}", CONFIRM_DEFAULT) for tf in TF_LIST}


def get_confirm_threshold(tf: str) -> int:
    return int(CONFIRM_NEEDED.get(tf.upper(), CONFIRM_DEFAULT))


# -------------------------------------------------------------------

debug_log(
    "[ENV] CONFIRM_NEEDED:",
    CONFIRM_NEEDED,
    "| TG_WHITELIST:",
    ALLOWED_TG,
    "| TRAIL_PIPS:",
    TRAILING_DISTANCE_PIPS,
    "-> DIST:",
    TRAILING_DISTANCE,
)

# --- Risk & Trailing (.env) ---
try:
    RISK_PERCENT = float(os.getenv("RISK_PERCENT", "0.02"))
except Exception:
    RISK_PERCENT = 0.02
RISK_PERCENT = max(0.0, min(RISK_PERCENT, 1.0))  # 0–1 arası sıkıştır

ATR_PERIOD = int(os.getenv("ATR_PERIOD", "14"))

TRAILING_MODE = (os.getenv("TRAILING_MODE", "OFF") or "OFF").upper()
if TRAILING_MODE not in {"OFF", "PIPS", "ATR"}:
    TRAILING_MODE = "OFF"

try:
    TRAILING_DISTANCE_PIPS = float(os.getenv("TRAILING_DISTANCE_PIPS", "0"))
except Exception:
    TRAILING_DISTANCE_PIPS = 0.0
TRAILING_DISTANCE_PIPS = max(0.0, TRAILING_DISTANCE_PIPS)

try:
    TRAILING_ATR_MULT = float(os.getenv("TRAILING_ATR_MULT", "1.0"))
except Exception:
    TRAILING_ATR_MULT = 1.0
TRAILING_ATR_MULT = max(0.0, TRAILING_ATR_MULT)

D1_TREND_MODE = os.getenv("D1_TREND_MODE", "OFF").upper()  # OFF | SOFT | HARD
try:
    D1_TREND_MA = int(os.getenv("D1_TREND_MA", "50"))
except Exception:
    D1_TREND_MA = 50

if D1_TREND_MODE not in {"OFF", "SOFT", "HARD"}:
    D1_TREND_MODE = "OFF"

    debug_log(
        f"[BOOT] D1_TREND_MODE={D1_TREND_MODE} D1_TREND_MA={D1_TREND_MA}", force=True
    )


TP_MODE = os.getenv("TP_BUCKET", "RANDOM").upper()
if TP_MODE not in {"RANDOM", "LOW", "MID", "HIGH", "FIXED"}:
    TP_MODE = "RANDOM"


def get_target_pips(tf: str) -> int | None:
    # choose_target_pips'i .env’deki TP_MODE ile çağırır
    return choose_target_pips(tf, mode=TP_MODE.lower())


SPREAD_MODE = os.getenv("SPREAD_MODE", "AUTO").upper()  # SOFT | HARD | AUTO
MAX_SPREAD_POINTS = int(
    os.getenv("MAXIMUM_SPREAD_POINTS", "40")
)  # .env'deki isim aynen böyle
MAX_SPREAD_SL_RATIO = float(os.getenv("MAX_SPREAD_SL_RATIO", "0.20"))

TZ_NAME = os.getenv("TIMEZONE", "Europe/Istanbul")

HARD_WINDOWS = os.getenv("HARD_WINDOWS", "")  # "16:30-16:45, 17:00-17:10" gibi
SOFT_WINDOWS = os.getenv("SOFT_WINDOWS", "")

if SPREAD_MODE not in {"SOFT", "HARD", "AUTO"}:
    SPREAD_MODE = "SOFT"

MAX_SPREAD_POINTS = max(0.0, MAX_SPREAD_POINTS)
MAX_SPREAD_SL_RATIO = min(max(0.0, MAX_SPREAD_SL_RATIO), 1.0)

# ---- SPREAD modu: AUTO → saat pencerelerine göre HARD/SOFT ----

# --- Confirm (teyit) eşikleri (.env) ---
TF_LIST = ["M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]


def _get_confirm_needed(tf: str) -> int:
    # TF’e özel yoksa CONFIRM_DEFAULT’u al; sayı değilse 3’e düş
    v = os.getenv(f"CONFIRM_{tf}")
    if v is None:
        v = os.getenv("CONFIRM_DEFAULT", "3")
    try:
        return max(0, int(v))
    except Exception:
        return 3


CONFIRM_NEEDED = {tf: _get_confirm_needed(tf) for tf in TF_LIST}
debug_log(f"[BOOT] CONFIRM_NEEDED={CONFIRM_NEEDED}", force=True)


def local_time() -> _dt_time:
    """ENV'deki TZ_NAME'e göre yerel saat nesnesi (datetime.time) döndürür."""
    return now_tr()(ZoneInfo("Europe/Istanbul"))


def _parse_windows(s: str):
    # "16:30-16:45,17:00-17:10" -> [(16:30,16:45), (17:00,17:10)]
    wins = []
    if not s:
        return wins
    for part in s.split(","):
        part = part.strip()
        if not part:
            continue
        try:
            a, b = part.split("-")
            h1, m1 = map(int, a.split(":"))
            h2, m2 = map(int, b.split(":"))
            wins.append((_dt_time(h1, m1), _dt_time(h2, m2)))
        except Exception:
            # hatalı parça -> görmezden gel
            continue
    return wins


def _in_windows(now: _dt_time, windows) -> bool:
    """Verilen 'now' (datetime.time) belirtilen saat aralıklarından birinin içinde mi?"""
    if not windows:
        return False

    t = now  # <- ÖNEMLİ: artık local_time() çağırmıyoruz, parametreyi kullanıyoruz

    for s, e in windows:
        if s <= e:
            # normal aralık (örn. 16:30–16:45)
            if s <= t <= e:
                return True
        else:
            # gece devreden aralık (örn. 23:50–00:10)
            if t >= s or t <= e:
                return True
    return False


HARD_W = _parse_windows(HARD_WINDOWS or "")
SOFT_W = _parse_windows(SOFT_WINDOWS or "")


def get_effective_spread_mode() -> str:
    """
    SPREAD_MODE = AUTO ise saat pencerelerine göre HARD/SOFT seç.
    Hiçbir pencereye düşmezse default SOFT döndür (None asla yok).
    """
    base = (SPREAD_MODE or "SOFT").upper()
    if base != "AUTO":
        return base

    now = local_time()

    # Önce HARD penceresi mi?
    if _in_windows(now, HARD_W):
        return "HARD"
    # Değilse SOFT penceresi mi?
    if _in_windows(now, SOFT_W):
        return "SOFT"

    # AUTO ama hiçbir pencereye girmedi → default
    return "SOFT"


# === Telegram Ayarları ===
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
MIN_TG_INTERVAL = float(os.getenv("MIN_TG_INTERVAL", "2.0"))

# anti-spam
try:
    MIN_TG_INTERVAL = float(os.getenv("MIN_TG_INTERVAL", "2.0"))
except Exception:
    pass  # inserted to satisfy block
# removed duplicate MIN_TG_INTERVAL (using env-based definition)
LAST_TG_SENT = 0.0  # başlangıç


def diagnose_now(tf: str, res: dict) -> None:
    """
    Kapanışı/TF döngüsünü beklemeden 'neden açmıyorum?' sorusuna anında cevap verir.
    Açmama nedenlerini tek tek listeler; SL/TP korumasını da simüle eder.
    """
    reasons = []

    # 1) Yön / teyit sayısı
    direction = str(res.get("direction", "")).upper()
    if direction not in ("LONG", "SHORT"):
        reasons.append("direction:NONE")

    try:
        need = get_confirm_threshold(tf)
        got = sum(1 for k, v in res.items() if isinstance(v, bool) and v)
        if got < need:
            reasons.append(f"confirm {got}/{need}")
    except Exception:
        reasons.append("confirm_err")

    # 2) Spread kapısı
    try:
        allow, why = spread_gate(direction, os.getenv("SPREAD_MODE", "AUTO"))
        if not allow:
            reasons.append(f"spread:{why}")
    except Exception:
        reasons.append("spread_err")

    # 3) RR eşiği
    try:
        min_rr = float(os.getenv("MIN_RR", "0"))
    except Exception:
        min_rr = 0.0
    rr = res.get("rr")
    if rr is None or (isinstance(rr, (int, float)) and rr < min_rr):
        reasons.append(f"rr:{rr}")

    # 4) SL/TP mevcut mu?
    entry = float(res.get("entry_price") or 0.0)
    sl = float(res.get("sl_price") or 0.0)
    tp = float(res.get("tp_price") or 0.0)
    if entry == 0.0 or sl == 0.0 or tp == 0.0:
        reasons.append(f"sl/tp missing -> sl={sl} tp={tp}")

    # 5) Sembol & tick
    symbol = (
        res.get("symbol") or os.getenv("GOLD_SYMBOL") or os.getenv("SYMBOL") or "GOLD"
    )
    if not mt5.symbol_select(symbol, True):
        reasons.append(f"symbol not tradable -> {symbol}")

    si = mt5.symbol_info(symbol)
    if not si:
        reasons.append("symbol_info:none")
        point, digits = 0.01, 2
    else:
        point = si.point or 0.01
        digits = si.digits or 2

    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        reasons.append("tick:none")
        price = entry
    else:
        price = tick.ask if direction == "LONG" else tick.bid

    buf = point  # küçük tampon (1 point)
    base = entry if entry else price  # giriş baz fiyatı (BUY->ask, SELL->bid)

    # Mevcut sl/tp'yi çek
    sl_g = float(sl or 0.0)
    tp_g = float(tp or 0.0)

    if direction == "LONG":
        if sl_g <= 0.0:
            sl_g = base - buf
        if tp_g <= 0.0:
            tp_g = base + buf
    else:  # SHORT
        if sl_g <= 0.0:
            sl_g = base + buf
        if tp_g <= 0.0:
            tp_g = base - buf

    # Broker basamaklarına yuvarla
    sl_g = round(sl_g, digits)
    tp_g = round(tp_g, digits)

    # --- güvenli pips log'u: tf yoksa sessiz geç + bölme hatasına karşı korumalı ---
    try:
        tf_label = str(tf)  # bazı yerlerde yok; sorun olmasın
    except Exception:
        tf_label = ""

    try:
        p = float(point)  # 'point' sayı değilse bile düşmesin
    except Exception:
        p = 0.01

    def _to_pips(dist):
        try:
            return float(dist) / p if p else 0.0
        except Exception:
            return 0.0

    # 7) Lot/volume
    try:
        rp = float(os.getenv("RISK_PERCENT", "0"))
    except Exception:
        rp = 0.0
    volume = 0.0
    try:
        if rp > 0 and entry and sl:
            volume = calc_volume_by_risk(symbol, entry, sl_g, rp)
        else:
            volume = float(os.getenv("LOT", "0.10"))
    except Exception:
        volume = float(os.getenv("LOT", "0.10"))

    if not volume or volume <= 0:
        reasons.append(f"lot/volume:{volume}")

    # 8) TP kovası vs (varsa)
    try:
        if not check_tp_bucket(tf, entry, tp):
            reasons.append("tp_bucket")
    except Exception:
        # opsiyonel: yoksa görmezden gel
        pass

    # Özet log
    pre_risk = abs(entry - sl) / point if entry and sl else 0.0
    pre_rew = abs(tp - entry) / point if tp and entry else 0.0
    guard_r = abs(entry - sl_g) / point if entry and sl_g else 0.0
    guard_rw = abs(tp_g - entry) / point if tp_g and entry else 0.0
    side_txt = (
        "BUY" if direction == "LONG" else ("SELL" if direction == "SHORT" else "-")
    )

    debug_log(
        f"[DIAG {tf}] side={side_txt} sym={symbol} "
        f"entry={entry:.{digits}f} sl={sl:.{digits}f}->{sl_g:.{digits}f} "
        f"tp={tp:.{digits}f}->{tp_g:.{digits}f} price={price:.{digits}f} "
        f"pre_risk={pre_risk:.1f}p pre_rew={pre_rew:.1f}p "
        f"guard_risk={guard_r:.1f}p guard_rew={guard_rw:.1f}p "
    )

    if reasons:
        debug_log(f"[DIAG {tf}] DROP -> " + ", ".join(reasons))
    else:
        debug_log(f"[DIAG {tf}] PASS -> Tüm kapılar OK (dry-run)")


# Telegram mesajı (istersen)
def build_signal_msg(tf, res):
    trues = [k for k, v in res.items() if isinstance(v, bool) and v]
    note = res.get("spread_note") or res.get("trend_note") or ""
    base = (
        f"✅[{tf}] sinyali\n"
        f"Yön: {res.get('direction','-')}\n"
        f"Formasyon: {res.get('formasyon','-')}\n"
        f"TRUE kolonlar: {trues}"
    )
    return base + (f"\n{note}" if note else "")


# --- Basit tekilleştirme kapısı (aynı dakika/aynı içerik tekrarını engelle) ---


def _msg_key(tf: str, res: dict) -> tuple:
    # dakika, yön, formasyon ve TRUE olan kolonlar
    try:

        minute = pd.to_datetime(res.get("time")).floor("T").strftime("%Y-%m-%d %H:%M")
    except Exception:
        minute = ""
    direction = res.get("direction", "")
    formasyon = res.get("formasyon", "")
    true_cols = tuple(sorted(k for k, v in res.items() if isinstance(v, bool) and v))
    return (minute, direction, formasyon, true_cols)


def remember_msg(tf: str, res: dict) -> None:
    LAST_MSG_SIG[tf] = _msg_key(tf, res)


def is_duplicate_msg(tf: str, res: dict) -> bool:
    return False


# === MetaTrader 5 Ayarları ===
MT5_LOGIN = int(os.getenv("MT5_LOGIN"))
MT5_PASSWORD = os.getenv("MT5_PASSWORD")
MT5_SERVER = os.getenv("MT5_SERVER")
SYMBOL = os.getenv("GOLD_SYMBOL", "GOLD")
LOT = float(os.getenv("LOT", 0.10))


# === Özel 45 Dakika Timeframe ===
TIMEFRAMES = {
    "M15": mt5.TIMEFRAME_M15,
    "M30": mt5.TIMEFRAME_M30,
    "H1": mt5.TIMEFRAME_H1,
    "H2": mt5.TIMEFRAME_H2,
    "H3": mt5.TIMEFRAME_H3,
    "H4": mt5.TIMEFRAME_H4,
    "H12": mt5.TIMEFRAME_H12,
    "D1": mt5.TIMEFRAME_D1,
}


# === Özel 45 Dakika Ortalama (15m + 30m) ===
def get_mixed_45m(symbol, num_bars=200):
    # M15 verisini çek
    rates_15 = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_M15, 0, num_bars * 3)
    # M30 verisini çek
    rates_30 = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_M30, 0, num_bars * 2)

    if rates_15 is None or rates_30 is None:
        debug_log("Veri alınamadı")
        return None

    # 15 dk dataframe
    df15 = pd.DataFrame(rates_15)
    df15["time"] = pd.to_datetime(df15["time"], unit="s")
    df15.set_index("time", inplace=True)
    df15["avg_price"] = (df15["open"] + df15["high"] + df15["low"] + df15["close"]) / 4

    # 30 dk dataframe
    df30 = pd.DataFrame(rates_30)
    df30["time"] = pd.to_datetime(df30["time"], unit="s")
    df30.set_index("time", inplace=True)
    df30["avg_price"] = (df30["open"] + df30["high"] + df30["low"] + df30["close"]) / 4

    # Zaman indeksine göre birleştir
    df = pd.concat([df15["avg_price"], df30["avg_price"]], axis=1)
    df.columns = ["avg15", "avg30"]

    # 45 dakikada ortalama al
    df_45m = pd.DataFrame()
    df_45m["avg15"] = df["avg15"].resample("45T").mean()
    df_45m["avg30"] = df["avg30"].resample("45T").mean()
    df_45m["mixed_avg"] = df_45m[["avg15", "avg30"]].mean(axis=1)

    df_45m.dropna(inplace=True)
    return df_45m


# ========= Configuration =========
CONFIG = {
    # General
    "doji_frac": 0.10,  # body <= range * doji_frac
    "engulf_factor": 1.0,  # current body >= prev body * factor
    "pin_wick_ratio": 2.5,  # long wick >= body * ratio
    "pin_edge_pct": 0.30,  # close near edge: <= range * pct
    "harami_body_frac": 1.0,  # current body <= prev body * frac
    "marubozu_shadow_frac": 0.10,  # total shadows <= range * frac
    "three_candle_body_frac": 0.6,  # soldiers/crows: body >= range * frac
    "ib_min_inside_frac": 0.0,  # inside bar strictness (0=classic)
    "tweezer_tol_pct": 0.0015,  # equal highs/lows tolerance ratio
    "equal_level_tol": 0.0020,  # equality tolerance for sweeps/doubles
    "pivot_lookback": 2,  # local pivot detection neighborhood
    "window_chart_patterns": 120,  # scan window for chart patterns
    "range_narrow_frac": 0.75,  # wedges: range narrowing threshold
    "triangle_min_span": 15,  # min bars in window for triangles/wedges
    "slope_eps": 1e-9,  # numeric epsilon for slope checks
    "abcd_tol": 0.15,  # AB=CD: |AB - CD| <= tol * max(|AB|,|CD|)
    "abcd_bc_min": 0.382,  # BC retracement min
    "abcd_bc_max": 0.786,  # BC retracement max
    "wolfe_tol": 0.02,  # Wolfe heuristic tolerance
    "wedge_lookback": 80,
    "wedge_pivot_lb": 2,
    "wedge_min_touchers": 3,
    "wedge_converge_tol": 0.12,
    "wedge_pretrend_lb": 60,
    "wedge_allow_counter": True,
    "wedge_buffer_pips": 10,
    "cup_lookback": 120,
    "cup_rim_tol": 0.01,
    "cup_handle_min": 5,
    "cup_handle_max": 25,
    "cup_handle_ret_min": 0.2,
    "cup_handle_ret_max": 0.5,
    "pattern_buffer_pips": 10,
}


SAFEY_PIPS = float(os.getenv("SLTP_SAFETY_PIPS", "0.5"))


# ========= Helpers =========
def _require_cols(df: pd.DataFrame):
    req = {"open", "high", "low", "close"}
    miss = req - set(df.columns)
    if miss:
        raise ValueError(f"Missing required columns: {miss}")


def _prep(df: pd.DataFrame) -> pd.DataFrame:
    _require_cols(df)
    d = df.copy()
    d = d.astype(
        {"open": "float64", "high": "float64", "low": "float64", "close": "float64"}
    )
    d["body"] = (d["close"] - d["open"]).abs()
    d["range"] = (d["high"] - d["low"]).replace(0, np.nan)
    upper_base = np.maximum(d["open"], d["close"])
    lower_base = np.minimum(d["open"], d["close"])
    d["upper_wick"] = d["high"] - upper_base
    d["lower_wick"] = lower_base - d["low"]
    d["bull"] = d["close"] > d["open"]
    d["bear"] = ~d["bull"]
    return d


def _pivot_highs(s: pd.Series, lb: int) -> pd.Series:
    # local max relative to neighbors within +/- lb
    cond = s.rolling(lb * 2 + 1, center=True).apply(
        lambda a: a[lb] == np.nanmax(a), raw=True
    )
    return cond.astype(bool)


def _pivot_lows(s: pd.Series, lb: int) -> pd.Series:
    cond = s.rolling(lb * 2 + 1, center=True).apply(
        lambda a: a[lb] == np.nanmin(a), raw=True
    )
    return cond.astype(bool)


def _lin_slope(y: pd.Series) -> float:
    n = len(y)
    if n < 2:
        return 0.0
    x = np.arange(n, dtype=float)
    den = (n * (n - 1) * (2 * n - 1) / 6) - ((n - 1) * n / 2) ** 2 / n
    if abs(den) < 1e-12:
        den = 1e-12
    x_mean = (n - 1) / 2.0
    y_mean = y.mean()
    num = ((x - x_mean) * (y.values - y_mean)).sum()
    return num / den


def _last_window(df: pd.DataFrame, n: int) -> pd.DataFrame:
    if len(df) <= n:
        return df.copy()
    return df.iloc[-n:].copy()


def get_ohlc(
    symbol,
    timeframe=mt5.TIMEFRAME_M15,
    bars: int = 500,
    *,
    base_sleep: float = 0.3,
    max_try: int = 2,
) -> pd.DataFrame:
    """MT5'ten OHLC çek; küçük retry yap; asla exception fırlatma.
    Başarısız olursa Boş DataFrame döner (çağıran kontrol eder).
    """
    for i in range(1, max_try + 1):  # 1..max_try
        try:
            rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, bars)
        except Exception as e:
            rates = None
            try:
                logger.warning(
                    "[MT5] copy_rates_from_pos EXC (try %d/%d): %s", i, max_try, e
                )
            except Exception:
                debug_log(
                    f"[MT5] copy_rates_from_pos EXC (try {i}/{max_try}): {e}",
                    force=True,
                )

        if rates is not None and len(rates) > 0:
            try:
                df = pd.DataFrame(rates)
                # epoch saniyeyi datetime'a çevir (naive/yerel)
                try:
                    df["time"] = pd.to_datetime(df["time"], unit="s")
                except Exception:
                    pass
                return df
            except Exception as e:
                try:
                    logger.warning(
                        "[MT5] rates->DataFrame EXC (try %d/%d): %s", i, max_try, e
                    )
                except Exception:
                    debug_log(
                        f"[MT5] rates->DataFrame EXC (try {i}/{max_try}): {e}",
                        force=True,
                    )

        # boş/None: bilgi amaçlı log + kısa bekleme
        try:
            err = mt5.last_error()  # (code, desc)
        except Exception:
            err = None

        try:
            logger.warning(
                "[MT5] copy_rates_from_pos boş/None (deneme %d/%d) last_error=%s",
                i,
                max_try,
                repr(err),
            )
        except Exception:
            debug_log(
                f"[MT5] copy_rates_from_pos boş/None (deneme {i}/{max_try}) last_error={err}",
                force=True,
            )

        try:
            _time.sleep(max(0.0, base_sleep) * i)  # 0.3s, 0.6s, ...
        except Exception:
            pass

    # tüm denemeler bittiyse boş DataFrame
    try:
        logger.warning(
            "[MT5] get_ohlc EMPTY return for %s tf=%s bars=%d",
            symbol,
            str(timeframe),
            bars,
        )
    except Exception:
        debug_log(
            f"[MT5] get_ohlc EMPTY return for {symbol} tf={timeframe} bars={bars}",
            force=True,
        )
    return pd.DataFrame()


# --------------------------------------------------------------------


# ========= Candle / Bar Formations =========


def engulfing_strong(data, ema=None, use_volume=True, strong=True, lookback_trend=5):
    if len(data) < 2:
        return False, False

    last = data.iloc[-1]
    prev = data.iloc[-2]

    tol = 0.2 * PIP_VALUE
    rng_last = max(last["high"] - last["low"], 1e-9)
    body_last = abs(last["close"] - last["open"])
    rng_prev = max(prev["high"] - prev["low"], 1e-9)
    body_prev = abs(prev["close"] - prev["open"])

    # doji/ufak gövdeyi ele
    if body_last / rng_last < CONFIG.get("doji_frac", 0.10):
        return False, False

    # wick/gövde oranı (fitilli sahte sinyal filtresi)
    if body_last < CONFIG.get("engulf_factor", 1.0) * body_prev:
        return False, False

    # temel engulf koşulları (gövde gövdeyi sarıyor)
    bull_core = (
        prev["close"] < prev["open"]
        and last["close"] > last["open"]
        and last["open"] <= prev["close"] + tol
        and last["close"] >= prev["open"] - tol
    )
    bear_core = (
        prev["close"] > prev["open"]
        and last["close"] < last["open"]
        and last["open"] >= prev["close"] - tol
        and last["close"] <= prev["open"] + tol
    )

    if strong:
        bull_core = bull_core and (last["close"] >= prev["high"] - tol)
        bear_core = bear_core and (last["close"] <= prev["low"] + tol)

    # Trend teyidi (opsiyonel)
    if ema is not None and len(data) >= lookback_trend:
        ema_val = float(ema.iloc[-1]) if hasattr(ema, "iloc") else float(ema)
        bull_core = bull_core and (last["close"] > ema_val)
        bear_core = bear_core and (last["close"] < ema_val)

    # Hacim teyidi (opsiyonel)
    if use_volume and "tick_volume" in data.columns and len(data) >= 20:
        vol_ok = (
            data["tick_volume"].iloc[-1]
            > data["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull_core = bull_core and vol_ok
        bear_core = bear_core and vol_ok

    return bool(bull_core), bool(bear_core)


def pinbar_strict(
    data,
    direction=None,
    wick_ratio=2.5,
    body_frac=0.25,
    close_quartile=True,
    ema=None,
    use_volume=True,
):
    """
    direction: "bull", "bear" ya da None (ikisini de döndür)
    wick_ratio: fitil/gövde oranı eşiği
    body_frac: body/range üst sınırı (doji filtre)
    close_quartile: close'un uç çeyrekte olma şartı
    """
    if len(data) < 1:
        return False, False
    last = data.iloc[-1]

    high, low = float(last["high"]), float(last["low"])
    open_, close = float(last["open"]), float(last["close"])
    rng = max(high - low, 1e-9)
    body = abs(close - open_)
    up_w = high - max(open_, close)
    low_w = min(open_, close) - low

    # gövde küçük olsun
    if body / rng > body_frac:
        return False, False

    # kapanış konumu (opsiyonel)
    ok_upper = close >= low + 0.75 * rng
    ok_lower = close <= low + 0.25 * rng
    if close_quartile:
        bull_quart_ok = ok_upper
        bear_quart_ok = ok_lower
    else:
        bull_quart_ok = bear_quart_ok = True

    # fitil oranları
    bull = (low_w >= wick_ratio * body) and bull_quart_ok
    bear = (up_w >= wick_ratio * body) and bear_quart_ok

    # trend filtresi (opsiyonel)
    if ema is not None:
        ema_v = float(ema.iloc[-1]) if hasattr(ema, "iloc") else float(ema)
        bull = bull and (close > ema_v)
        bear = bear and (close < ema_v)

    # hacim teyidi (opsiyonel)
    if use_volume and "tick_volume" in data.columns and len(data) >= 20:
        vol_ok = (
            data["tick_volume"].iloc[-1]
            > data["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return bool(bull), bool(bear)


def inside_bar(data):
    """Son mum, bir öncekinin içinde mi? (tek kontrol)"""
    if len(data) < 2:
        return False
    last = data.iloc[-1]
    prev = data.iloc[-2]
    return (last["high"] <= prev["high"]) and (last["low"] >= prev["low"])


def inside_chain_breakout(df, lookback=20, buffer_pips=5, vol_confirm=True):
    """
    Son X bar içinde oluşan inside-bar zincirinin mother bar sınırının kırılımını test eder.
    Dönüş: (bull_break, bear_break, meta)
    """
    if len(df) < 3:
        return False, False, {}

    d = df.iloc[-lookback:].copy()
    # zinciri en sondan geri sar: mother'ı bul
    i = len(d) - 1
    inside_cnt = 0
    while i >= 1:
        cur, prev = d.iloc[i], d.iloc[i - 1]
        if (cur["high"] <= prev["high"]) and (cur["low"] >= prev["low"]):
            inside_cnt += 1
            i -= 1
        else:
            # prev mother bar
            mother = prev
            break
    else:
        # hepsi iç içeyse ilk barı mother al
        mother = d.iloc[0]

    upper = float(mother["high"])
    lower = float(mother["low"])
    close = float(d.iloc[-1]["close"])

    # küçük pip tamponu
    buffer = buffer_pips * PIP_VALUE
    bull = close > upper + buffer
    bear = close < lower - buffer

    # hacim teyidi (opsiyonel)
    if vol_confirm and "tick_volume" in d.columns and len(d) >= 20:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    meta = {"mother_high": upper, "mother_low": lower, "inside_count": inside_cnt}
    return bool(bull), bool(bear), meta


def is_outside_bar(data):
    """Son mum, bir öncekinin hem yüksek hem düşük değerlerini AŞIYOR mu?"""
    if len(data) < 2:
        return False
    last = data.iloc[-1]
    prev = data.iloc[-2]
    return (last["high"] >= prev["high"]) and (last["low"] <= prev["low"])


def outside_breakout(df, buffer_pips=5, vol_confirm=False):
    """
    Outside bar sonrasında kırılım sinyali üretir.
    Dönüş: (bull_break, bear_break, meta)
    - bull_break: close > mother_high + buffer
    - bear_break: close < mother_low - buffer
    """
    if len(df) < 2:
        return False, False, {}

    prev = df.iloc[-2]
    last = df.iloc[-1]
    mother_high = float(prev["high"])
    mother_low = float(prev["low"])
    close = float(last["close"])

    # önce gerçekten outside mı?
    outside = (last["high"] >= mother_high) and (last["low"] <= mother_low)
    if not outside:
        return False, False, {"outside": False}

    buffer = buffer_pips * PIP_VALUE
    bull = close > mother_high + buffer
    bear = close < mother_low - buffer

    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        vol_ok = (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return (
        bool(bull),
        bool(bear),
        {"outside": True, "mother_high": mother_high, "mother_low": mother_low},
    )


def horseshoe_concept_bull(
    df, base_bars=2, body_small=0.4, body_big=1.2, buffer_pips=10
):
    """
    Bullish horseshoe concept:
    - Son N (base_bars) mum küçük gövdeli (range'e göre)
    - Son mum güçlü yeşil ve önceki N mumun en yüksek + buffer üzerinde kapanır
    """
    if len(df) < base_bars + 1:
        return False
    d = df.iloc[-(base_bars + 1) :].copy()
    rng = (d["high"] - d["low"]).replace(0, 1e-9)
    body = (d["close"] - d["open"]).abs()

    small_ok = (body.iloc[:-1] <= body_small * rng.iloc[:-1]).all()  # küçük gövdeler
    last_green = d["close"].iloc[-1] > d["open"].iloc[-1]  # yeşil kapanış
    big_ok = body.iloc[-1] >= body_big * rng.iloc[-1]  # görece büyük gövde

    prev_high = float(d["high"].iloc[:-1].max())
    break_ok = float(d["close"].iloc[-1]) > prev_high + buffer_pips * PIP_VALUE

    return bool(small_ok and last_green and big_ok and break_ok)


def horseshoe_concept_bear(
    df, base_bars=2, body_small=0.4, body_big=1.2, buffer_pips=10
):
    """
    Bearish horseshoe concept:
    - Son N mum küçük gövdeli
    - Son mum güçlü kırmızı ve önceki N mumun en düşük - buffer altında kapanır
    """
    if len(df) < base_bars + 1:
        return False
    d = df.iloc[-(base_bars + 1) :].copy()
    rng = (d["high"] - d["low"]).replace(0, 1e-9)
    body = (d["close"] - d["open"]).abs()

    small_ok = (body.iloc[:-1] <= body_small * rng.iloc[:-1]).all()
    last_red = d["close"].iloc[-1] < d["open"].iloc[-1]
    big_ok = body.iloc[-1] >= body_big * rng.iloc[-1]

    prev_low = float(d["low"].iloc[:-1].min())
    break_ok = float(d["close"].iloc[-1]) < prev_low - buffer_pips * PIP_VALUE

    return bool(small_ok and last_red and big_ok and break_ok)


def is_hammer(
    df, ratio=2.5, body_frac=0.35, close_pos_frac=0.6, top_wick_max_frac=0.25
):
    if len(df) < 1:
        return False
    last = df.iloc[-1]
    o, h, l, c = (
        float(last["open"]),
        float(last["high"]),
        float(last["low"]),
        float(last["close"]),
    )
    rng = max(h - l, 1e-9)
    body = abs(c - o)
    upper_wick = h - max(o, c)
    lower_wick = min(o, c) - l

    cond_long_wick = lower_wick >= ratio * body
    cond_small_body = body <= rng * body_frac
    cond_close_high = (
        c - min(o, c)
    ) >= body * close_pos_frac  # kapanış gövdenin üst tarafında
    cond_short_upper = upper_wick <= rng * top_wick_max_frac

    return cond_long_wick and cond_small_body and cond_close_high and cond_short_upper


def is_inverted_hammer(
    df, ratio=2.5, body_frac=0.35, close_pos_frac=0.6, bot_wick_max_frac=0.25
):
    if len(df) < 1:
        return False
    last = df.iloc[-1]
    o, h, l, c = (
        float(last["open"]),
        float(last["high"]),
        float(last["low"]),
        float(last["close"]),
    )
    rng = max(h - l, 1e-9)
    body = abs(c - o)
    upper_wick = h - max(o, c)
    lower_wick = min(o, c) - l

    cond_long_wick = upper_wick >= ratio * body
    cond_small_body = body <= rng * body_frac
    cond_close_low = (
        max(o, c) - c
    ) >= body * close_pos_frac  # kapanış gövdenin alt tarafında
    cond_short_lower = lower_wick <= rng * bot_wick_max_frac

    return cond_long_wick and cond_small_body and cond_close_low and cond_short_lower


def hammer_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 2:
        return False, False, {}
    prev = df.iloc[-2]  # hammer beklenen mum
    last = df.iloc[-1]  # teyit mumu

    is_ham = is_hammer(df.iloc[:-0]) or is_hammer(
        df.iloc[:-1]
    )  # son mum hammer olmayabilir; güvenli yol:
    # en doğru yaklaşım: prev’in hammer olup olmadığını kontrol etmek
    is_prev_hammer = is_hammer(df.iloc[:-1])

    if not is_prev_hammer:
        return False, False, {"hammer": False}

    mother_high = float(prev["high"])
    mother_low = float(prev["low"])
    close = float(last["close"])

    buf = buffer_pips * PIP_VALUE
    bull = close > mother_high + buf
    bear = False  # hammer’da esas kırılım yukarı

    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        vol_ok = (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok

    return bool(bull), bool(bear), {"hammer": True, "mother_high": mother_high}


def inverted_hammer_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 2:
        return False, False, {"inv_hammer": False}
    prev = df.iloc[-2]
    last = df.iloc[-1]

    is_prev_inv = is_inverted_hammer(df.iloc[:-1])
    if not is_prev_inv:
        return False, False, {"inv_hammer": False}

    mother_low = float(prev["low"])
    close = float(last["close"])

    buf = buffer_pips * PIP_VALUE
    bear = close < mother_low - buf
    bull = False

    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        vol_ok = (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and vol_ok

    return bool(bull), bool(bear), {"inv_hammer": True, "mother_low": mother_low}


def is_morning_star(df, body_frac=0.35, middle_close=True):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]
    # 1. mum ayı
    bear1 = a["close"] < a["open"]
    # 2. mum küçük gövde
    rng_b = max(b["high"] - b["low"], 1e-9)
    body_b = abs(b["close"] - b["open"]) <= rng_b * body_frac
    # 3. mum boğa
    bull3 = c["close"] > c["open"]
    # teyit: 3. mum 1. mum gövde ortasını geçsin
    mid_a = (a["open"] + a["close"]) / 2.0
    confirm = c["close"] > mid_a if middle_close else bull3
    return bool(bear1 and body_b and bull3 and confirm)


def morning_star_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 4:
        return False, False, {}
    a, b, c, d = df.iloc[-4], df.iloc[-3], df.iloc[-2], df.iloc[-1]
    if not is_morning_star(df.iloc[:-1]):  # son mum teyit mumu
        return False, False, {"ms": False}
    mid_a = (a["open"] + a["close"]) / 2.0
    buf = buffer_pips * PIP_VALUE
    bull = float(d["close"]) > (mid_a + buf)
    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        bull = bull and (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
    return bool(bull), False, {"ms": True}


def is_evening_star(df, body_frac=0.35, middle_close=True):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]
    # 1. mum boğa
    bull1 = a["close"] > a["open"]
    # 2. mum küçük gövde
    rng_b = max(b["high"] - b["low"], 1e-9)
    body_b = abs(b["close"] - b["open"]) <= rng_b * body_frac
    # 3. mum ayı
    bear3 = c["close"] < c["open"]
    # teyit: 3. mum 1. mum gövde ortasının altında kapatsın
    mid_a = (a["open"] + a["close"]) / 2.0
    confirm = c["close"] < mid_a if middle_close else bear3
    return bool(bull1 and body_b and bear3 and confirm)


def evening_star_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 4:
        return False, False, {}
    a, b, c, d = df.iloc[-4], df.iloc[-3], df.iloc[-2], df.iloc[-1]
    if not is_evening_star(df.iloc[:-1]):
        return False, False, {"es": False}
    mid_a = (a["open"] + a["close"]) / 2.0
    buf = buffer_pips * PIP_VALUE
    bear = float(d["close"]) < (mid_a - buf)
    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        bear = bear and (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
    return False, bool(bear), {"es": True}


def is_three_white_soldiers(
    df, min_body_frac=0.55, max_upper_wick_frac=0.35, require_higher_opens=True
):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]

    def ok_bull(x):
        return x["close"] > x["open"]

    def body(x):
        return abs(x["close"] - x["open"])

    def rng(x):
        return max(x["high"] - x["low"], 1e-9)

    def upper_wick(x):
        return x["high"] - max(x["open"], x["close"])

    cond_dir = ok_bull(a) and ok_bull(b) and ok_bull(c)
    cond_body = (
        body(a) >= rng(a) * min_body_frac
        and body(b) >= rng(b) * min_body_frac
        and body(c) >= rng(c) * min_body_frac
    )
    cond_wick = (
        upper_wick(a) <= rng(a) * max_upper_wick_frac
        and upper_wick(b) <= rng(b) * max_upper_wick_frac
        and upper_wick(c) <= rng(c) * max_upper_wick_frac
    )
    cond_progress = (b["close"] > a["close"]) and (c["close"] > b["close"])

    if require_higher_opens:
        # her bir sonraki açılış önceki gövdenin üst yarısında/üstünde
        mid_a = (a["open"] + a["close"]) / 2.0
        mid_b = (b["open"] + b["close"]) / 2.0
        cond_open = (b["open"] >= mid_a) and (c["open"] >= mid_b)
    else:
        cond_open = True

    return bool(cond_dir and cond_body and cond_wick and cond_progress and cond_open)


def three_white_soldiers_follow(df, buffer_pips=10):
    if len(df) < 4:
        return False
    if not is_three_white_soldiers(df.iloc[:-1]):  # son mum teyit olsun
        return False
    c = df.iloc[-2]  # üçüncü asker
    d = df.iloc[-1]  # teyit mumu
    buf = buffer_pips * PIP_VALUE
    return bool(d["close"] > (c["close"] + buf))


def is_three_black_crows(
    df, min_body_frac=0.55, max_lower_wick_frac=0.35, require_lower_opens=True
):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]

    def ok_bear(x):
        return x["close"] < x["open"]

    def body(x):
        return abs(x["close"] - x["open"])

    def rng(x):
        return max(x["high"] - x["low"], 1e-9)

    def lower_wick(x):
        return min(x["open"], x["close"]) - x["low"]

    cond_dir = ok_bear(a) and ok_bear(b) and ok_bear(c)
    cond_body = (
        body(a) >= rng(a) * min_body_frac
        and body(b) >= rng(b) * min_body_frac
        and body(c) >= rng(c) * min_body_frac
    )
    cond_wick = (
        lower_wick(a) <= rng(a) * max_lower_wick_frac
        and lower_wick(b) <= rng(b) * max_lower_wick_frac
        and lower_wick(c) <= rng(c) * max_lower_wick_frac
    )
    cond_progress = (b["close"] < a["close"]) and (c["close"] < b["close"])

    if require_lower_opens:
        mid_a = (a["open"] + a["close"]) / 2.0
        mid_b = (b["open"] + b["close"]) / 2.0
        cond_open = (b["open"] <= mid_a) and (c["open"] <= mid_b)
    else:
        cond_open = True
    return bool(cond_dir and cond_body and cond_wick and cond_progress and cond_open)


def three_black_crows_follow(df, buffer_pips=10):
    if len(df) < 4:
        return False
    if not is_three_black_crows(df.iloc[:-1]):
        return False
    c = df.iloc[-2]  # üçüncü karga
    d = df.iloc[-1]  # teyit mumu
    buf = buffer_pips * PIP_VALUE
    return bool(d["close"] < (c["close"] - buf))


def double_bottom_breakout(
    df, lookback=120, tol=0.005, min_gap=5, buffer_pips=10, vol_confirm=True
):
    """
    İkili dip (W) – boyun çizgisi üstü kapanışta bullish kırılım verir.
    tol: diplerin eşitliği için oransal tolerans (0.5%)
    min_gap: iki dip arasında en az bar
    """
    d = df.iloc[-lookback:].copy()
    lows = d["low"].astype(float)
    highs = d["high"].astype(float)
    close = d["close"].astype(float)

    if len(d) < 30:
        return False, False, {}

    # yerel min/max (basit pivot)
    pl = (lows.shift(1) > lows) & (lows.shift(-1) > lows)
    ph = (highs.shift(1) < highs) & (highs.shift(-1) < highs)
    li = list(lows[pl].index)

    if len(li) < 2:
        return False, False, {}

    # son iki dip ve aralarındaki tepe
    d2 = li[-1]
    d1 = None
    # d1'i, d2'den önceki pivotlardan al ve arada min_gap bırak
    for idx in reversed(li[:-1]):
        if (d2 - idx).days is not None:
            # index datetime ise .days çalışır; değilse bar sayısı için:
            pass
        if d.index.get_loc(d2) - d.index.get_loc(idx) >= min_gap:
            d1 = idx
            break
    if d1 is None:
        return False, False, {}

    # aradaki tepe (neckline)
    mid_high = highs.loc[d1:d2]
    ph_mid = mid_high[(mid_high.shift(1) < mid_high) & (mid_high.shift(-1) < mid_high)]
    if ph_mid.empty:
        neckline = float(mid_high.max())
    else:
        neckline = float(ph_mid.iloc[-1])

    # diplerin eşitliği
    L1, L2 = float(lows.loc[d1]), float(lows.loc[d2])
    base = max(1e-9, (L1 + L2) / 2.0)
    if abs(L1 - L2) / base > tol:
        return False, False, {}

    # kırılım (neckline üstünde kapanış)
    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bull = float(close.iloc[-1]) > neckline + buffer

    # hacim teyidi opsiyonel
    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and bool(vol_ok)

    meta = {
        "neckline": float(neckline),
        "low1": float(L1),
        "low2": float(L2),
        "close": float(close.iloc[-1]),
    }
    return bool(bull), False, meta


def double_top_breakout(
    df, lookback=120, tol=0.005, min_gap=5, buffer_pips=10, vol_confirm=True
):
    """
    İkili tepe (M) – boyun çizgisi altı kapanışta bearish kırılım verir.
    """
    d = df.iloc[-lookback:].copy()
    lows = d["low"].astype(float)
    highs = d["high"].astype(float)
    close = d["close"].astype(float)

    if len(d) < 30:
        return False, False, {}

    # yerel min/max (basit pivot)
    ph = (highs.shift(1) < highs) & (highs.shift(-1) < highs)
    pl = (lows.shift(1) > lows) & (lows.shift(-1) > lows)
    hi = list(highs[ph].index)

    if len(hi) < 2:
        return False, False, {}

    t2 = hi[-1]
    t1 = None
    for idx in reversed(hi[:-1]):
        if d.index.get_loc(t2) - d.index.get_loc(idx) >= min_gap:
            t1 = idx
            break
    if t1 is None:
        return False, False, {}

    # aradaki dip (neckline)
    mid_low = lows.loc[t1:t2]
    pl_mid = mid_low[(mid_low.shift(1) > mid_low) & (mid_low.shift(-1) > mid_low)]
    if pl_mid.empty:
        neckline = float(mid_low.min())
    else:
        neckline = float(pl_mid.iloc[-1])

    # tepelerin eşitliği
    H1, H2 = float(highs.loc[t1]), float(highs.loc[t2])
    base = max(1e-9, (H1 + H2) / 2.0)
    if abs(H1 - H2) / base > tol:
        return False, False, {}

    # kırılım (neckline altında kapanış)
    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bear = float(close.iloc[-1]) < neckline - buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and bool(vol_ok)

    meta = {
        "neckline": float(neckline),
        "high1": float(H1),
        "high2": float(H2),
        "close": float(close.iloc[-1]),
    }
    return False, bool(bear), meta


def head_shoulders_breakout(df, lookback=80, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    h, l = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # --- pivot tepeler/dipler
    s = h.values
    ph = np.r_[False, (s[1:-1] > s[:-2]) & (s[1:-1] > s[2:]), False]
    s = l.values
    pl = np.r_[False, (s[1:-1] < s[:-2]) & (s[1:-1] < s[2:]), False]
    ph_idx = d.index[ph]
    pl_idx = d.index[pl]
    if len(ph_idx) < 3 or len(pl_idx) < 2:
        return False, False  # bull, bear

    # son bölümdeki en yüksek tepe = head
    ph_idx = sorted(ph_idx)[-5:]
    head_i = max(ph_idx, key=lambda i: h.loc[i])
    left = [i for i in ph_idx if i < head_i]
    right = [i for i in ph_idx if i > head_i]
    if not left or not right:
        return False, False
    ls_i = max(left)  # sol omuz tepesi
    rs_i = min(right)  # sağ omuz tepesi
    ls, hd, rs = float(h.loc[ls_i]), float(h.loc[head_i]), float(h.loc[rs_i])

    # omuz benzerliği ve başın daha yüksek olması
    if not (hd > ls and hd > rs and abs(ls - rs) <= 0.015 * hd):
        return False, False

    # omuzlar arası iki dipten boyun çizgisi (lineer fit)
    dips_between = [i for i in pl_idx if ls_i < i < rs_i]
    if len(dips_between) < 2:
        return False, False
    idx = np.array([d.index.get_loc(i) for i in dips_between[:2]], dtype=float)
    y = np.array([float(l.loc[i]) for i in dips_between[:2]], dtype=float)
    a, b = np.polyfit(idx, y, 1)
    x_last = float(d.index.size - 1)
    neckline_last = a * x_last + b

    buf = buffer_pips * PIP_VALUE
    # normal (beklenen) = aşağı; ters = yukarı
    bear_break = close < (neckline_last - buf)
    bull_break = close > (neckline_last + buf)

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear_break = bear_break and bool(vol_ok)
        bull_break = bull_break and bool(vol_ok)

    return bool(bull_break), bool(bear_break)


def inverse_head_shoulders_breakout(df, lookback=80, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    h, l = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    s = h.values
    ph = np.r_[False, (s[1:-1] > s[:-2]) & (s[1:-1] > s[2:]), False]
    s = l.values
    pl = np.r_[False, (s[1:-1] < s[:-2]) & (s[1:-1] < s[2:]), False]
    ph_idx = d.index[ph]
    pl_idx = d.index[pl]
    if len(pl_idx) < 3 or len(ph_idx) < 2:
        return False, False

    head_i = min(pl_idx, key=lambda i: l.loc[i])  # en derin dip = head
    left = [i for i in pl_idx if i < head_i]
    right = [i for i in pl_idx if i > head_i]
    if not left or not right:
        return False, False
    ls_i = max(left)  # sol omuz dibi
    rs_i = min(right)  # sağ omuz dibi
    ls, hd, rs = float(l.loc[ls_i]), float(l.loc[head_i]), float(l.loc[rs_i])

    if not (hd < ls and hd < rs and abs(ls - rs) <= 0.015 * max(ls, rs)):
        return False, False

    tops_between = [i for i in ph_idx if ls_i < i < rs_i]
    if len(tops_between) < 2:
        return False, False
    idx = np.array([d.index.get_loc(i) for i in tops_between[:2]], dtype=float)
    y = np.array([float(h.loc[i]) for i in tops_between[:2]], dtype=float)
    a, b = np.polyfit(idx, y, 1)
    x_last = float(d.index.size - 1)
    neckline_last = a * x_last + b

    buf = buffer_pips * PIP_VALUE
    # normal (beklenen) = yukarı; ters = aşağı
    bull_break = close > (neckline_last + buf)
    bear_break = close < (neckline_last - buf)

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull_break = bull_break and bool(vol_ok)
        bear_break = bear_break and bool(vol_ok)

    return bool(bull_break), bool(bear_break)


# Daralan hayali üçgende kırılım noktasını belirleyip sinyal verir
def triangle_symmetric_breakout(df, lookback=60, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    highs, lows = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # basit pivotlar
    ph = highs[(highs.shift(1) < highs) & (highs.shift(-1) < highs)]
    pl = lows[(lows.shift(1) > lows) & (lows.shift(-1) > lows)]
    if len(ph) < 2 or len(pl) < 2:
        return False, False, {}

    # üst/alt çizgi için lineer fit
    xh = np.arange(len(ph), dtype=float)
    xl = np.arange(len(pl), dtype=float)
    m_up, b_up = np.polyfit(
        (xh - xh.mean()) / (xh.std() + 1e-9), ph.values.astype(float), 1
    )
    m_dn, b_dn = np.polyfit(
        (xl - xl.mean()) / (xl.std() + 1e-9), pl.values.astype(float), 1
    )

    # simetrik üçgen şartı (üst eğim negatif, alt eğim pozitif)
    if not (m_up < 0 and m_dn > 0):
        return False, False, {}

    # son bar için çizgi seviyeleri (normalize edilmiş x≈0 kabul)
    upper_last = b_up
    lower_last = b_dn

    buffer = buffer_pips * PIP_VALUE
    bull = close > upper_last + buffer
    bear = close < lower_last - buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull, bear = bull and vol_ok, bear and vol_ok

    return (
        bool(bull),
        bool(bear),
        {"upper": float(upper_last), "lower": float(lower_last), "close": close},
    )


def triangle_ascending_breakout(
    df, lookback=60, flat_tol=0.002, buffer_pips=10, vol_confirm=True
):
    d = df.iloc[-lookback:].copy()
    highs, lows = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # yatay tepe (flat top) ve yükselen dipler arıyoruz
    top_spread = (highs.max() - highs.min()) / (highs.max() + 1e-9)
    rising_lows = lows.is_monotonic_increasing
    if not (top_spread < flat_tol and rising_lows):
        return False, False, {}

    flat_top = float(highs.max())
    buffer = buffer_pips * PIP_VALUE
    bull = close > flat_top + buffer
    # aşağı kırılım garanti değil ama istersek:
    bear = False

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok

    return bool(bull), bool(bear), {"flat_top": flat_top, "close": close}


def triangle_descending_breakout(
    df, lookback=60, flat_tol=0.002, buffer_pips=10, vol_confirm=True
):
    d = df.iloc[-lookback:].copy()
    highs, lows = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # yatay taban (flat bottom) ve alçalan tepeler
    bottom_spread = (lows.max() - lows.min()) / (lows.min() + 1e-9)
    falling_highs = highs.is_monotonic_decreasing
    if not (bottom_spread < flat_tol and falling_highs):
        return False, False, {}

    flat_bottom = float(lows.min())
    buffer = buffer_pips * PIP_VALUE
    bear = close < flat_bottom - buffer
    bull = False

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and vol_ok

    return bool(bull), bool(bear), {"flat_bottom": flat_bottom, "close": close}


def wedge_breakout(
    df,
    lookback=None,
    pivot_lb=None,
    min_touches=None,
    converge_tol=None,
    pretrend_lb=None,
    allow_counter=None,
):
    """
    Gerçek wedge (rising/falling) + kırılım tespiti.
    Dönüş: (bull_break, bear_break, meta)
    meta: {"kind": "rising"|"falling"|"none", "expected": "UP"|"DOWN"|None, "counter": bool}
    """
    if lookback is None:
        lookback = CONFIG["wedge_lookback"]
    if pivot_lb is None:
        pivot_lb = CONFIG["wedge_pivot_lb"]
    if min_touches is None:
        min_touches = CONFIG["wedge_min_touchers"]
    if converge_tol is None:
        converge_tol = CONFIG["wedge_converge_tol"]
    if pretrend_lb is None:
        pretrend_lb = CONFIG["wedge_pretrend_lb"]
    if allow_counter is None:
        allow_counter = CONFIG["wedge_allow_counter"]

    if len(df) < max(lookback, pretrend_lb) + 5:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    window = df.iloc[-lookback:].copy()
    closes = df["close"]

    # 1) Pivotlar
    highs = window["high"]
    lows = window["low"]
    ph = _pivot_highs(highs, pivot_lb)
    pl = _pivot_lows(lows, pivot_lb)
    hi_pts = highs[ph].dropna()
    lo_pts = lows[pl].dropna()
    if len(hi_pts) < min_touches or len(lo_pts) < min_touches:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    # 2) Üst/Alt çizgi regresyonu
    # x ekseni: 0..n-1 (pencere göre relatif)
    x_hi = (hi_pts.index - window.index[0]).total_seconds()
    x_hi = (x_hi / max(x_hi.max(), 1)).values  # normalize
    y_hi = hi_pts.values
    a_hi, b_hi = np.polyfit(x_hi, y_hi, 1)  # üst çizgi eğim

    x_lo = (lo_pts.index - window.index[0]).total_seconds()
    x_lo = (x_lo / max(x_lo.max(), 1)).values
    y_lo = lo_pts.values
    a_lo, b_lo = np.polyfit(x_lo, y_lo, 1)  # alt çizgi eğim

    # 3) Takoz tipi
    kind = "none"
    if a_hi > 0 and a_lo > 0:
        kind = "rising"
    elif a_hi < 0 and a_lo < 0:
        kind = "falling"
    else:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    # 4) Daralma (band genişliği azalıyor mu?)
    # başlangıç-x=0, bitiş-x=1 varsayımıyla band genişliği
    band_start = (a_hi * 0 + b_hi) - (a_lo * 0 + b_lo)
    band_end = (a_hi * 1 + b_hi) - (a_lo * 1 + b_lo)
    if band_start <= 0:  # güvenlik
        return False, False, {"kind": "none", "expected": None, "counter": False}
    narrowing = (band_start - band_end) / band_start  # % azalma
    if narrowing < converge_tol:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    # 5) Pre-trend (pencere öncesi)
    pre = df.iloc[-(lookback + pretrend_lb) : -lookback]["close"]
    if len(pre) < 2:
        pretrend = 0.0
    else:
        pretrend = _lin_slope(pre)

    # Beklenen kırılım yönü (klasik)
    expected = "DOWN" if kind == "rising" else "UP"

    # 6) Kırılım kontrolü (son kapanış)
    last_close = window["close"].iloc[-1]
    # üst/alt çizgi son x=1 değeri:
    upper_end = a_hi * 1 + b_hi
    lower_end = a_lo * 1 + b_lo
    bull_break = last_close > upper_end
    bear_break = last_close < lower_end

    # 7) Beklenen vs Kontra etiketi
    counter = False
    if bull_break and expected == "DOWN":
        counter = True
        if not allow_counter:
            bull_break = False
    if bear_break and expected == "UP":
        counter = True
        if not allow_counter:
            bear_break = False

    return (
        bool(bull_break),
        bool(bear_break),
        {"kind": kind, "expected": expected, "counter": counter},
    )


def channel_breakout(
    df, lookback=60, buffer_pips=10, parallel_tol=0.15, slope_eps=1e-9, vol_confirm=True
):
    """
    Paralel kanal (ascending/descending/horizontal) kırılım tespiti.
    close > üst çizgi + buffer → bull, close < alt çizgi - buffer → bear
    parallel_tol: üst-alt eğim farkı için bağıl tolerans (≈%15)
    """

    d = df.iloc[-lookback:].copy()
    if len(d) < lookback:
        return False, False, {"kind": "none"}

    highs = d["high"]
    lows = d["low"]
    close = float(d["close"].iloc[-1])

    # --- basit pivotlar (yerel tepe/dip)
    ph = highs[(highs.shift(1) < highs) & (highs.shift(-1) < highs)]
    pl = lows[(lows.shift(1) > lows) & (lows.shift(-1) > lows)]
    if len(ph) < 2 or len(pl) < 2:
        return False, False, {"kind": "none"}

    # --- üst/alt çizgiler için lineer fit
    xh = (
        (ph.index - ph.index[0]).total_seconds()
        if hasattr(ph.index, "tz") or hasattr(ph.index, "tzinfo")
        else np.arange(len(ph))
    )
    xl = (
        (pl.index - pl.index[0]).total_seconds()
        if hasattr(pl.index, "tz") or hasattr(pl.index, "tzinfo")
        else np.arange(len(pl))
    )
    xh = np.asarray(xh, dtype=float)
    xl = np.asarray(xl, dtype=float)

    a_up, b_up = np.polyfit(xh, ph.values.astype(float), 1)  # üst çizgi eğimi
    a_dn, b_dn = np.polyfit(xl, pl.values.astype(float), 1)  # alt çizgi eğimi

    # paralellik testi (bağıl fark)
    denom = max(abs(a_up), abs(a_dn), slope_eps)
    if abs(a_up - a_dn) / denom > parallel_tol:
        return False, False, {"kind": "not_parallel"}

    # kanal tipi
    if a_up > 0 and a_dn > 0:
        kind = "ascending"
    elif a_up < 0 and a_dn < 0:
        kind = "descending"
    else:
        kind = "horizontal"

    # son bar için çizgi seviyeleri
    # zaman eksenini son bar’a normalize edelim
    last_x = max(xh[-1], xl[-1])  # yakınsama için kabaca
    upper_last = a_up * last_x + b_up
    lower_last = a_dn * last_x + b_dn

    # tamponu fiyata çevir (pip)
    buffer = buffer_pips * PIP_VALUE

    bull = close > upper_last + buffer
    bear = close < lower_last - buffer

    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return (
        bool(bull),
        bool(bear),
        {
            "kind": kind,
            "upper": float(upper_last),
            "lower": float(lower_last),
            "close": float(close),
            "slope_up": float(a_up),
            "slope_dn": float(a_dn),
        },
    )


def cup_breakout(df, lookback=120, rim_tol=0.01, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    close = d["close"].astype(float).values
    if len(close) < 30:
        return False, False, {}

    L = len(close)
    third = max(10, L // 3)
    left_rim = close[:third].max()
    right_rim = close[-third:].max()
    rim = max(left_rim, right_rim)
    trough = float(close.argmin())
    trough = float(close[int(trough)])

    if rim <= trough:
        return False, False, {}
    if abs(left_rim - right_rim) / rim > rim_tol:
        return False, False, {}

    x = np.arange(L, dtype=float)
    a1 = np.polyfit(x[:third], close[:third], 1)[0]  # sol taraf düşüş
    a2 = np.polyfit(x[-third:], close[-third:], 1)[0]  # sağ taraf yükseliş
    if not (a1 < 0 and a2 > 0):
        return False, False, {}

    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bull = float(close[-1]) > rim + buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and bool(vol_ok)

    return (
        bool(bull),
        False,
        {"rim": float(rim), "trough": float(trough), "close": float(close[-1])},
    )


def dome_breakout(df, lookback=120, rim_tol=0.01, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    close = d["close"].astype(float).values
    if len(close) < 30:
        return False, False, {}

    L = len(close)
    third = max(10, L // 3)
    left_rim = close[:third].min()
    right_rim = close[-third:].min()
    rim = min(left_rim, right_rim)
    peak = float(close.max())

    if peak <= rim:
        return False, False, {}
    if abs(left_rim - right_rim) / max(1e-9, abs(rim)) > rim_tol:
        return False, False, {}

    x = np.arange(L, dtype=float)
    a1 = np.polyfit(x[:third], close[:third], 1)[0]  # sol taraf yükseliş
    a2 = np.polyfit(x[-third:], close[-third:], 1)[0]  # sağ taraf düşüş
    if not (a1 > 0 and a2 < 0):
        return False, False, {}

    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bear = float(close[-1]) < rim - buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and bool(vol_ok)

    return (
        False,
        bool(bear),
        {"rim": float(rim), "peak": float(peak), "close": float(close[-1])},
    )


def cup_handle_breakout(
    df,
    lookback=160,
    rim_tol=0.01,
    handle_min=5,
    handle_max=25,
    handle_ret_min=0.2,
    handle_ret_max=0.5,
    buffer_pips=10,
    vol_confirm=True,
):
    bull_cup, _, meta = cup_breakout(
        df, lookback=lookback, rim_tol=rim_tol, buffer_pips=0, vol_confirm=False
    )
    if not bull_cup:
        return False, False, {}

    d = df.iloc[-lookback:].copy()
    close = d["close"].astype(float).values
    rim = meta["rim"]
    trough = meta["trough"]

    L = len(close)
    third = max(10, L // 3)
    recent_peak_idx = np.argmax(close[-(third * 2) :]) + (L - third * 2)
    recent_peak = close[recent_peak_idx]
    if abs(recent_peak - rim) / rim > rim_tol:
        return False, False, {}

    handle = close[recent_peak_idx + 1 :]
    if len(handle) < handle_min or len(handle) > handle_max:
        return False, False, {}

    cup_h = rim - trough
    if cup_h <= 0:
        return False, False, {}

    pullback = recent_peak - handle.min()
    ret = pullback / cup_h
    if not (handle_ret_min <= ret <= handle_ret_max):
        return False, False, {}

    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bull = float(close[-1]) > rim + buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and bool(vol_ok)

    return (
        bool(bull),
        False,
        {"rim": float(rim), "trough": float(trough), "close": float(close[-1])},
    )


def abcd_strict(
    df,
    lookback=120,
    retrace=0.618,
    ext=1.272,
    tol=0.03,
    confirm_break=False,
    buffer_pips=10,
):
    """
    AB=CD (harmonik) – BC ~ 0.618*AB, CD ~ 1.272*BC.
    D noktası tamamlandığında sinyal verir. İsteğe bağlı olarak D sonrası
    ters yönde küçük bir kırılım (reversal) teyidi aranabilir.
    Döndürür: (bull, bear)
    """
    d = df.iloc[-lookback:].copy()
    h, l = d["high"], d["low"]
    c = float(d["close"].iloc[-1])

    # --- basit pivotlar (tepe/dip)
    s = h.values
    ph = np.r_[False, (s[1:-1] > s[:-2]) & (s[1:-1] > s[2:]), False]
    s = l.values
    pl = np.r_[False, (s[1:-1] < s[:-2]) & (s[1:-1] < s[2:]), False]
    piv_hi = d.index[ph]
    piv_lo = d.index[pl]
    if len(piv_hi) < 2 or len(piv_lo) < 2:
        return False, False

    # --- son 6–8 pivottan AB=CD dizilimi ara (…A-B-C-D)
    piv = sorted(list({*piv_hi, *piv_lo}), key=lambda i: d.index.get_loc(i))[-8:]

    bull = bear = False
    buf = buffer_pips * PIP_VALUE

    def near(x, y, rel=tol):
        return abs(x - y) <= rel * max(abs(y), 1e-9)

    # her 4’lü ardışık pivotu dene
    for i in range(len(piv) - 3):
        A, B, C, D = piv[i : i + 4]
        PA, PB, PC, PD = (
            float(d.loc[A, "close"]),
            float(d.loc[B, "close"]),
            float(d.loc[C, "close"]),
            float(d.loc[D, "close"]),
        )

        AB = PB - PA
        BC = PC - PB
        CD = PD - PC

        # YUKARI trendli varyant (AB>0, BC<0, CD>0) → bitişte düşüş beklenen AB=CD (bearish)
        if AB > 0 and BC < 0 and CD > 0:
            bc_ok = near(abs(BC), retrace * abs(AB))
            cd_ok = near(abs(CD), ext * abs(BC))
            if bc_ok and cd_ok:
                if not confirm_break:
                    bear = True
                else:
                    # D sonrası küçük bir aşağı kırılım teyidi
                    bear = c < (PD - buf)
                # devam etmeden önce daha güncel bir eşleşme var mı diye aramaya devam edebiliriz
        # AŞAĞI trendli varyant (AB<0, BC>0, CD<0) → bitişte yükseliş beklenen AB=CD (bullish)
        if AB < 0 and BC > 0 and CD < 0:
            bc_ok = near(abs(BC), retrace * abs(AB))
            cd_ok = near(abs(CD), ext * abs(BC))
            if bc_ok and cd_ok:
                if not confirm_break:
                    bull = True
                else:
                    bull = c > (PD + buf)

    return bool(bull), bool(bear)


def wolfe_breakout(df, lookback=120, buffer_pips=10, tol=None, vol_confirm=True):
    """
    Wolfe Wave breakout:
      - Bullish: falling channel tipi dalga, 5 oluştuktan sonra close > line(1-4)+buffer
      - Bearish: rising channel tipi dalga, 5 sonrası close < line(1-4)-buffer
    return: (bull, bear, meta)
    """
    d = df.iloc[-lookback:].copy()
    if tol is None:
        tol = CONFIG.get("wolfe_tol", 0.02)

    h, l = d["high"].values, d["low"].values
    c = float(d["close"].iloc[-1])
    idx = d.index

    # --- kaba pivotlar (yerel tepe/dip)
    ph = np.r_[False, (h[1:-1] > h[:-2]) & (h[1:-1] > h[2:]), False]
    pl = np.r_[False, (l[1:-1] < l[:-2]) & (l[1:-1] < l[2:]), False]
    piv_hi = np.where(ph)[0]
    piv_lo = np.where(pl)[0]
    if len(piv_hi) + len(piv_lo) < 5:
        return False, False, {"kind": "none"}

    # pivotları zaman sırasına göre topla (son 10–12 taneden ara)
    piv = sorted(list(set(piv_hi.tolist() + piv_lo.tolist())))[-12:]
    if len(piv) < 5:
        return False, False, {"kind": "none"}

    bull = bear = False
    meta = {"kind": "none"}
    buf = buffer_pips * PIP_VALUE

    def line_y(x0, y0, x1, y1, xq):
        # x: bar index (0..n-1)
        if x1 == x0:
            return y0
        m = (y1 - y0) / (x1 - x0)
        return y0 + m * (xq - x0)

    # Wolfe şablonu arayışı:
    # Bullish: 1 (tepe) – 2 (dip) – 3 (tepe) – 4 (dip) – 5 (alt sarkma) ~ düşen kanal
    # Bearish: 1 (dip) – 2 (tepe) – 3 (dip) – 4 (tepe) – 5 (üst sarkma) ~ yükselen kanal
    # Son noktadan (5) sonra 1–4 hattının kırılması sinyal.

    # son 8 ardışık pivot dizilerinden dene
    for i in range(len(piv) - 4):
        p1, p2, p3, p4, p5 = piv[i : i + 5]
        # sıra korunmalı
        if not (p1 < p2 < p3 < p4 < p5):
            continue

        P1c, P2c, P3c, P4c, P5c = d["close"].iloc[[p1, p2, p3, p4, p5]].astype(float)

        # Bullish aday (düşen yapı: P1>P3>P5 ve P2>P4)
        bull_shape = (P1c > P3c > P5c) and (P2c > P4c)
        # Bearish aday (yükselen yapı: P1<P3<P5 ve P2<P4)
        bear_shape = (P1c < P3c < P5c) and (P2c < P4c)

        # Kanal eğimlerinin yakınlığı (1–3–5 ile 2–4 arasında eğim farkı küçük)
        x = np.array([p1, p3, p5], dtype=float)
        y_top = np.array([P1c, P3c, P5c], dtype=float)
        mt = np.polyfit(x, y_top, 1)[0]
        x2 = np.array([p2, p4], dtype=float)
        y_bot = np.array([P2c, P4c], dtype=float)
        mb = np.polyfit(x2, y_bot, 1)[0] if len(x2) == 2 else mt
        parallel_ok = abs(abs(mt) - abs(mb)) <= tol * max(1e-6, abs(mt) + abs(mb))

        if not parallel_ok:
            continue

        # 1–4 hattı
        x14_0, x14_1 = float(p1), float(p4)
        y14_0, y14_1 = P1c, P4c
        last_x = float(len(d) - 1)
        line14_now = line_y(x14_0, y14_0, x14_1, y14_1, last_x)

        if bull_shape:
            # 5’ten sonra yukarı kırılım
            bull_break = c > (line14_now + buf)
            if bull_break:
                bull = True
                meta = {
                    "kind": "bullish",
                    "p": [int(p1), int(p2), int(p3), int(p4), int(p5)],
                    "line14": float(line14_now),
                }
        if bear_shape:
            # 5’ten sonra aşağı kırılım
            bear_break = c < (line14_now - buf)
            if bear_break:
                bear = True
                meta = {
                    "kind": "bearish",
                    "p": [int(p1), int(p2), int(p3), int(p4), int(p5)],
                    "line14": float(line14_now),
                }

    # Hacim teyidi istenirse
    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return bool(bull), bool(bear), meta


def po3_signal(
    df,
    lookback=80,
    box_lb=20,
    box_tol=0.002,
    spike_pips=20,
    disp_atr=1.0,
    vol_confirm=True,
):
    """
    PO3 (Power of Three) tespiti:
      - bull: önce kutu, aşağı stop-hunt (spike), sonra yukarı güçlü close
      - bear: önce kutu, yukarı stop-hunt (spike), sonra aşağı güçlü close
    """

    d = df.iloc[-lookback:].copy()
    c = float(d["close"].iloc[-1])
    h = d["high"].values
    l = d["low"].values

    # --- 1) Kutu (dar aralık)
    box = d.iloc[-(box_lb + 5) : -5] if len(d) >= box_lb + 5 else d.iloc[:-5]
    if box.empty:
        return False, False, {"stage": "none"}
    box_hi = float(box["high"].max())
    box_lo = float(box["low"].min())
    box_mid = (box_hi + box_lo) / 2.0
    cond_box = (box_hi - box_lo) / max(1e-9, box_mid) <= box_tol

    if not cond_box:
        return False, False, {"stage": "no_box"}

    # --- 2) Manipülasyon (son 5 mumda kutu DIŞINA spike)
    last5 = d.iloc[-5:]
    buf = spike_pips * PIP_VALUE
    # bullish senaryo: kutu altı altına spike
    bull_spike = last5["low"].min() < box_lo - buf
    # bearish: kutu üstü üstüne spike
    bear_spike = last5["high"].max() > box_hi + buf

    # --- 3) Displacement kırılım (son mum)
    # ATR (varsa) ile gövde gücü
    if "atr" in d.columns:
        atr = float(d["atr"].iloc[-1])
    else:
        # hızlı ATR ~ True Range'in 14 ortalaması
        tr = np.maximum(h[1:], l[1:]) - np.minimum(h[1:], l[1:])
        atr = (
            float(np.mean(tr[-14:]))
            if len(tr) >= 14
            else float(np.mean(tr)) if len(tr) > 0 else 0.0
        )

    body = abs(float(d["close"].iloc[-1]) - float(d["open"].iloc[-1]))
    power_ok = body >= disp_atr * max(1e-9, atr)

    bull_break = bull_spike and (c > box_hi + buf) and power_ok
    bear_break = bear_spike and (c < box_lo - buf) and power_ok

    # Hacim teyidi (isteğe bağlı)
    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull_break = bull_break and vol_ok
        bear_break = bear_break and vol_ok

    meta = {
        "stage": "done" if (bull_break or bear_break) else "waiting",
        "box_hi": box_hi,
        "box_lo": box_lo,
        "spike_pips": spike_pips,
        "atr": atr,
    }
    return bool(bull_break), bool(bear_break), meta


def quasimodo_breakout(df, lookback=80, retouch_pips=12, vol_confirm=True):
    """
    QML (Quasimodo) kırılım/retouch tespiti.
    - Bearish: H1 -> H2 (HH) -> L2 (LL) yapısı ve close ≈ H1 (retouch) => bear=True
    - Bullish: L1 -> L2 (LL) -> H2 (HH) yapısı ve close ≈ L1 (retouch) => bull=True
    """
    d = df.iloc[-lookback:].copy()
    if len(d) < 10:
        return False, False, {}

    h, l, c = d["high"], d["low"], d["close"]

    # basit pivotlar
    ph = (h.shift(1) < h) & (h.shift(-1) < h)  # pivot high
    pl = (l.shift(1) > l) & (l.shift(-1) > l)  # pivot low
    H = h[ph]
    L = l[pl]
    if len(H) < 2 or len(L) < 2:
        return False, False, {}

    # --- Bearish QML: H1 < H2 (HH) ve H2'den sonra L2 < L1 (LL)
    bear = False
    qml_bear = None
    # son iki pivot high: H1, H2
    h2i = H.index[-1]
    h1i = H.index[-2]
    # H2 sonrası son pivot low: L2 ; H2 öncesi son pivot low: L1
    L_after = L[L.index > h2i]
    L_before = L[L.index < h2i]
    if len(L_after) >= 1 and len(L_before) >= 1:
        l2i = L_after.index[-1]
        l1i = L_before.index[-1]
        cond_struct_bear = (h.loc[h2i] > h.loc[h1i]) and (l.loc[l2i] < l.loc[l1i])
        qml_bear = float(h.loc[h1i])  # left-shoulder seviyesi
        # retouch yakınlığı (pip)
        tol = retouch_pips * PIP_VALUE
        retouch_bear = c.iloc[-1] <= qml_bear + tol and c.iloc[-1] >= qml_bear - 2 * tol
        bear = bool(cond_struct_bear and retouch_bear)

    # --- Bullish QML: L1 > L2 (LL) ve L2'den sonra H2 > H1 (HH)
    bull = False
    qml_bull = None
    l2i = L.index[-1]
    l1i = L.index[-2]
    H_after = H[H.index > l2i]
    H_before = H[H.index < l2i]
    if len(H_after) >= 1 and len(H_before) >= 1:
        h2i_b = H_after.index[-1]
        h1i_b = H_before.index[-1]
        cond_struct_bull = (l.loc[l2i] < l.loc[l1i]) and (h.loc[h2i_b] > h.loc[h1i_b])
        qml_bull = float(l.loc[l1i])  # left-shoulder low seviyesi
        tol = retouch_pips * PIP_VALUE
        retouch_bull = c.iloc[-1] >= qml_bull - tol and c.iloc[-1] <= qml_bull + 2 * tol
        bull = bool(cond_struct_bull and retouch_bull)

    # opsiyonel hacim teyidi
    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    meta = {
        "qml_bear_level": qml_bear,
        "qml_bull_level": qml_bull,
        "close": float(c.iloc[-1]),
    }
    return bull, bear, meta


# 21. Three Sweep Concept
def three_sweep(data):
    if len(data) < 6:
        return False, False
    highs = data["high"][-6:]
    lows = data["low"][-6:]
    bull = lows.iloc[-1] < lows.iloc[-2] < lows.iloc[-3]
    bear = highs.iloc[-1] > highs.iloc[-2] > highs.iloc[-3]
    return bull, bear


# ✅ ALIAS
def three_sweep_concept(data):
    return three_sweep(data)


# ========= Triangles/Wedges helpers are above =========


# ========= Aggregate =========
def generate_signals(df: pd.DataFrame) -> pd.DataFrame:
    d = _prep(df)
    last_index = d.index[-1]  # sadece son barı kullan

    # ⬇️ Time fix
    if not isinstance(last_index, pd.Timestamp):
        try:
            last_index = pd.to_datetime(last_index, errors="coerce")
        except Exception as e:
            # print("⚠️ DEBUG time conversion error:", e, last_index)
            return pd.DataFrame()

    # print("🔍 DEBUG last_index type:", type(last_index), last_index)
    parts = []

    # ========= Candle / Bar formations =========
    ema20 = d["close"].ewm(span=20, adjust=False).mean()
    bull, bear = engulfing_strong(d, ema=ema20, use_volume=True, strong=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "engulf_strong_bull": [bull],
                "engulf_strong_bear": [bear],
            }
        )
    )

    ema20 = d["close"].ewm(span=20, adjust=False).mean()
    bull, bear = pinbar_strict(d, ema=ema20, use_volume=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "pinbar_strict_bull": [bull],
                "pinbar_strict_bear": [bear],
            }
        )
    )

    bull, bear, meta_ib = inside_chain_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "inside_break_bull": [bull],
                "inside_break_bear": [bear],
                # istersen metayı da loglamak için:
                # "inside_count": [meta_ib["inside_count"]],
            }
        )
    )

    # Basit outside işareti
    parts.append(
        pd.DataFrame({"time": [last_index], "outside_bar": [is_outside_bar(d)]})
    )
    # Outside kırılım sinyali
    ob_bull, ob_bear, ob_meta = outside_breakout(d, buffer_pips=10, vol_confirm=True)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "outside_break_bull": [ob_bull],
                "outside_break_bear": [ob_bear],
            }
        )
    )

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "horseshoe_concept_bull": [horseshoe_concept_bull(d)],
                "horseshoe_concept_bear": [horseshoe_concept_bear(d)],
            }
        )
    )

    # Hammer / Inverted Hammer basit işaretleri
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "hammer_mark": [is_hammer(d)],
                "inv_hammer_mark": [is_inverted_hammer(d)],
            }
        )
    )

    # Kırılım teyitleri
    h_bull, h_bear, _ = hammer_breakout(d, buffer_pips=10, vol_confirm=True)
    ih_bull, ih_bear, _ = inverted_hammer_breakout(d, buffer_pips=10, vol_confirm=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "hammer_break_bull": [h_bull],
                "hammer_break_bear": [h_bear],  # genelde False
                "inv_hammer_break_bull": [ih_bull],  # genelde False
                "inv_hammer_break_bear": [ih_bear],
            }
        )
    )

    # Morning/Evening Star işaretleri (3 mum morfolojisi)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "morning_star_mark": [is_morning_star(d)],
                "evening_star_mark": [is_evening_star(d)],
            }
        )
    )

    # Kırılım teyitleri (sonraki mum)
    ms_bull, ms_bear, _ = morning_star_breakout(d, buffer_pips=10, vol_confirm=True)
    es_bull, es_bear, _ = evening_star_breakout(d, buffer_pips=10, vol_confirm=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "morning_star_break_bull": [ms_bull],  # beklenen: True/False
                "evening_star_break_bear": [es_bear],  # beklenen: True/False
            }
        )
    )

    # Three White Soldiers / Three Black Crows (güçlü)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "three_white_soldiers_mark": [is_three_white_soldiers(d)],
                "three_black_crows_mark": [is_three_black_crows(d)],
                "three_white_soldiers_follow": [three_white_soldiers_follow(d)],
                "three_black_crows_follow": [three_black_crows_follow(d)],
            }
        )
    )

    # ========= Chart Patterns =========
    bull, bear, _ = double_bottom_breakout(d, lookback=120, tol=0.005, buffer_pips=10)
    parts.append(
        pd.DataFrame({"time": [last_index], "double_bottom_break_bull": [bull]})
    )

    bull, bear, _ = double_top_breakout(d, lookback=120, tol=0.005, buffer_pips=10)
    parts.append(pd.DataFrame({"time": [last_index], "double_top_break_bear": [bear]}))

    # OBO: normal = bear, counter = bull
    bull, bear = head_shoulders_breakout(d, lookback=80, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "head_shoulders_break_bear": [bear],  # beklenen
                "head_shoulders_counter_bull": [bull],  # TERS kırılım
            }
        )
    )

    # TOBO: normal = bull, counter = bear
    bull, bear = inverse_head_shoulders_breakout(d, lookback=80, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "inverse_head_shoulders_break_bull": [bull],  # beklenen
                "inverse_head_shoulders_counter_bear": [bear],  # TERS kırılım
            }
        )
    )

    bull, bear, _ = triangle_symmetric_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "triangle_sym_break_bull": [bull],
                "triangle_sym_break_bear": [bear],
            }
        )
    )

    bull, bear, _ = triangle_ascending_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame({"time": [last_index], "triangle_asc_break_bull": [bull]})
    )

    bull, bear, _ = triangle_descending_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame({"time": [last_index], "triangle_desc_break_bear": [bear]})
    )

    bull, bear, meta_w = wedge_breakout(d)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "wedge_break_bull": [bull],
                "wedge_break_bear": [bear],
            }
        )
    )

    bull, bear, meta_ch = channel_breakout(
        d, lookback=60, buffer_pips=10, parallel_tol=0.15
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "channel_break_bull": [bull],
                "channel_break_bear": [bear],
                # istersen meta’yı da sakla:
                # "channel_kind": [meta_ch.get("kind","none")]
            }
        )
    )

    bull, bear, _ = cup_breakout(d, lookback=120, rim_tol=0.01, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {"time": [last_index], "cup_break_bull": [bull], "cup_break_bear": [False]}
        )
    )

    bull, bear, _ = dome_breakout(d, lookback=120, rim_tol=0.01, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "dome_break_bull": [False],
                "dome_break_bear": [bear],
            }
        )
    )

    bull, bear, _ = cup_handle_breakout(
        d,
        lookback=160,
        rim_tol=0.01,
        handle_min=5,
        handle_max=25,
        handle_ret_min=0.2,
        handle_ret_max=0.5,
        buffer_pips=10,
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "cup_handle_bull": [bull],
                "cup_handle_bear": [False],
            }
        )
    )

    bull, bear = abcd_strict(
        d,
        lookback=120,
        retrace=0.618,
        ext=1.272,
        tol=0.03,
        confirm_break=False,
        buffer_pips=10,
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "abcd_strict_bull": [bull],
                "abcd_strict_bear": [bear],
            }
        )
    )

    bull, bear, meta_wv = wolfe_breakout(
        d, lookback=120, buffer_pips=10, vol_confirm=True
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "wolfe_break_bull": [bull],
                "wolfe_break_bear": [bear],
                # istersen meta:
                # "wolfe_kind": [meta_wv.get("kind","none")]
            }
        )
    )

    bull, bear, meta_po3 = po3_signal(
        d,
        lookback=80,
        box_lb=20,
        box_tol=0.002,
        spike_pips=20,
        disp_atr=1.0,
        vol_confirm=True,
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "po3_bull": [bull],
                "po3_bear": [bear],
                # "po3_box_hi": [meta_po3["box_hi"]], # istersen meta da saklayabilirsin
                # "po3_box_lo": [meta_po3["box_lo"]],
            }
        )
    )

    bull, bear, _ = quasimodo_breakout(d, lookback=80, retouch_pips=12)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "qml_bull": [bull],
                "qml_bear": [bear],
            }
        )
    )

    bull, bear = three_sweep_concept(d)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "three_sweep_bull": [bull],
                "three_sweep_bear": [bear],
            }
        )
    )

    # ========= Combine all signals =========
    signals = pd.concat(parts, axis=1)

    # duplicate kolonları temizle
    signals = signals.loc[:, ~signals.columns.duplicated()]

    # time kolonunu datetime garantiye al
    if "time" in signals.columns:
        signals["time"] = pd.to_datetime(signals["time"], errors="coerce")
        signals = signals.dropna(subset=["time"])  # boş varsa at
        signals.set_index("time", inplace=True)

    # sadece formasyon kolonlarını bool yap
    for col in signals.columns:
        if col != "score":
            signals[col] = signals[col].fillna(False).astype(bool)

    # score hesapla
    signals["score"] = signals.astype(int).sum(axis=1)

    # 🟢 DEBUG son tabloyu yazdır
    # print("🟢 DEBUG Son mum sinyal tablosu:")
    # print(signals.tail(1).T)
    # print("WEDGE:", signals[["wedge_break_bull", "wedge_break_bear"]].tail(1).T)
    return signals


bullish_keys = {
    "engulf_strong_bull",
    "pinbar_strict_bull",
    "inside_break_bull",
    "outside_break_bull",
    "hammer_break_bull",
    "inv_hammer_break_bull",
    "morning_star_break_bull",
    "three_white_soldiers_follow",
    "double_bottom_break_bull",
    "head_shoulders_counter_bull",
    "triangle_sym_break_bull",
    "triangle_asc_break_bull",
    "wedge_break_bull",
    "channel_break_bull",
    "cup_break_bull",
    "cup_handle_bull",
    "dome_break_bull",
    "abcd_strict_bull",
    "wolfe_break_bull",
    "po3_bull",
    "qml_bull",
    "three_sweep_bull",
}
bearish_keys = {
    "engulf_strong_bear",
    "pinbar_strict_bear",
    "inside_break_bear",
    "outside_break_bear",
    "hammer_break_bear",
    "inv_hammer_break_bear",
    "evening_star_break_bear",
    "three_black_crows_follow",
    "double_top_break_bear",
    "head_shoulders_break_bear",
    "triangle_sym_break_bear",
    "triangle_desc_break_bear",
    "wedge_break_bear",
    "channel_break_bear",
    "cup_break_bear",
    "cup_handle_bear",
    "dome_break_bear",
    "abcd_strict_bear",
    "wolfe_break_bear",
    "po3_bear",
    "qml_bear",
    "three_sweep_bear",
}
FORMATION_LABELS = {
    "engulf_strong_bull": "Engulf (Bull)",
    "engulf_strong_bear": "Engulf (Bear)",
    "pinbar_strict_bull": "Pin Bar (Bull)",
    "pinbar_strict_bear": "Pin Bar (Bear)",
    "inside_break_bull": "Inside Break (Up)",
    "inside_break_bear": "Inside Break (Down)",
    "outside_break_bull": "Outside Break (Up)",
    "outside_break_bear": "Outside Break (Down)",
    "hammer_break_bull": "Hammer Break",
    "inv_hammer_break_bear": "Inverted Hammer Break",
    "morning_star_break_bull": "Morning Star",
    "evening_star_break_bear": "Evening Star",
    "three_white_soldiers_follow": "3 White Soldiers",
    "three_black_crows_follow": "3 Black Crows",
    "double_bottom_break_bull": "Double Bottom",
    "double_top_break_bear": "Double Top",
    "head_shoulders_counter_bull": "H&S (Counter Up)",
    "head_shoulders_break_bear": "H&S (Break Down)",
    "triangle_sym_break_bull": "Sym Triangle (Up)",
    "triangle_sym_break_bear": "Sym Triangle (Down)",
    "triangle_asc_break_bull": "Asc Triangle (Up)",
    "triangle_desc_break_bear": "Desc Triangle (Down)",
    "wedge_break_bull": "Wedge (Up)",
    "wedge_break_bear": "Wedge (Down)",
    "channel_break_bull": "Channel (Up)",
    "channel_break_bear": "Channel (Down)",
    "cup_break_bull": "Cup (Break Up)",
    "cup_break_bear": "Cup (Break Down)",
    "cup_handle_bull": "Cup&Handle (Up)",
    "cup_handle_bear": "Cup&Handle (Down)",
    "dome_break_bull": "Dome (Break Up)",
    "dome_break_bear": "Dome (Break Down)",
    "abcd_strict_bull": "AB=CD (Bull)",
    "abcd_strict_bear": "AB=CD (Bear)",
    "wolfe_break_bull": "Wolfe (Up)",
    "wolfe_break_bear": "Wolfe (Down)",
    "po3_bull": "PO3 (Up)",
    "po3_bear": "PO3 (Down)",
    "qml_bull": "Quasimodo (Bull)",
    "qml_bear": "Quasimodo (Bear)",
    "three_sweep_bull": "Three Sweep (Bull)",
    "three_sweep_bear": "Three Sweep (Bear)",
}
PRIORITY_BULL = [
    "po3_bull",
    "wolfe_break_bull",
    "wedge_break_bull",
    "triangle_sym_break_bull",
    "triangle_asc_break_bull",
    "channel_break_bull",
    "cup_handle_bull",
    "cup_break_bull",
    "inverse_head_shoulders_break_bull",
    "double_bottom_break_bull",
    "engulf_strong_bull",
    "pinbar_strict_bull",
    "morning_star_break_bull",
    "three_white_soldiers_follow",
    "inside_break_bull",
    "outside_break_bull",
    "abcd_strict_bull",
    "qml_bull",
    "three_sweep_bull",
]
PRIORITY_BEAR = [
    "po3_bear",
    "wolfe_break_bear",
    "wedge_break_bear",
    "triangle_sym_break_bear",
    "triangle_desc_break_bear",
    "channel_break_bear",
    "cup_handle_bear",
    "cup_break_bear",
    "head_shoulders_break_bear",
    "double_top_break_bear",
    "engulf_strong_bear",
    "pinbar_strict_bear",
    "evening_star_break_bear",
    "three_black_crows_follow",
    "inside_break_bear",
    "outside_break_bear",
    "abcd_strict_bear",
    "qml_bear",
    "three_sweep_bear",
]


def pick_direction(latest: dict) -> str:
    # bullish/bearish setleri yukarıda tanımlı
    bull_hit = any(bool(latest.get(k, False)) for k in bullish_keys)
    bear_hit = any(bool(latest.get(k, False)) for k in bearish_keys)
    if bull_hit and not bear_hit:
        return "LONG"
    if bear_hit and not bull_hit:
        return "SHORT"
    return "NONE"  # ikisi de yoksa ya da ikisi birden varsa


def pick_formasyon(latest: dict, direction: str) -> str:
    if direction == "LONG":
        order = PRIORITY_BULL
    elif direction == "SHORT":
        order = PRIORITY_BEAR
    else:
        order = PRIORITY_BULL + PRIORITY_BEAR  # yönsüzse genel öncelik

    # 1) öncelik listesine göre ilk TRUE olanı seç
    for k in order:
        if bool(latest.get(k, False)):
            return FORMATION_LABELS.get(k, k)

    # 2) yedek: tabloda herhangi bir TRUE varsa ilkini al
    for k, v in latest.items():
        if (
            k not in ("time", "score", "direction", "formasyon")
            and isinstance(v, bool)
            and v
        ):
            return FORMATION_LABELS.get(k, k)

    return "-"  # hiçbiri yoksa


def postprocess(latest: dict) -> dict:
    direction = pick_direction(latest)
    latest["direction"] = direction
    latest["formasyon"] = pick_formasyon(latest, direction)
    return latest


def get_tf_bar_time(res: dict) -> datetime | None:
    """
    latest/result sözlüğündeki 'time' alanını güvenle datetime'e çevirir.
    pandas Timestamp, string veya datetime gelebilir; None dönebilir.
    """
    t = res.get("time")
    if t is None:
        return None
    try:
        # pd.to_datetime tüm tipleri normalize eder; ardından pure datetime'a çevir.
        return pd.to_datetime(t).to_pydatetime()
    except Exception:
        return None


def _now_minutes_in_tz(tz_name: str) -> int:
    now = get_server_time(ZoneInfo(tz_name))
    return now.hour * 60 + now.minute


# ---- Sinyal işleme (basit sürüm) ----
def handle_signal(tf: str, res: dict):
    global HANDLE_SIGNAL_LOCK
    if HANDLE_SIGNAL_LOCK:
        debug_log("[GUARD] handle_signal reentry blocked")
        return  # recursion kilidi

    HANDLE_SIGNAL_LOCK = True
    try:
        # --- mevcut mesaj inşa kısmın ---
        direction = res.get("direction", "-")
        formasyon = res.get("formasyon", "-")
        true_cols = [k for k, v in res.items() if isinstance(v, bool) and v]

        msg = (
            f"✅[{tf}] sinyali\n"
            f"Yön: {direction}\n"
            f"Formasyon: {formasyon}\n"
            f"TRUE kolonlar: {true_cols}"
        )
        note = res.get("spread_note")
        if note:
            msg += f"\n{note}"

        debug_log(msg)
        # send_signal_message(tf, msg) # istersen aç

        # ⬇⬇ FORCE kancası – kesin çağrı + görünür log
        # print("[FORCE] hook çağrılıyor…")
        # force_open_market_from_res(res)
        # ⬆⬆

        r = dict(res or {})
        r["timeframe"] = tf  # log için
        diagnose_and_maybe_order(tf, r, send=(int(os.getenv("SEND_ORDERS", "1")) == 1))
        return msg
    finally:
        HANDLE_SIGNAL_LOCK = False


# ========= MT5 helper (optional) =========
def mt5_rates_to_ohlc_df(rates) -> pd.DataFrame:
    df = pd.DataFrame(rates)
    df["time"] = pd.to_datetime(df["time"], unit="s")
    df.set_index("time", inplace=True)
    return df[["open", "high", "low", "close"]].copy()


# örnek çağrı
# stats = mini_backtest(SYMBOL, mt5.TIMEFRAME_M15, lookback=500)
# print(stats)


# --- Mini backtest ---
def mini_backtest(symbol: str, timeframe, lookback: int = 500):
    """
    Emir yok, Telegram yok. Son 'lookback' mum için:
    - Kaç sinyal üretildi
    - Win/Loss sayısı
    - Ortalama RR
    - En iyi / en kötü RR
    - Basit max drawdown (RR bazlı)
    """

    # 1) Veri çek
    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, lookback + 2)
    if rates is None or len(rates) < 50:
        return {"error": "veri yok / kısa"}

    df = pd.DataFrame(rates)
    df["time"] = pd.to_datetime(df["time"], unit="s")

    wins = 0
    losses = 0
    rrs = []
    equity = [0.0]  # RR birikimli
    max_peak = 0.0
    max_dd = 0.0
    total_signals = 0

    # 2) Sinyal üretimi için kendi generate_signals akışın
    # NOT: aşağıda, her bar kapanışında "latest" sözlüğü oluşturup
    # senin postprocess/pick_direction/pick_formasyon ile aynı şekilde okuyoruz.
    def build_latest(i: int):
        # i: kapanmış bar (i >= 1)
        row = df.iloc[i]
        latest = {
            "time": row["time"],
            "open": float(row["open"]),
            "high": float(row["high"]),
            "low": float(row["low"]),
            "close": float(row["close"]),
            # aşağıdaki kolonlar senin generate_signals()’tan beklenen boolean anahtarlar olmalı
        }
        return latest

    # Bu iki seti senin projedekiyle aynı tut
    bullish_keys = (
        set(PRIORITY_BULL)
        if "PRIORITY_BULL" in globals()
        else {"OB", "FVG", "BRK", "FTR", "SD", "NSB", "LQ"}
    )
    bearish_keys = (
        set(PRIORITY_BEAR)
        if "PRIORITY_BEAR" in globals()
        else {"OB", "FVG", "BRK", "FTR", "SD", "NSB", "LQ"}
    )

    # 3) Bar bar dolaş
    for i in range(50, len(df) - 1):  # ilk 50 barı ısınma
        latest = build_latest(i)

        # Senin ana sinyal jeneratörün (varsa) ile güncel işaretleri doldur
        try:
            # Eğer sende generate_signals(df) gibi toplu bir fonksiyon varsa,
            # yukarıda bir defa üretip df ile merge edebilirsin.
            # Burada min yalın: mevcut barın basit teyidi için kendi rules fonksiyonlarını çağır.
            pass
        except:
            pass

        # Direction + formasyon seç
        try:
            direction = pick_direction(latest)
        except:
            # basit fallback: close > open ise long, değilse short
            direction = "LONG" if latest["close"] >= latest["open"] else "SHORT"

        try:
            formasyon = pick_formasyon(latest, direction)
        except:
            # fallback: herhangi bir anahtar yoksa "-"
            formasyon = "-"

        # Teyit sayısı (TRUE sayımı) — senin confirm eşiğinle tutarlı olsun
        true_cols = []
        for k, v in list(latest.items()):
            if isinstance(v, bool) and v:
                true_cols.append(k)
        confirm = len(true_cols)
        th = (
            get_confirm_threshold(timeframe)
            if "get_confirm_threshold" in globals()
            else 3
        )

        if confirm < th or formasyon == "-":
            continue  # sinyal kabul edilmedi

        total_signals += 1

        # 4) Giriş/Çıkış (basit simülasyon)
        entry = df.iloc[i + 1]["open"]  # bir sonraki bar açılışından giriş
        # TP/SL mesafesi
        try:
            pips = choose_target_pips(timeframe, mode=TP_MODE.lower())
        except:
            pips = 30  # fallback

        # point → pip dönüşümü projene göre değişiyorsa ayarla
        point = mt5.symbol_info(symbol).point
        pip_value_in_price = 10 * point  # ör: 5 basamaklıysa 10*point = 0.001

        tp_dist = pips * pip_value_in_price
        sl_dist = pips * pip_value_in_price  # 1:1 RR basit yaklaşım

        if direction == "LONG":
            tp = entry + tp_dist
            sl = entry - sl_dist
        else:
            tp = entry - tp_dist
            sl = entry + sl_dist

        # bar-bar ileri sar, TP mi SL mi önce?
        rr = None
        for j in range(i + 1, len(df)):
            hi = df.iloc[j]["high"]
            lo = df.iloc[j]["low"]
            if direction == "LONG":
                hit_tp = hi >= tp
                hit_sl = lo <= sl
            else:
                hit_tp = lo <= tp
                hit_sl = hi >= sl

            if hit_tp and hit_sl:
                # aynı bar içinde ikisine de dokunursa “kötümser” SL say
                rr = -1.0
                break
            elif hit_tp:
                rr = +1.0
                break
            elif hit_sl:
                rr = -1.0
                break

        # sonuç yoksa (veri bitti) break
        if rr is None:
            break

        rrs.append(rr)
        if rr > 0:
            wins += 1
        else:
            losses += 1

        # equity & max DD
        equity.append(equity[-1] + rr)
        if equity[-1] > max_peak:
            max_peak = equity[-1]
        dd = max_peak - equity[-1]
        if dd > max_dd:
            max_dd = dd

    # 5) Özet
    if rrs:
        avg_rr = float(np.mean(rrs))
        best = float(np.max(rrs))
        worst = float(np.min(rrs))
    else:
        avg_rr, best, worst = 0.0, 0.0, 0.0

    return {
        "symbol": symbol,
        "timeframe": str(timeframe),
        "lookback": lookback,
        "signals": total_signals,
        "wins": wins,
        "losses": losses,
        "winrate_%": round(100 * wins / max(1, wins + losses), 1),
        "avg_RR": round(avg_rr, 3),
        "best_RR": best,
        "worst_RR": worst,
        "max_DD_RR": round(max_dd, 2),
    }


def get_spread_points(symbol: str):
    """
    Sembole ait anlık spread'i point cinsinden döndürür.
    return: (spread_pts, bid, ask) veya (None, None, None)
    """
    tick = mt5.symbol_info_tick(symbol)
    info = mt5.symbol_info(symbol)
    if tick is None or info is None:
        return None, None, None

    point = info.point or 0.01  # emniyet kemeri
    bid = float(tick.bid)
    ask = float(tick.ask)
    spread_pts = abs(ask - bid) / point
    return spread_pts, bid, ask


def spread_gate(
    symbol: str, entry_price: float, sl_price: float, mode: str | None = None
):
    """
    Spread kapısı.
    return: (ok: bool, reason: str|None, spread_pts: float, ratio: float)
    """
    # Dışarıdan mode verilmemişse aktif modu içeride hesapla
    eff_mode = (mode or get_effective_spread_mode()).upper()  # "SOFT" | "HARD" | "AUTO"

    max_pts = float(MAX_SPREAD_POINTS)
    max_ratio = float(MAX_SPREAD_SL_RATIO)

    spread_pts, bid, ask = get_spread_points(symbol)
    if spread_pts is None:
        return True, "NO-SPREAD-DATA", 0.0, 0.0  # veri yoksa engelleme

    info = mt5.symbol_info(symbol)
    point = max(info.point, 1e-9)

    sl_dist_pts = abs(entry_price - sl_price) / point
    ratio = spread_pts / max(sl_dist_pts, 1e-9)

    breach_pts = spread_pts > max_pts
    breach_ratio = ratio > max_ratio

    # SOFT: bloklama yok, sadece uyarı nedeni döndür
    if eff_mode == "SOFT":
        reason = None
        if breach_pts and breach_ratio:
            reason = "WARN:SPREAD:PTS&RATIO"
        elif breach_pts:
            reason = "WARN:SPREAD:PTS"
        elif breach_ratio:
            reason = "WARN:SPREAD:RATIO"
        return True, reason, spread_pts, ratio

    # HARD: iki limitten biri aşılırsa blokla
    if eff_mode == "HARD":
        if breach_pts or breach_ratio:
            return False, "BLOCK:HARD", spread_pts, ratio
        return True, None, spread_pts, ratio

    # AUTO: ikisinden biri aşılırsa blokla (gece/volatilite koruması gibi)
    if breach_pts or breach_ratio:
        return False, "BLOCK:AUTO", spread_pts, ratio
    return True, None, spread_pts, ratio


# --- 15 dk ---
def check_signals_m15(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M15"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


def sanity_startup_check(symbol):
    # 1) .env okundu mu?
    debug_log(
        "[CHECK] SPREAD_MODE:",
        SPREAD_MODE,
        "HARD_W:",
        HARD_WINDOWS,
        "SOFT_W:",
        SOFT_WINDOWS,
    )

    # 2) Saat penceresi / AUTO modu
    try:
        debug_log("[CHECK] effective_mode:", get_effective_spread_mode())
    except Exception as e:
        debug_log("[CHECK] get_effective_spread_mode ERROR:", e)

    # 3) Spread fonksiyonu
    try:
        sp, bid, ask = get_spread_points(symbol)
        debug_log(f"[CHECK] spread={sp}p bid={bid} ask={ask}")
    except Exception as e:
        debug_log("[CHECK] get_spread_points ERROR:", e)


# --- 30 dk ---
def check_signals_m30(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M30"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 45 dk (M15 + M30 ortalaması) ---
def check_signals_m45(symbol):
    rates15 = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M15"], 0, 300)
    rates30 = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M30"], 0, 300)
    if (rates15 is None or len(rates15) == 0) or (rates30 is None or len(rates30) == 0):
        return None

    df15 = mt5_rates_to_ohlc_df(rates15)
    df30 = mt5_rates_to_ohlc_df(rates30)
    df_mixed = (df15 + df30) / 2
    df_mixed.dropna(inplace=True)
    if df_mixed.empty:
        return None

    sig = generate_signals(df_mixed).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 1 saat ---
def check_signals_h1(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H1"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 2 saat ---
def check_signals_h2(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H2"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 3 saat ---
def check_signals_h3(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H3"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 4 saat ---
def check_signals_h4(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H4"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 12 saat ---
def check_signals_h12(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H12"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# TF → fonksiyon eşlemesi
TF_FUNS = {
    "M15": check_signals_m15,
    "M30": check_signals_m30,
    "M45": check_signals_m45,
    "H1": check_signals_h1,
    "H2": check_signals_h2,
    "H3": check_signals_h3,
    "H4": check_signals_h4,
    "H12": check_signals_h12,
}


def run_boot(symbol: str, sleep_sec: int = 5):
    """Tarama döngüsü + kapılar + RR/Mesafe sanity."""

    # TF → sinyal fonksiyonu eşlemesi (sende isimler farklıysa uyarlayabilirsin)
    fns = {
        "M15": check_signals_m15,
        "M30": check_signals_m30,
        "M45": check_signals_m45,
        "H1": check_signals_h1,
        "H2": check_signals_h2,
        "H3": check_signals_h3,
        "H4": check_signals_h4,
        "H12": check_signals_h12,
    }

    # Global bar-zaman takibi
    global LAST_BAR_TIME
    if "LAST_BAR_TIME" not in globals():
        LAST_BAR_TIME = {}

    while True:
        loop_start = time.time()
        m15_closed = False

        try:
            for tf, fn in fns.items():
                # --- 0) Sinyal çek
                res = fn(symbol)
                if not res:
                    continue

                # --- 1) Aynı bar tekrarını engelle
                bar_time = get_tf_bar_time(res)
                is_new_bar = False

                if tf not in LAST_BAR_TIME:
                    if bar_time is not None:
                        LAST_BAR_TIME[tf] = bar_time
                    # warm-up
                    continue

                last_t = LAST_BAR_TIME.get(tf)
                if (last_t is not None) and (bar_time is not None):
                    if bar_time == last_t:
                        continue  # aynı bar
                    else:
                        is_new_bar = True

                if bar_time is not None:
                    LAST_BAR_TIME[tf] = bar_time

                if tf == "M15" and is_new_bar:
                    m15_closed = True

                # --- 2) Aynı içerikli mesajı tekrarlama
                if is_duplicate_msg(tf, res):
                    continue
                remember_msg(tf, res)

                # --- SPREAD debug + RCA'ya not bırak ---

                limit_pts = float(os.getenv("MAXIMUM_SPREAD_POINTS", "99999"))
                limit_ratio = float(os.getenv("MAX_SPREAD_LS_RATIO", "9.99"))

                # --- 4) D1 trend kapısı
                ok_trend, trend_note = d1_trend_gate(res.get("direction"), symbol)
                if not ok_trend:
                    # print(f"[{tf}] SKIP d1_trend: note={trend_note}")
                    continue
                if trend_note:
                    res["trend_note"] = trend_note

                # --- 5) Yön kontrolü
                if str(res.get("direction", "NONE")).upper() not in ("LONG", "SHORT"):
                    # print(f"[{tf}] SKIP direction=NONE")
                    continue

                # --- 6) RR/Mesafe sanity (ENV'den) <<<<<< EKLEDİĞİMİZ BLOK
                si = mt5.symbol_info(symbol)
                point = si.point if si else 0.01
                digits = si.digits if si else 2

                entry = float(res.get("entry_price") or 0.0)
                sl = float(res.get("sl_price") or 0.0)
                tp = float(res.get("tp_price") or 0.0)

                # ENTRY YOKSA: tarafı belirle ve anlık fiyatı kullan
                tick = mt5.symbol_info_tick(symbol)
                dir_val = str(res.get("direction", "LONG")).upper()
                side = mt5.ORDER_TYPE_SELL if dir_val == "SHORT" else mt5.ORDER_TYPE_BUY
                price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask

                if entry <= 0:
                    entry = float(price)
                    res["entry_price"] = entry  # log ve devam için kaydet

                def _pips(a, b):
                    if not a or not b:
                        return 0.0
                    pts = abs(a - b) / point
                    return pts / max(1, POINTS_PER_PIP)

                risk_pips = _pips(entry, sl)
                reward_pips = _pips(tp, entry)

                # --- 3) Spread kapısı
                mode_now = get_effective_spread_mode()
                ok, spread_reason, spread_pts, ratio = spread_gate(
                    symbol, entry_price=entry, sl_price=sl, mode=mode_now
                )

                debug_log(
                    f"[SPREAD][{tf}] spread_pts={spread_pts:.1f} ratio={ratio:.2f} "
                    f"limit_pts={limit_pts:.0f} limit_ratio={limit_ratio:.2f} "
                    f"mode={mode_now} why={spread_reason}"
                )
                res["spread_why"] = spread_reason
                if not ok:
                    res["spread_note"] = spread_reason
                    continue
                else:
                    res.pop("spread_note", None)

                # === RCA: PRE-GATE (sinyal neden SKIP?) ===
                tf_used = str((res or {}).get("timeframe") or tf)
                why_val = locals().get("why", os.getenv("SPREAD_MODE", "OFF"))

                res["spread_why"] = (
                    why_val  # elindeki spread kararı (OK / RATIO / POINTS vs.)
                )

                # --- AUTO FILL: SL/TP eksikse seviyelerden doldur ---
                try:
                    # her şeyi res sözlüğünden oku; yoksa güvenli fallback
                    dir_side = (
                        res.get("side") or res.get("direction") or "LONG"
                    ).upper()
                    entry_px = float(
                        res.get("entry_price", res.get("entry", 0.0)) or 0.0
                    )

                    sl_val = res.get("sl_price")
                    tp_val = res.get("tp_price")
                    sl_in = None if (sl_val in (None, 0)) else float(sl_val)
                    tp_in = None if (tp_val in (None, 0)) else float(tp_val)

                    lvls = res.get("levels")
                    atr_p = res.get("atr_pips")

                    if (sl_in is None) or (tp_in is None):
                        g = compute_sl_tp_guard(
                            symbol=symbol,
                            direction=dir_side,
                            entry=entry_price,
                            sl=sl_in,
                            tp=tp_in,
                            si=None,
                            tick=None,  # scope'ta yoksa None sorun değil
                            levels=lvls,
                            atr_pips=atr_p,
                        )
                        res["sl_price"] = g["sl_price"]
                        res["tp_price"] = g["tp_price"]
                        # varsa local değişkenleri de güncelle
                        sl_price = res["sl_price"]
                        tp_price = res["tp_price"]
                except Exception as _e:
                    print("[RCA] WARN auto-fill(check_all_timeframes):", _e)
                # --- /AUTO FILL ---

                print(f"[RCA][{tf_used}] -- pre-gate --")
                rca_order(
                    symbol, res, tf=tf_used
                )  # request yok; gate sebeplerini döker

                EPS = 1e-9
                rr = reward_pips / max(risk_pips, EPS)
                res["rr"] = rr
                try:
                    tf_used = res.get("timeframe", tf)
                    handle_signal(tf_used, res)
                except Exception as e:
                    debug_log(f"[{tf_used}] handle_signal hata: {e}")

                # 6.c) RR'yi hesapla ve res'e koy
                # EPS = 1e-9
                # rr = reward_pips / max(risk_pips, EPS)
                # res["rr"] = rr

                # --- 7) Normal akış (telegram/işlem)
                try:
                    tf_used = res.get("timeframe", tf)
                    handle_signal(tf_used, res)
                except Exception as e:
                    debug_log(f"[{tf_used}] handle_signal hata: {e}")

            # --- TF taraması bitti; M15 kapanışında evaluate
            if m15_closed:
                try:
                    print("[EVAL] M15 close -> evaluate")
                    eval_mode = (
                        "trade" if int(os.getenv("SEND_ORDERS", "0")) == 1 else "signal"
                    )
                    check_all_timeframes(mode=eval_mode)
                except Exception as e:
                    debug_log(f"[EVAL ERROR] {e.__class__.__name__}:{e}")
                    traceback.print_exc()
                finally:
                    m15_closed = False

        except Exception as e:
            debug_log(f"[LOOP ERROR] {e}")

        # tempo
        elapsed = time.time() - loop_start
        time.sleep(max(0.0, sleep_sec - elapsed))


def ema(series, span):
    return series.ewm(span=span, adjust=False).mean()


def sma(series, window):
    return series.rolling(window=window).mean()


def atr(data, window=14):
    high = data["high"]
    low = data["low"]
    close = data["close"]
    tr1 = high - low
    tr2 = (high - close.shift(1)).abs()
    tr3 = (low - close.shift(1)).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    return tr.rolling(window).mean()


# ----------------- 1) RSI -----------------
def rsi_confirmation(data, period=14, lower=30, upper=70):
    close = data["close"]
    delta = close.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / (avg_loss.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    rsi_val = float(rsi.iloc[-1]) if not rsi.empty else np.nan
    return rsi_val <= lower, rsi_val >= upper


# ----------------- 2) MACD -----------------
def macd_confirmation(data, fast=12, slow=26, signal=9):
    close = data["close"]
    ema_fast = close.ewm(span=fast, adjust=False).mean()
    ema_slow = close.ewm(span=slow, adjust=False).mean()
    macd_line = ema_fast - ema_slow
    signal_line = macd_line.ewm(span=signal, adjust=False).mean()
    hist = macd_line - signal_line
    return (macd_line.iloc[-1] > signal_line.iloc[-1]) and (hist.iloc[-1] > 0), (
        macd_line.iloc[-1] < signal_line.iloc[-1]
    ) and (hist.iloc[-1] < 0)


# ----------------- 3) Bollinger -----------------
def bollinger_confirmation(data, length=20, dev=2.0):
    close = data["close"]
    mid = close.rolling(window=length).mean()
    std = close.rolling(window=length).std()
    upper = mid + dev * std
    lower = mid - dev * std
    c = float(close.iloc[-1])
    return c > float(upper.iloc[-1]), c < float(lower.iloc[-1])


# ----------------- 4) Heikin Ashi -----------------
def heikin_ashi_confirmation(data):
    o = data["open"]
    h = data["high"]
    l = data["low"]
    c = data["close"]
    ha_close = (o + h + l + c) / 4.0
    ha_open = pd.Series(index=data.index, dtype=float)
    ha_open.iloc[0] = (o.iloc[0] + c.iloc[0]) / 2.0
    for i in range(1, len(data)):
        ha_open.iloc[i] = (ha_open.iloc[i - 1] + ha_close.iloc[i - 1]) / 2.0
    ha_o = ha_open.iloc[-1]
    ha_c = ha_close.iloc[-1]
    return ha_c > ha_o, ha_c < ha_o


# ----------------- 5) Fibonacci -----------------
def fib_confirmation(data, lookback=200, tol_percent=0.003):
    high = data["high"][-lookback:]
    low = data["low"][-lookback:]
    swing_high = float(high.max())
    swing_low = float(low.min())
    rng = swing_high - swing_low
    if rng == 0:
        return False, False
    level382 = swing_high - 0.382 * rng
    level618 = swing_high - 0.618 * rng
    c = float(data["close"].iloc[-1])
    in_zone = (c >= level618) and (c <= level382)
    return in_zone, False


# ----------------- 6) Trendline Breakout -----------------
def trendline_breakout_check(data, lookback=50):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    last_high = float(highs.max())
    last_low = float(lows.min())
    c = float(data["close"].iloc[-1])
    return c > last_high, c < last_low


# ----------------- 7) Mavilim (MA Filter) -----------------
def mavilim_confirmation(data, short=50, long=200):
    if len(data) < long:
        return False, False
    ma_s = float(ema(data["close"], short).iloc[-1])
    ma_l = float(ema(data["close"], long).iloc[-1])
    return ma_s > ma_l, ma_s < ma_l


# ----------------- 8) Supertrend -----------------
def supertrend_confirmation(data, period=10, multiplier=3):
    hl2 = (data["high"] + data["low"]) / 2
    atr_val = atr(data, period)
    upperband = hl2 + multiplier * atr_val
    lowerband = hl2 - multiplier * atr_val
    c = data["close"].iloc[-1]
    return c > lowerband.iloc[-1], c < upperband.iloc[-1]


# ----------------- 9) EMA Ribbon -----------------
def ema_ribbon_confirmation(data, spans=(8, 13, 21, 34, 55, 89)):
    emas = [ema(data["close"], s) for s in spans]
    last = [float(e.iloc[-1]) for e in emas]
    return all(last[i] > last[i + 1] for i in range(len(last) - 1)), all(
        last[i] < last[i + 1] for i in range(len(last) - 1)
    )


# ----------------- 10) Liquidity Sweep -----------------
def liquidity_sweep_confirmation(data):
    if len(data) < 3:
        return False, False
    prev = data.iloc[-2]
    last = data.iloc[-1]
    ok_long = (prev["high"] < last["high"]) and (last["close"] < prev["close"])
    ok_short = (prev["low"] > last["low"]) and (last["close"] > prev["close"])
    return ok_long, ok_short


# ----------------- 11) Old High/Low -----------------
def old_high_low_confirmation(data, lookback=200):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return c > float(highs.max()), c < float(lows.min())


# ----------------- 12) MSB -----------------
def msb_confirmation(data, lookback=20):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return c > float(highs.max()), c < float(lows.min())


# ----------------- 13) ChoCH -----------------
def choch_confirmation(data, lookback=50):
    if len(data) < 6:
        return False, False
    highs = data["high"][-6:]
    lows = data["low"][-6:]
    if highs.iloc[-1] > highs.iloc[-2] and lows.iloc[-1] > lows.iloc[-2]:
        return True, False
    if highs.iloc[-1] < highs.iloc[-2] and lows.iloc[-1] < lows.iloc[-2]:
        return False, True
    return False, False


# ----------------- 14) Order Block -----------------
def order_block_confirmation(data, lookback=100):
    bodies = (data["close"] - data["open"]).abs()
    idx = bodies[-lookback:].idxmax()
    ob_open = float(data.loc[idx, "open"])
    ob_close = float(data.loc[idx, "close"])
    c = float(data["close"].iloc[-1])
    return (c >= min(ob_open, ob_close)) and (c <= max(ob_open, ob_close)) and (
        ob_close > ob_open
    ), (c >= min(ob_open, ob_close)) and (c <= max(ob_open, ob_close)) and (
        ob_close < ob_open
    )


# ----------------- 15) Breaker Block -----------------
def breaker_block_confirmation(data, lookback=100):
    ok_long, ok_short = order_block_confirmation(data, lookback)
    last_body = data["close"].iloc[-1] - data["open"].iloc[-1]
    if ok_long and last_body < 0:
        return True, False
    if ok_short and last_body > 0:
        return False, True
    return False, False


# ----------------- 16) OTE -----------------
def ote_confirmation(data, lookback=200):
    high = float(data["high"][-lookback:].max())
    low = float(data["low"][-lookback:].min())
    rng = high - low
    if rng == 0:
        return False, False
    ote_top = high - 0.618 * rng
    ote_bot = high - 0.705 * rng
    c = float(data["close"].iloc[-1])
    return (c >= ote_bot) and (c <= ote_top), False


# ----------------- 17) Supply & Demand -----------------
def supply_demand_confirmation(data, lookback=200):
    close = data["close"]
    pct = close.pct_change()
    idx = pct[-lookback:].abs().idxmax()
    zone = float(data.loc[idx, "close"])
    c = float(close.iloc[-1])
    return c >= zone, c <= zone


# ----------------- 18) FTR -----------------
def ftr_confirmation(data, lookback=50):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return c > float(highs.max()), c < float(lows.min())


# ----------------- 19) FVG -----------------
def fvg_confirmation(data):
    if len(data) < 3:
        return False, False
    a = data.iloc[-3]
    b = data.iloc[-2]
    c = data.iloc[-1]
    return (b["low"] > a["high"] and c["low"] > a["high"]), (
        b["high"] < a["low"] and c["high"] < a["low"]
    )


# ----------------- 20) SR Flip -----------------
def sr_flip_confirmation(data, lookback=200):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return (c > float(highs.max())) and (data["close"].iloc[-2] < float(highs.max())), (
        c < float(lows.min())
    ) and (data["close"].iloc[-2] > float(lows.min()))


# ----------------- 21) Sniper Entry -----------------
def sniper_entry_confirmation(data):
    fib_ok_long, fib_ok_short = fib_confirmation(data)
    ob_ok_long, ob_ok_short = order_block_confirmation(data)
    return fib_ok_long and ob_ok_long, fib_ok_short and ob_ok_short


# ----------------- 22) CRT -----------------
def crt_confirmation(data):
    if len(data) < 3:
        return False, False
    b = data.iloc[-2]
    c = data.iloc[-1]
    be = (
        (b["close"] < b["open"])
        and (c["close"] > c["open"])
        and (c["close"] > b["open"])
    )
    se = (
        (b["close"] > b["open"])
        and (c["close"] < c["open"])
        and (c["close"] < b["open"])
    )
    return be, se


# === Order Block (OB) ===
def ob_check(df):
    if len(df) < 2:
        return False, False, None
    last = df.iloc[-1]
    prev = df.iloc[-2]

    ok_long = last.close > prev.high
    ok_short = last.close < prev.low

    level = prev.low if ok_long else prev.high if ok_short else None
    return ok_long, ok_short, level


# === Breaker Block (BRK) ===
def brk_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = prev.high < mid.low and last.close > mid.high
    ok_short = prev.low > mid.high and last.close < mid.low

    level = mid.low if ok_long else mid.high if ok_short else None
    return ok_long, ok_short, level


# === SR Flip (Destek ↔ Direnç) ===
def sr_flip_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = prev.low < mid.low < last.close
    ok_short = prev.high > mid.high > last.close

    level = mid.low if ok_long else mid.high if ok_short else None
    return ok_long, ok_short, level


# === FVG (Fair Value Gap) ===
def fvg_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = prev.high < last.low
    ok_short = prev.low > last.high

    level = prev.high if ok_long else prev.low if ok_short else None
    return ok_long, ok_short, level


# === FTR (Failed To Return) ===
def ftr_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = last.close > prev.high and mid.low > prev.low
    ok_short = last.close < prev.low and mid.high < prev.high

    level = prev.low if ok_long else prev.high if ok_short else None
    return ok_long, ok_short, level


# === Supply & Demand Zones (SD) ===
def sd_check(df):
    if len(df) < 5:
        return False, False, None
    zone_high = df["high"].iloc[-5:].max()
    zone_low = df["low"].iloc[-5:].min()

    ok_long = df["close"].iloc[-1] > zone_high
    ok_short = df["close"].iloc[-1] < zone_low

    level = zone_low if ok_long else zone_high if ok_short else None
    return ok_long, ok_short, level


# === Market Structure Break (MSB) ===
def msb_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = last.high > mid.high and last.close > mid.close
    ok_short = last.low < mid.low and last.close < mid.close

    level = mid.low if ok_long else mid.high if ok_short else None
    return ok_long, ok_short, level


# === Liquidity Sweep (Equal High/Low, Old High/Low) ===
def liquidity_sweep_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = last.low < prev.low and last.close > prev.close
    ok_short = last.high > prev.high and last.close < prev.close

    level = prev.low if ok_long else prev.high if ok_short else None
    return ok_long, ok_short, level


# ----------------- Hepsini Topla -----------------
def all_confirmations(data):
    funcs = [
        rsi_confirmation,
        macd_confirmation,
        bollinger_confirmation,
        heikin_ashi_confirmation,
        fib_confirmation,
        trendline_breakout_check,
        mavilim_confirmation,
        supertrend_confirmation,
        ema_ribbon_confirmation,
        liquidity_sweep_confirmation,
        old_high_low_confirmation,
        msb_confirmation,
        choch_confirmation,
        order_block_confirmation,
        breaker_block_confirmation,
        ote_confirmation,
        supply_demand_confirmation,
        ftr_confirmation,
        fvg_confirmation,
        sr_flip_confirmation,
        sniper_entry_confirmation,
        crt_confirmation,
    ]
    teyit_sayisi_long = 0
    teyit_sayisi_short = 0
    for fn in funcs:
        try:
            ok_long, ok_short = fn(data)
        except:
            ok_long, ok_short = False, False
        if ok_long:
            teyit_sayisi_long += 1
        if ok_short:
            teyit_sayisi_short += 1

    # 🔽🔽🔽 BURAYA STOP LOSS FONKSİYONLARINI ÇAĞIRACAKSIN 🔽🔽🔽
    ob_long, ob_short, ob_level = ob_check(data)
    brk_long, brk_short, brk_level = brk_check(data)
    sr_long, sr_short, sr_level = sr_flip_check(data)
    fvg_long, fvg_short, fvg_level = fvg_check(data)
    ftr_long, ftr_short, ftr_level = ftr_check(data)
    sd_long, sd_short, sd_level = sd_check(data)
    msb_long, msb_short, msb_level = msb_check(data)
    lq_long, lq_short, lq_level = liquidity_sweep_check(data)

    levels = {
        "OB": ob_level,
        "BRK": brk_level,
        "SR": sr_level,
        "FVG": fvg_level,
        "FTR": ftr_level,
        "SD": sd_level,
        "MSB": msb_level,
        "LQ": lq_level,
    }

    return teyit_sayisi_long, teyit_sayisi_short, levels

    # Öncelikli seviyelerden SL seç
    for key in priority:
        level = levels.get(key)
        if level is not None:
            if isinstance(level, pd.Series):
                level = float(level.iloc[-1])
            else:
                level = float(level)
            return level, key

    # Eğer hiç seviye yoksa fallback → son barın low/high
    last = tf_df.iloc[-1]
    if direction == "LONG":
        return float(last["low"]) - (pip_buffer * 0.5), "ATR-Fallback"
    else:
        return float(last["high"]) + (pip_buffer * 0.5), "ATR-Fallback"


# Günlük trend analizi
# D1 trend yönünü üretir: "LONG" / "SHORT" / "NONE"
def get_d1_trend(symbol: str, ma_period: int | None = None) -> str:
    try:
        # env'den default MA
        if ma_period is None:
            try:
                ma_period = int(os.getenv("D1_TREND_MA", "50"))
            except Exception:
                ma_period = 50

        # D1 OHLC al
        df = get_ohlc(symbol, mt5.TIMEFRAME_D1, 200)
        if df is None or df.empty or len(df) < ma_period + 1:
            return "NONE"

        close = df["close"]
        ma = close.rolling(window=ma_period).mean()
        last_close = float(close.iloc[-1])
        last_ma = float(ma.iloc[-1])

        if np.isnan(last_ma):
            return "NONE"

        if last_close > last_ma:
            return "LONG"
        elif last_close < last_ma:
            return "SHORT"
        else:
            return "NONE"

    except Exception:
        return "NONE"


timeframes_to_check = {
    "M15": check_signals_m15,
    "M30": check_signals_m30,
    "M45": check_signals_m45,  # 15dk + 30dk karışımı
    "H1": check_signals_h1,
    "H2": check_signals_h2,
    "H3": check_signals_h3,
    "H4": check_signals_h4,
    "H12": check_signals_h12,
}


def d1_trend_gate(direction: str, symbol: str) -> tuple[bool, str | None]:
    """
    D1 trend filtresi:
      OFF -> her zaman True
      SOFT -> trend tersse not düş; yine de kabul et
      HARD -> trend tersse reddet
    return: (ok, note)
    """
    mode = D1_TREND_MODE  # .env’den okunuyor (OFF / SOFT / HARD)
    if mode == "OFF":
        return True, None

    try:
        # get_d1_trend LONG/SHORT/NONE döndürür
        d1_dir = get_d1_trend(symbol, D1_TREND_MA)  # ma periyodunu da iletelim
    except Exception as e:
        debug_log(f"D1 trend hesaplanamadı: {e}")
        # SOFT’ta geç, HARD’da reddet
        return (True, "trend_unavailable") if mode == "SOFT" else (False, None)

    # Trend yoksa
    if d1_dir == "NONE" or d1_dir is None:
        return (True, "trend_none") if mode == "SOFT" else (False, None)

    # Trend aynı yönde → serbest
    if direction == d1_dir:
        return True, None

    # Trend ters
    if mode == "SOFT":
        return True, f"D1 trend {d1_dir}"
    else:  # HARD
        return False, None


# --- MT5 İşlem Açma Fonksiyonu ---


def calculate_lot(
    entry_price: float, sl_price: float, risk_percent: float = 0.02
) -> float:
    """
    Risk başına lot: SL mesafesine spread tamponu eklenmiş olarak hesaplar.
    """
    # 1) Hesap bilgisi
    account = mt5.account_info()
    if account is None:
        debug_log(f"❌ Hesap bilgisi alınamadı: {mt5.last_error()}", force=True)
        return 0.10  # fallback sabit lot

    balance = float(account.balance)
    risk_usd = max(0.0, balance * float(risk_percent))  # riske edilecek para

    # 2) Enstrüman bilgisi
    info = mt5.symbol_info(SYMBOL)
    if info is None:
        debug_log("❌ symbol_info alınamadı", force=True)
        return 0.10

    point = float(info.point or 0.01)
    tick_val = float(getattr(info, "trade_tick_value", 1.0) or 1.0)
    tick_size = float(getattr(info, "trade_tick_size", point) or point)

    # 1 lot için 1 'point'lik fiyat hareketinin USD karşılığı
    usd_per_point_per_lot = tick_val / max(tick_size, 1e-9)

    # 3) SL mesafesi → puan
    sl_dist_pts = abs(float(entry_price) - float(sl_price)) / max(point, 1e-9)

    # 4) SPREAD tamponunu ekle
    spread_pts, bid, ask = get_spread_points(SYMBOL)  # (spread_pts "point" cinsinden)
    sl_dist_effective = sl_dist_pts + float(spread_pts)

    # Aşırı küçük mesafelere karşı koruma
    sl_dist_effective = max(sl_dist_effective, 1.0)

    # 5) Lot hesabı
    # risk_usd ≈ lot * sl_dist_effective * usd_per_point_per_lot
    raw_lot = risk_usd / (sl_dist_effective * usd_per_point_per_lot)

    # 6) Broker limitlerine yuvarla / kısıtla
    vol_min = float(getattr(info, "volume_min", 0.01) or 0.01)
    vol_max = float(getattr(info, "volume_max", 100.0) or 100.0)
    vol_step = float(getattr(info, "volume_step", 0.01) or 0.01)

    # adıma yuvarla
    lot_steps = max(1, round(raw_lot / vol_step))
    lot = lot_steps * vol_step
    lot = min(max(lot, vol_min), vol_max)

    debug_log(
        f"[LOT] balance={balance:.2f} risk={risk_usd:.2f}USD "
        f"SL_pts={sl_dist_pts:.1f} spread_pts={spread_pts:.1f} "
        f"eff_pts={sl_dist_effective:.1f} usd/pt/lot={usd_per_point_per_lot:.4f} "
        f"lot={lot}",
        force=True,
    )
    return round(lot, 2)


def has_open_position(symbol):
    positions = mt5.positions_get(symbol=symbol)
    if positions:
        return True
    return False


def calculate_atr(df: pd.DataFrame, period: int = 14) -> pd.Series:
    """
    Average True Range (ATR) hesaplar.
    :param df: OHLC DataFrame (open, high, low, close kolonları olmalı)
    :param period: ATR periyodu (varsayılan 14)
    :return: ATR serisi
    """
    high = df["high"]
    low = df["low"]
    close = df["close"]

    # True Range hesapla
    df["prev_close"] = close.shift(1)
    tr1 = high - low
    tr2 = (high - df["prev_close"]).abs()
    tr3 = (low - df["prev_close"]).abs()

    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    # ATR = TR'nin üssel hareketli ortalaması (EMA)
    atr = tr.ewm(span=period, adjust=False).mean()

    return atr


def place_order(symbol, order_type, lot, entry_price, sl_price, tp_price, side_txt):
    reasons: list[str] = []  # init reasons list
    order_type_mt5 = mt5.ORDER_TYPE_BUY if order_type == "BUY" else mt5.ORDER_TYPE_SELL

    allow_multi = int(os.getenv("ALLOW_MULTIPLE_POSITIONS", "1"))
    if not allow_multi:
        # Aynı sembolde ve aynı yönde açık pozisyon var mı?
        positions = mt5.positions_get(symbol=symbol)
        if positions:
            for pos in positions:
                if pos.type == order_type_mt5:  # aynı yöndeyse
                    debug_log(
                        f"[BLOCK] {symbol} için aynı yönde açık pozisyon var, yeni işlem açılmadı."
                    )
                    return None

    # Cooldown kontrolü
    global LAST_TRADE_TIME
    cooldown = int(os.getenv("TRADE_COOLDOWN_SEC", "0"))

    if cooldown > 0 and "LAST_TRADE_TIME" in globals():
        elapsed = (
            now_tr()(ZoneInfo("Europe/ISTANBUL")) - LAST_TRADE_TIME.total_seconds()
        )
        if elapsed < cooldown:
            debug_log(
                f"[BLOCK] Cooldown aktif ({elapsed:.0f}/{cooldown} sn) -> yeni işlem açılmadı"
            )
            return None

    max_trades = int(os.getenv("MAX_CONCURRENT_TRADES", "0"))
    if max_trades > 0:
        current = active_trade_count()
        if current >= max_trades:
            debug_log(
                f"[BLOCK] Maksimum açık işlem limiti aşıldı: {current}/{max_trades}"
            )
            return None

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": float(os.getenv("LOT_SIZE", "0.1")),
        "type": order_type,
        "entry": float(entry_price),
        "sl": float(sl_price),
        "tp": float(tp_price),
        "deviation": 20,
        "magic": 123456,
        "comment": "Gold Bot",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }

    request = _sanitize_request_plus(request)

    si = mt5.symbol_info(symbol)
    try:
        tick = mt5.symbol_info_tick(symbol)
    except Exception:
        tick = None

    direction = "LONG" if order_type_mt5 == mt5.ORDER_TYPE_BUY else "SHORT"

    # sadece eksikse guard çağır
    if not sl_price or not tp_price:
        guard = compute_sl_tp_guard(
            symbol,
            direction,
            entry_price,
            (tick.ask if direction == "LONG" else tick.bid) if tick else entry_price,
            sl_price,
            tp_price,
            si=si,
            tick=tick,
        )

    # BUY->ask, SELL->bid, digits’e göre yuvarla; guard.price varsa kullan
    request = fix_order_price(
        request,
        guard=guard,
        tick=tick,
    )

    # Broker'ın destekleyebileceği modları sırayla dene
    fillings = [
        getattr(mt5, "ORDER _FILLING_RETURN", 2),
        getattr(mt5, "ORDER_FILLING_IOC", 1),
        getattr(mt5, "ORDER_FILLING_FOK", 3),
    ]
    base_req = dict(request)

    last_result = None

    for f in fillings:
        req = dict(base_req)
        req["type_filling"] = f
        result = RAW_ORDER_SEND(req)
    if result and getattr(result, "retcode", -1) == mt5.TRADE_RETCODE_DONE:
        debug_log(f"✅ DEAL OK ticket={result.order} filling={f}")
        return result
    else:
        debug_log(f"❌ DEAL FAIL retcode={getattr(result,'retcode',None)} filling={f}")


LAST_TRADE_TIME = now_tr()

LOG_FILE = "trades_log.csv"


def log_trade(time_str, order_type, entry, volume, sl, tp, lot, rr, ticket):
    file_exists = os.path.isfile(LOG_FILE)

    with open(LOG_FILE, mode="a", newline="") as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(
                ["Time", "Type", "Entry", "volume", "SL", "TP", "Lot", "R:R", "Ticket"]
            )
        writer.writerow([time_str, order_type, entry, volume, sl, tp, lot, rr, ticket])


def log_close_trade(
    time_str, order_type, entry, volume, sl, tp, lot, rr, ticket, close_price, profit
):
    file_exists = os.path.isfile(LOG_FILE)

    with open(LOG_FILE, mode="a", newline="") as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(
                [
                    "Time",
                    "Type",
                    "Volume" "Entry",
                    "SL",
                    "TP",
                    "Lot",
                    "R:R",
                    "Ticket",
                    "ClosePrice",
                    "Profit",
                ]
            )
        writer.writerow(
            [
                time_str,
                order_type,
                entry,
                volume,
                sl,
                tp,
                lot,
                rr,
                ticket,
                close_price,
                profit,
            ]
        )


# --- Kapanışları tarayıp 'HEDEFTE'yi tek kez gönder ----------------
def check_closed_positions():
    global LAST_CLOSED_CHECK, LAST_LOGGED_DEALS

    # Alan adı farkları için küçük yardımcı
    def deal_field(d, *names):
        for n in names:
            if hasattr(d, n):
                return getattr(d, n)
            if hasattr(d, "_asdict"):
                a = d._asdict()
                if n in a:
                    return a[n]
        return None

    # Zaman aralığı: son kontrolden bu ana (ilk turda 1 saat geriye bak)
    t1 = (
        datetime.fromtimestamp(LAST_CLOSED_CHECK, tz=ZoneInfo("Europe/Istanbul"))
        if isinstance(LAST_CLOSED_CHECK, (int, float)) and LAST_CLOSED_CHECK > 0
        else now_tr()(ZoneInfo("Europe/Istanbul")) - timedelta(hours=1)
    )
    t2 = now_tr()(ZoneInfo("Europe/Istanbul"))
    try:
        history = mt5.history_deals_get(t1, t2) or []
    except Exception:
        history = []

    if not history:
        LAST_CLOSED_CHECK = t2.timestamp()
        return

    for deal in history:
        try:
            # 1) sadece kapanışlar
            entry = deal_field(deal, "entry", "Entry")
            if entry != mt5.DEAL_ENTRY_OUT:
                continue

            # 2) duplicate: aynı ticket’i iki kez işleme
            ticket = deal_field(deal, "ticket", "Ticket")
            if ticket in LAST_LOGGED_DEALS:
                continue
            LAST_LOGGED_DEALS.add(ticket)

            # 3) sadece TP kapanışları
            reason = str(
                deal_field(deal, "reason", "deal_reason", "Reason") or ""
            ).lower()
            comment = str(deal_field(deal, "comment", "Comment") or "").lower()
            if (
                mt5.DEAL_REASON_TP not in [deal_field(deal, "reason", "Reason"), None]
                and "tp" not in comment
            ):
                continue

            # 4) alanlar
            close_time = datetime.fromtimestamp(deal_field(deal, "time", "Time"))
            close_price = deal_field(deal, "price", "Price")
            profit = deal_field(deal, "profit", "Profit")
            side = (
                "LONG"
                if deal_field(deal, "type", "Type") == mt5.ORDER_TYPE_BUY
                else "SHORT"
            )
            pos_id = int(
                deal_field(deal, "position_id", "position", "PositionID") or ticket
            )

            # Telegram: HEDEFTE
            try:
                tgt_pips = globals().get("target_pips") or globals().get("PIPS")
                if tgt_pips is None:
                    tgt_pips = 0

                # mesajı fonksiyona yolla
                send_target_message(side, tgt_pips, close_time, close_price, profit)

                # terminal log
                debug_log(
                    f"[TARGET] 🎯XAUUSD {side} {tgt_pips} PİP HEDEFTE | "
                    f"KAPANIŞ:{close_price:.2f} 💰Kâr:{profit:.2f} USD"
                )

            except Exception as e:
                debug_log(f"[TARGET SEND EXC] {e}")

            # kısa log
            debug_log(
                f"[OK] POZİSYON KAPANDI | Ticket:{ticket} Pos:{pos_id} 💰Kâr:{profit:.2f} USD"
            )

        except Exception:
            continue

    LAST_CLOSED_CHECK = t2.timestamp()


# -------------------------------------------------------------------
def update_trailing_stop(
    symbol, ticket, order_type, entry_price, sl_price, direction, trailing_distance=200
):
    # Mevcut pozisyonu çek
    position = mt5.positions_get(ticket=ticket)
    if not position:
        return False  # pozisyon yok

    price = (
        mt5.symbol_info_tick(symbol).bid
        if direction == "BUY"
        else mt5.symbol_info_tick(symbol).ask
    )
    profit_distance = (
        (price - entry_price) if direction == "BUY" else (entry_price - price)
    )

    # trailing stop devreye girecek mi?
    if profit_distance > trailing_distance * PIP_VALUE:
        # yeni SL: fiyat - trailing_distance
        new_sl = (
            price - trailing_distance * PIP_VALUE
            if direction == "BUY"
            else price + trailing_distance * PIP_VALUE
        )

        # sadece ileriye taşırız (asla geri almayız)
        if (direction == "BUY" and new_sl > sl_price) or (
            direction == "SELL" and new_sl < sl_price
        ):
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": float(os.getenv("LOT_SIZE", "0.1")),
                "type": order_type,
                "entry": float(entry_price),
                "sl": float(sl_price),
                "tp": float(tp_price),
                "deviation": 20,
                "magic": 123456,
                "comment": "Gold Bot",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }

        result = RAW_ORDER_SEND(request)
        if result is None:
            debug_log(f"❌ Trailing Stop: order_send None → {mt5.last_error()}")
            return False
        if result.retcode == mt5.TRADE_RETCODE_DONE:
            debug_log(f"✅ Trailing Stop güncellendi → Yeni SL: {new_sl}")
            return True
        else:
            debug_log(f"❌ Trailing Stop güncellenemedi: {result.retcode}")
            return False


def move_sl_to_entry(symbol, ticket, order_type, entry_price, tp_price, direction):
    try:
        current_price = (
            mt5.symbol_info_tick(symbol).bid
            if direction == "BUY"
            else mt5.symbol_info_tick(symbol).ask
        )

        # %70 hedef seviyesi
        hedef_seviye = (
            entry_price + (tp_price - entry_price) * 0.7
            if direction == "BUY"
            else entry_price - (entry_price - tp_price) * 0.7
        )

        if (direction == "BUY" and current_price >= hedef_seviye) or (
            direction == "SELL" and current_price <= hedef_seviye
        ):

            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": float(os.getenv("LOT_SIZE", "0.1")),
                "type": order_type,
                "entry": float(entry_price),
                "sl": float(sl_price),
                "tp": float(tp_price),
                "deviation": 20,
                "magic": 123456,
                "comment": "Gold Bot",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }
            ok_sess, sess_reason = session_gate(symbol)
            if not ok_sess:
                debug_log(f"[SESSION][MODIFY] blocked: {sess_reason}")
                return False
            result = RAW_ORDER_SEND(request)
            if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                debug_log(f"🔒 SL entry price’a taşındı! Ticket: {ticket}")
                debug_log(
                    f"🔒[INFO] {symbol}SL entry price’a taşındı (Ticket {ticket})"
                )
                return True
    except Exception as e:
        debug_log(f"move_sl_to_entry hata: {e}")
    return False


def manage_open_positions(
    symbol: str, trailing_distance: int = TRAILING_DISTANCE, throttle_sec: int = 5
):
    """
    Açık pozisyonları periyodik kontrol eder:
      - Trailing Stop'u günceller (5 sn throttle)
      - Fiyat TP'nin %70'ine gelmişse SL'yi entry'e taşır
    """
    try:
        positions = mt5.positions_get(symbol=symbol)
        if not positions:
            return

        now_ts = time.time()

        for pos in positions:
            ticket = pos.ticket
            direction = "BUY" if pos.type == mt5.ORDER_TYPE_BUY else "SELL"
            entry = float(pos.price_open)
            sl = float(pos.sl) if pos.sl else entry  # yoksa entry baz al
            tp = float(pos.tp) if pos.tp else None

            # 1) Trailing Stop (throttle: 5 sn)
            last = LAST_TRAIL_CHECK.get(ticket, 0.0)
            if now_ts - last >= throttle_sec:
                try:
                    update_trailing_stop(
                        SYMBOL,
                        ticket,
                        entry,
                        sl,
                        direction,
                        trailing_distance=trailing_distance,
                    )
                except Exception as e:
                    debug_log(f"Trailing hata (ticket {ticket}): {e}")
                LAST_TRAIL_CHECK[ticket] = now_ts

            # 2) SL'yi girişe taşı (TP tanımlıysa)
            if tp is not None:
                try:
                    move_sl_to_entry(SYMBOL, ticket, entry, tp, direction)
                except Exception as e:
                    debug_log(f"BE hata (ticket {ticket}): {e}")

    except Exception as e:
        debug_log(f"manage_open_positions genel hata: {e}")


def maybe_check_closed_positions(throttle_sec: int = 10):
    """
    check_closed_positions()'ı en fazla 'throttle_sec' saniyede bir çalıştır.
    """
    pass_msg = None
    global LAST_CLOSED_CHECK
    now = time.time()
    if now - LAST_CLOSED_CHECK >= throttle_sec:
        try:
            check_closed_positions()
        except Exception as e:
            debug_log(f"check_closed_positions hatası: {e}")
        LAST_CLOSED_CHECK = now


def check_all_timeframes(mode="order"):

    sl_price = 0.0
    tp_price = 0.0
    sl_source = 0.0

    reasons = []
    tfs = ["M5", "M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]
    # Safe symbol resolution for downstream calls
    try:
        symbol = os.getenv("FORCE_SYMBOL") or globals().get("SYMBOL") or "GOLD"
    except Exception:
        symbol = "GOLD"

    info = {}

    request = None  # safe default to avoid UnboundLocalError
    volume = float(os.getenv("LOT", "0.10"))  # default to avoid UnboundLocalError

    # --- local RR text helper (safe) ---
    def _rr_text():
        _v = locals().get("rr_ratio")
        try:
            if _v is None:
                return "-"
            _v = float(_v)
            if not (_v == _v) or _v == float("inf") or _v == float("-inf"):
                return "-"
            return f"{_v:.2f}"
        except Exception:
            return "-"

    if str(os.getenv("FAST_TEST", "0")).strip() in ("1", "true", "on", "yes"):
        tfs = ["M5"]
    pending_msg = ""
    global last_signal_minute
    total_long = 0
    total_short = 0
    results = []  # tüm timeframe sonuçları
    msg: str = ""
    if mode == "signal":
        current_minute = now_tr()(ZoneInfo("Europe/Istanbul")).strftime(
            "%Y-%m-%d %H:%M"
        )
        last_signal_minute = current_minute

    # 🔹 1) Tüm TF'leri tara
    for tf, func in timeframes_to_check.items():
        try:
            latest = func(SYMBOL)
            if latest is None:
                debug_log(f"{tf} | DATA ALINAMADI (NONE)")
                continue

            aktif = [k for k, v in latest.items() if v]
            formasyon = latest.get("formasyon", "-")

            long_sinyal = any(sig in bullish_keys for sig in aktif)
            short_sinyal = any(sig in bearish_keys for sig in aktif)

            if long_sinyal and not short_sinyal:
                direction_local = "LONG"
                total_long += 1
            elif short_sinyal and not long_sinyal:
                direction_local = "SHORT"
                total_short += 1
            else:
                direction_local = "NONE"

            # teyit sayıları
            tf_df = get_ohlc(SYMBOL, TIMEFRAMES.get(tf, mt5.TIMEFRAME_H1), 300)
            teyit_long, teyit_short, _ = (
                all_confirmations(tf_df)
                if tf_df is not None and not tf_df.empty
                else (0, 0, {})
            )

            results.append(
                {
                    "timeframe": tf,
                    "direction": direction_local,
                    "formasyon": formasyon,
                    "teyit_long": teyit_long,
                    "teyit_short": teyit_short,
                }
            )

        except Exception as e:
            debug_log(f"{tf} HATASI: {e}")

    # 🔹 2) Genel yön
    if total_long > total_short:
        direction = "LONG"
    elif total_short > total_long:
        direction = "SHORT"
    else:
        direction = "NONE"

    if direction == "NONE":
        return None

    # 🔹 3) En güçlü sinyali seç (teyit sayısına göre)
    best_signal = None
    best_score = -1
    for r in results:
        if r["direction"] == direction:
            teyit = r["teyit_long"] if direction == "LONG" else r["teyit_short"]
            if teyit > best_score:
                best_score = teyit
                best_signal = r

    if not best_signal:
        debug_log("❌ Uygun sinyal bulunamadı")
        return None

    formasyon = best_signal["formasyon"]
    tf_used = best_signal["timeframe"]

    debug_log(
        f"📊 GENEL PUANLAMA: LONG={total_long}, SHORT={total_short}, YÖN={direction}, SEÇİLEN={tf_used} (TEYİT={best_score})"
    )

    dir_val = str(direction).upper() if direction else "-"
    if dir_val not in ("LONG", "SHORT"):
        dir_val = "-"

    res = {
        "direction": dir_val,  # LONG / SHORT / -
        "formasyon": formasyon or "-",  # seçilen formasyon
        "symbol": (
            os.getenv("FORCE_SYMBOL")  # GOLD vs. .env'den
            or globals().get("SYMBOL")
            or "GOLD"
        ),
        "timeframe": tf_used,  # bilgi amaçlı
    }
    # 🔹 4) OHLC datası (H1 baz alınır)
    tf_df = get_ohlc(SYMBOL, mt5.TIMEFRAME_H1, 500)
    if tf_df is None or tf_df.empty:
        debug_log("H1 OHLC DATASI ALINAMADI")
        return None

    teyit_sayisi_long, teyit_sayisi_short, levels = all_confirmations(tf_df)
    last_close = float(tf_df["close"].iloc[-1])
    target_pips = choose_target_pips(tf_used, mode=TP_MODE.lower())

    th = get_confirm_threshold(tf_used)  # tf_used zaten best_signal’dan geliyor
    debug_log(f"[{tf_used}] teyit_eşiği = {th}")  # (opsiyonel)

    now = get_server_time().strftime("%d-%m-%Y %H:%M:%S")
    atr_values = calculate_atr(tf_df, period=14)
    atr = (
        float(atr_values.iloc[-1])
        if atr_values is not None and not atr_values.empty
        else 0
    )

    # --- LONG ---
    if direction == "LONG":
        if teyit_sayisi_long < th:
            return None

            # default'lar (her durumda tanımlı olsun)
        warn_tag = ""
        why = None
        spread_pts = 0.0
        rr_ratio = 0.0
        entry_price = None
        tp_price = None
        sl_price = None
        sl_source = ""

        entry_price = last_close
        tp_price = entry_price + target_pips * PIP_VALUE
        sl_price, sl_source = choose_stop_loss(tf_df, "LONG", levels)

        if isinstance(sl_price, pd.Series):
            sl_price = float(sl_price.iloc[-1])
        else:
            sl_price = float(sl_price)

        if sl_price >= entry_price:
            sl_price = entry_price - (atr * 1)
            sl_source = "ATR-FALLBACK"

        # --- SPREAD FİLTRESİ ---
        allow, why, spread_pts, ratio = spread_gate(SYMBOL, entry_price, sl_price)
        if not allow:
            # istersen not düş
            res["spread_note"] = why
            return None

        # Uyarı metni (OK/NO-SPREAD-DATA ise boş)
        warn_tag = (
            ""
            if why in ("OK", "NO-SPREAD-DATA", None)
            else f"\nWARN:{why} (spread={spread_pts:.0f}pt, ratio={ratio:.2f})"
        )

        min_rr = float(os.getenv("MIN_RR", "0"))
        tol = float(os.getenv("RR_TOL", "1e-9"))  # .env’de opsiyonel

        if rr_ratio + tol < min_rr:
            debug_log(
                f"❌ {('LONG' if entry_price > sl_price else 'SHORT')} için RR {_rr_text()} < {min_rr:.6f} → İptal"
            )
            return None

        if not check_tp_bucket(tf_used, entry_price, tp_price):
            hedef_pip = abs(tp_price - entry_price) / PIP_VALUE
            debug_log(
                f"[DEBUG] TP KOVASI REDDEDİLDİ → hedef_pip={hedef_pip:.1f}, entry={entry_price}, tp={tp_price}"
            )
            return None

        lot = calculate_lot(entry_price, sl_price, risk_percent=0.02)
        if lot <= 0:
            debug_log(
                f"[DEBUG] LOT REDDEDİLDİ → hesaplanan lot={lot}, entry={entry_price}, sl={sl_price}, tp={tp_price}"
            )
            return None

        warn_tag = (
            ""
            if why in ("OK", "NO-SPREAD-DATA")
            else f" [SPREAD:{spread_pts:.0f}pt {ratio:.2f}]"
        )

        if reasons:
            # ❌ DROP → sadece terminal
            print(f"[DROP] [{tf_used}] direction -> {', '.join(reasons)}")
        else:
            # ✅ PASS → terminal + telegram
            print(f"[PASS] [{tf_used}] direction -> tüm kapılar OK")
            send_telegram_message
            place_order(symbol, direction, lot, entry_price, sl_price, tp_price)

        msg = (
            f"🟩🚨XAUUSD LONG GİR HEDEF {target_pips} PİP  ({tf_used}) | "
            f"ZAMAN: {now_tr()} ({formasyon}) | "
            f"ENTRY: {entry_price:.2f} | "
            f"TP: {tp_price:.2f} | "
            f"SL: {sl_price:.2f} ({sl_source}) | "
            f"RR: {rr_ratio:.2f} | "
        )
        send_telegram_message(msg)
        place_order(
            symbol="GOLD",
            order_type=direction,
            lot=LOT_SIZE,
            entry_price=entry_price,
            sl_price=sl_price,
            tp_price=tp_price,
        )

        try:
            info["request"] = request  # (may be None; safe)
        except Exception:
            pass

        # --- RCA: GATE ÖNCESİ (sinyal niye SKIP/PASS?) ---
        tf_used = str(
            (res or {}).get("timeframe") or tf
        )  # tf değişkenin varsa onu da kullanabilirsin
        res["spread_why"] = (
            why  # spread kararını RCA'ya geçir (why değişkeni sende var)
        )

        # --- AUTO FILL: SL/TP eksikse seviyelerden doldur ---
        try:
            # her şeyi res sözlüğünden oku; yoksa güvenli fallback
            dir_side = (res.get("side") or res.get("direction") or "LONG").upper()
            entry_px = float(res.get("entry_price", res.get("entry", 0.0)) or 0.0)

            sl_val = res.get("sl_price")
            tp_val = res.get("tp_price")
            sl_in = None if (sl_val in (None, 0)) else float(sl_val)
            tp_in = None if (tp_val in (None, 0)) else float(tp_val)

            lvls = res.get("levels")
            atr_p = res.get("atr_pips")

            if (sl_in is None) or (tp_in is None):
                g = compute_sl_tp_guard(
                    symbol=symbol,
                    direction=dir_side,
                    entry=entry_price,
                    sl=sl_in,
                    tp=tp_in,
                    si=None,
                    tick=None,  # scope'ta yoksa None sorun değil
                    levels=lvls,
                    atr_pips=atr_p,
                )
                res["sl_price"] = g["sl_price"]
                res["tp_price"] = g["tp_price"]
                # varsa local değişkenleri de güncelle
                sl_price = res["sl_price"]
                tp_price = res["tp_price"]
        except Exception as _e:
            print("[RCA] WARN auto-fill(check_all_timeframes):", _e)
        # --- /AUTO FILL ---

        print(f"[RCA][{tf_used}] -- pre-gate --")
        rca_order(
            symbol, res, tf=tf_used
        )  # request YOK -> gate sebeplerini döker (confirm/spread/min pip vs.)

        tf_used = str((res or {}).get("timeframe") or tf)
        why_val = locals().get("why", os.getenv("SPREAD_MODE", "OFF"))

        res["spread_why"] = why_val  # elindeki spread kararı (OK / RATIO / POINTS vs.)

        # --- AUTO FILL: SL/TP eksikse seviyelerden doldur ---
        try:
            # eldeki alanları toparla
            dir_side = (res.get("side") or res.get("direction") or "LONG").upper()
            entry_px = float(entry_price)
            sl_in = None if (sl_price in (None, 0)) else float(sl_price)
            tp_in = None if (tp_price in (None, 0)) else float(tp_price)
            lvls = res.get("levels")  # H1 teyitlerinden gelen seviye sözlüğü
            atr_p = res.get("atr_pips")  # varsa ATR pips
            si_local = si if "si" in locals() else None
            tick_local = tick if "tick" in locals() else None

            # AUTO FILL: SL/TP eksikse guard ile doldur
            if not sl_in or not tp_in:
                g = compute_sl_tp_guard(
                    symbol=symbol,
                    direction=dir_side,
                    entry=entry_px,
                    sl=sl_in,
                    tp=tp_in,
                    si=None,
                    tick=None,
                    levels=lvls,
                    atr_pips=atr_p,
                )
                sl_in = g.get("sl_price") or sl_in
                tp_in = g.get("tp_price") or tp_in
                # res içine de yaz
                res["sl_price"] = sl_in
                res["tp_price"] = tp_in
                sl_price = res["sl_price"]
                tp_price = res["tp_price"]
        except Exception as _e:
            print("[RCA] WARN auto-fill(check_all_timeframes):", _e)
        # --- /AUTO FILL ---

        print(f"[RCA][{tf_used}] -- pre-gate --")
        rca_order(symbol, res, tf=tf_used)  # request yok; gate sebeplerini döker

        # --- PRE-GATE DIST CHECK ---
        try:
            _vd = _validate_positive_distances(res, entry_price, sl_price, tp_price)
            # _validate_* bazen tuple, bazen dict, bazen bool dönebiliyor: esnek parse
            if isinstance(_vd, (list, tuple)):
                _ok_dist = bool(_vd[0])
                _why = _vd[1] if len(_vd) > 1 else ""
            elif isinstance(_vd, dict):
                _ok_dist = bool(_vd.get("ok", False))
                _why = _vd.get("why", "")
            else:
                _ok_dist = bool(_vd)
                _why = ""
        except Exception as e:
            # Asla çökmesin; RCA'ya sebebi yaz ama akışı sürdür
            _ok_dist = True
            _why = f"dist_guard_exc:{e}"

        if not _ok_dist:
            try:
                res.setdefault("why", []).append(_why)
            except Exception:
                pass

                # --- AUTO FILL: SL/TP eksikse seviyeden doldur; yine yoksa hard fallback ---
        try:
            side = (res.get("side") or res.get("direction") or "LONG").upper()
            entry_px = float(
                res.get("entry_price", res.get("entry", res.get("price", 0.0))) or 0.0
            )

            sl_val = res.get("sl_price")
            tp_val = res.get("tp_price")
            sl_in = None if (sl_val in (None, 0)) else float(sl_val)
            tp_in = None if (tp_val in (None, 0)) else float(tp_val)

            if (sl_in is None) or (tp_in is None):
                g = compute_sl_tp_guard(
                    symbol=symbol,
                    direction=side,
                    entry=entry_px,
                    sl=sl_in,
                    tp=tp_in,
                    si=None,
                    tick=None,
                    levels=res.get("levels"),
                    atr_pips=res.get("atr_pips"),
                )
                sl_in, tp_in = g["sl_price"], g["tp_price"]

            # son çare: 1 pip hard fallback (asla 0/None kalmasın)
            if (sl_in in (None, 0)) or (tp_in in (None, 0)):

                pip_div = float(os.getenv("POINTS_PER_PIP", "1") or 1.0)
                point = 0.01
                pip = point * pip_div
                if side == "LONG":
                    sl_in = sl_in or (entry_px - 1 * pip)
                    tp_in = tp_in or (entry_px + 1 * pip)
                else:
                    sl_in = sl_in or (entry_px + 1 * pip)
                    tp_in = tp_in or (entry_px - 1 * pip)

            res["sl_price"] = float(sl_in)
            res["tp_price"] = float(tp_in)
            sl_price = res["sl_price"]
            tp_price = res["tp_price"]
        except Exception as e:
            print("[RCA] WARN auto-fill(final):", e)
            # --- /AUTO FILL ---
            print(f"[RCA][{tf_used}] DROP: {_why}")
            return None

        # --- /PRE-GATE DIST CHECK ---

        # --- REAL SIGNAL GATE ---
        # Circuit breaker (optional)

        _block, _why_cb = (False, "ok")

        if _block:
            reasons.append(_why_cb)

        reasons = []
        need = get_confirm_threshold(tf_used)
        got = sum(
            1
            for k, v in (res.items() if isinstance(res, dict) else [])
            if isinstance(v, bool) and v
        )
        if got < need:
            reasons.append(f"confirm {got}/{need}")
        try:
            if not allow:
                reasons.append(f"spread:{why}")
        except Exception:
            pass

        try:
            min_rr = 0.10
            if rr_ratio is None or rr_ratio < min_rr:
                reasons.append(
                    f"rr:{(0.0 if rr_ratio is None else rr_ratio):.2f}<{min_rr}"
                )
        except Exception:
            reasons.append("rr_err")

        try:
            if not check_tp_bucket(tf_used, entry_price, tp_price):
                reasons.append("tp_bucket")
        except Exception:
            reasons.append("tp_bucket_err")

        if (lot is None) or (lot <= 0):
            reasons.append(f"lot:{lot}")

        tf_used = res.get("timeframe", tf)

        # özet -> sadece terminal
        try:
            summary = build_signal_msg(tf_used, res)
            debug_log(summary)
        except Exception as e:
            debug_log(f"[{tf_used}] build_signal_msg err: {e}")

        # --- İSTEĞE BAĞLI: her turda teşhis bas (dry-run) ---
        if os.getenv("DIAG_ALWAYS", "0") == "1":
            diagnose_and_maybe_order(
                tf_used, res, send=False
            )  # order denemez, sadece nedenleri basar
        else:
            send_flag = mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1
            diagnose_and_maybe_order(tf_used, res, send=send_flag)

        #  aşağıda istersen info'yu kullanarak konsola kısa özet basabilirsin
        if not (isinstance(info, dict) and info.get("ok")):
            print(
                f"[DIAG][{tf_used}] SKIP -> "
                + " , ".join((res or {}).get("reasons", []))
            )
        else:
            req = info.get("request", {}) or {}
            debug_log(
                f"[DIAG][{tf_used}] OK (send={send_flag}) price={req.get('price')} sl={req.get('sl')} tp={req.get('tp')}"
            )

    # ---- PASS sonrası: seçilen TF teşhis ----
    entry_price = float(res.get("entry_price", 0.0))

    try:
        msg_text = build_signal_msg(tf_used, res) or ""
    except Exception as e:
        debug_log(f"[{tf_used}] build_signal_msg err: {e}")
        msg_text = ""

        debug_log(msg_text or f"[{tf_used}] boş sinyal metni üretildi)")

    # (suppressed) build_signal_msg is internal; do not send
    send_flag = mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1
    diagnose_and_maybe_order(tf_used, res, send=send_flag)

    # Konsola okunur özet
    ok_flag = info.get("ok") if isinstance(info, dict) else True

    _reasons = info.get("reasons", []) if isinstance(info, dict) else []
    print(f"[DIAG][{tf_used}] SKIP -> " + ", ".join(_reasons))

    print(f"[DIAG][{tf_used}] OK (send={send_flag})")
    req = (res or {}).get("request", {})
    debug_log(
        f"[DIAG][{tf_used}] price={req.get('price')} sl={req.get('sl')} tp={req.get('tp')}"
    )

    symbol = (
        res.get("symbol") or os.getenv("GOLD_SYMBOL") or os.getenv("SYMBOL") or "GOLD"
    )

    # Sembol seç ve tick al
    if not mt5.symbol_select(symbol, True):
        debug_log(f"[ORDER?] SKIP: symbol not tradable -> {symbol}")
        return

    entry = float(res.get("entry_price") or 0.0)
    sl = float(res.get("sl_price") or 0.0)
    tp = float(res.get("tp_price") or 0.0)

    if entry == 0.0 or sl == 0.0 or tp == 0.0:
        debug_log(f"[ORDER?] SKIP: sl/tp missing -> sl={sl} tp={tp}")
        return

    si = mt5.symbol_info(symbol)
    point = si.point or 0.01
    digits = si.digits or 2

    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        debug_log(f"[ORDER?] SKIP: no tick -> {symbol}")
        return

    dir_val = str(res.get("direction", "")).upper()
    side = mt5.ORDER_TYPE_SELL if dir_val == "SHORT" else mt5.ORDER_TYPE_BUY
    price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask

    # 5) min stop / freeze + ENV guard
    si = mt5.symbol_info(symbol)
    point = si.point or 0.01
    digits = si.digits or 2
    min_stop = si.trade_stops_level * point

    # küçük tampon: 1 point
    buf = point

    # SL/TP boş kalmasın (ATR veya hard 1 pip fallback + min_stop ekle)
    if not sl_price or sl_price == 0:
        sl_price = entry - atr * 1 if direction == "LONG" else entry + atr * 1
        # broker tamponu ekle
        if direction == "LONG":
            sl_price = min(sl_price, entry - min_stop)
        else:
            sl_price = max(sl_price, entry + min_stop)
        sl_source = "ATR-FALLBACK"

    if not tp_price or tp_price == 0:
        tp_price = entry + atr * 2 if direction == "LONG" else entry - atr * 2
        # broker tamponu ekle
        if direction == "LONG":
            tp_price = max(tp_price, entry + min_stop)
        else:
            tp_price = min(tp_price, entry - min_stop)

    # broker basamaklarına yuvarla
    sl_price = round(sl_price, digits)
    tp_price = round(tp_price, digits)

    debug_log(
        f"[ORDER GUARD] price={price:.{digits}f} sl={sl_price:.{digits}f} tp={tp_price:.{digits}f}"
    )

    # 6) BURADAN SONRASI senin mevcut kodun:
    deviation = int(os.getenv("FORCE_DEVIATION", "50"))
    magic = int(os.getenv("MAGIC", "20250918"))

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": float(os.getenv("LOT_SIZE", "0.1")),
        "type": side,
        "entry": float(entry_price),
        "sl": float(sl_price),
        "tp": float(tp_price),
        "deviation": 20,
        "magic": 123456,
        "comment": "Gold Bot",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }
    result = RAW_ORDER_SEND(request)
    # print(f"[ORDER] retcode={getattr(result,'retcode',None)} comment={getattr(result,'comment','')}")
    try:
        info["request"] = request  # (may be None; safe)
    except Exception:
        pass

    # --- RCA: ORDER_CHECK ÖNCESİ (erken teşhis & erken kesme) ---
    tf_used = str((res or {}).get("timeframe") or "?")  # garanti olsun
    rca = rca_order(symbol, res, tf=tf_used, request=request)
    if rca.get("block"):
        info["reasons"] = info.get("reasons", []) + rca["reasons"]
        print(f"[RCA][{tf_used}] DROP before order_check")
        # (return avoided to continue summary)
    # Emir gönder (mode=trade ve SEND_ORDERS=1 ise)
    if mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1:

        symbol = (
            res.get("symbol")
            or os.getenv("GOLD_SYMBOL")
            or os.getenv("SYMBOL")
            or "GOLD"
        )
        dir_val = str(res.get("direction", "")).upper()
        side = mt5.ORDER_TYPE_SELL if dir_val == "SHORT" else mt5.ORDER_TYPE_BUY

        tick = mt5.symbol_info_tick(symbol)
        if not tick:
            debug_log(f"[EVAL][ORDER] tick yok ({symbol})")
        else:
            price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask

            rp = float(os.getenv("RISK_PERCENT", "0"))
            if rp > 0:
                try:
                    volume = calc_volume_by_risk(symbol, entry_price, sl_price, rp)
                except Exception:
                    volume = float(os.getenv("LOT", "0.10"))
            else:
                volume = float(os.getenv("LOT", "0.10"))

            deviation = int(os.getenv("FORCE_DEVIATION", "50"))
            magic = int(os.getenv("MAGIC", "20250918"))

            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": float(os.getenv("LOT_SIZE", "0.1")),
                "type": side,
                "entry": float(entry_price),
                "sl": float(sl_price),
                "tp": float(tp_price),
                "deviation": 20,
                "magic": 123456,
                "comment": "Gold Bot",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }

            debug_log(
                f"[EVAL][ORDER] sending {symbol} {dir_val} vol={volume} price={price}"
            )
            request = fix_order_price(
                request, guard=res.get("guard") or res.get("sl_tp_guard")
            )
            result = RAW_ORDER_SEND(request)
            rc_send = int(getattr(result, "retcode", -1))
            debug_log(f"[ORDER][{tf_used}] retcode={rc_send}")
            OKS = (0, 1, getattr(mt5, "TRADE_RETCODE_DONE", 10009))
            if rc_send not in OKS:
                debug_log(f"[ORDER][{tf_used}] retcode={rc_send} -> RCA:")
                rca_order(symbol, res, tf=tf_used, request=request)
            reasons.append(f"order_send_retcode={rc_send}")
            # (return avoided to continue summary)
    # --- SHORT ---
    elif direction == "SHORT":
        if teyit_sayisi_short < th:
            return None

            # default'lar (her durumda tanımlı olsun)
        warn_tag = ""
        why = None
        spread_pts = 0.0
        rr_ratio = 0.0
        entry_price = None
        tp_price = None
        sl_price = None
        sl_source = ""

        entry_price = last_close
        tp_price = entry_price - target_pips * PIP_VALUE
        sl_price, sl_source = choose_stop_loss(tf_df, "SHORT", levels)

        if isinstance(sl_price, pd.Series):
            sl_price = float(sl_price.iloc[-1])
        else:
            sl_price = float(sl_price)

        # --- SPREAD FİLTRESİ ---
        allow, why, spread_pts, ratio = spread_gate(SYMBOL, entry_price, sl_price)
        if not allow:
            debug_log(
                f"[SPREAD] BLOCK → mode={SPREAD_MODE} spread_pts={spread_pts:.1f} ratio={ratio:.2f} ({why})"
            )
            return None

        risk = abs(entry_price - sl_price)
        reward = abs(entry_price - tp_price)
        if risk <= 0:
            return None
        rr_ratio = reward / risk

        # Uyarı etiketi (opsiyonel)
        warn_tag = (
            ""
            if why in ("OK", "NO-SPREAD-DATA", None)
            else f"\nWARN:SPREAD:{why} (spread={spread_pts:.0f}pt, ratio={ratio:.2f})"
        )

        min_rr = float(os.getenv("MIN_RR", "0"))
        tol = float(os.getenv("RR_TOL", "1e-9"))  # .env’de opsiyonel

        if rr_ratio + tol < min_rr:
            debug_log(
                f"❌ {('LONG' if entry_price > sl_price else 'SHORT')} için RR {_rr_text()} < {min_rr:.6f} → İptal"
            )
            return None

        if not check_tp_bucket(tf_used, entry_price, tp_price):
            hedef_pip = round(abs(tp_price - entry_price) / PIP_VALUE, 1)
            debug_log(
                f"[DEBUG] TP KOVASI REDDEDİLDİ → hedef_pip={hedef_pip:.1f}, entry={entry_price}, tp={tp_price}"
            )
            return None

        lot = calculate_lot(entry_price, sl_price, risk_percent=0.02)
        if lot <= 0:
            debug_log(
                f"[DEBUG] LOT REDDEDİLDİ → hesaplanan lot={lot}, entry={entry_price}, sl={sl_price}, tp={tp_price}"
            )
            return None

        msg = (
            f"🟥🚨XAUUSD SHORT GİR HEDEF {target_pips} PİP ({tf_used}) | "
            f"ZAMAN: {now_tr()} ({formasyon}) | "
            f"ENTRY: {entry_price:.2f} | "
            f"TP: {tp_price:.2f} | "
            f"SL: {sl_price:.2f} ({sl_source}) | "
            f"RR: {rr_ratio:.2f} | "
        )
        send_telegram_message(msg)
        place_order(
            symbol="GOLD",
            order_type=direction,
            lot=LOT_SIZE,
            entry_price=entry_price,
            sl_price=sl_price,
            tp_price=tp_price,
        )

        # --- PRE-GATE DIST CHECK ---
        # --- PRE-GATE DIST CHECK (RR-ONLY: mesafe guard'ları kapalı) ---

        _ok_dist, _why = True, "ok"
        # --- REAL SIGNAL GATE ---
        # Circuit breaker (optional)

        _block, _why_cb = (False, "ok")

        if _block:
            reasons.append(_why_cb)

        reasons = []
        need = get_confirm_threshold(tf_used)
        got = sum(
            1
            for k, v in (res.items() if isinstance(res, dict) else [])
            if isinstance(v, bool) and v
        )
        if got < need:
            reasons.append(f"confirm {got}/{need}")
        try:
            if not allow:
                reasons.append(f"spread:{why}")
        except Exception:
            try:
                min_rr = 0.10
                if rr_ratio is None or rr_ratio < min_rr:
                    reasons.append(
                        f"rr:{(0.0 if rr_ratio is None else rr_ratio):.2f}<{min_rr}"
                    )
            except Exception:
                reasons.append("rr_err")

            if not check_tp_bucket(tf_used, entry_price, tp_price):
                reasons.append("tp_bucket")
        except Exception:
            reasons.append("tp_bucket_err")

        if (lot is None) or (lot <= 0):
            reasons.append(f"lot:{lot}")
        # varsa duplicate kontrolünü de burada ekleyebilirsin
        # if is_duplicate_msg(tf_used, res): reasons.append("duplicate")

        # --- PASS: yalnızca burada Telegram'a gönder ---
        # send_signal_message(tf_used, msg)

        # (Emir açma kısmı opsiyonel; SEND_ORDERS vb. ile anahtarlarsın)

        # ensure SHORT branch triggers diagnose/order
        info = diagnose_and_maybe_order(
            tf_used,
            res,
            send=(mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1),
        )


def run_bot():
    while True:

        try:

            if not ensure_mt5_alive():

                time.sleep(1.0)

                continue

            time.sleep(float(os.getenv("MIN_LOOP_SLEEP_MS", "500")) / 1000.0)

        except Exception as _loop_err:

            debug_log(f"[LOOP] hata: {_loop_err}")
            time.sleep(1.0)
        now = get_server_time().strftime()
        minute = now.minute
        hour = now.hour
        second = now.second

        # --- M15 ---
        if minute % 15 == 14 and second == 0:
            check_all_timeframes(mode="scan")  # sadece tarama
        if minute % 15 == 0 and second == 0:
            check_all_timeframes(mode="signal")  # sinyal

        # --- M30 ---
        if minute % 30 == 29 and second == 0:
            check_all_timeframes(mode="scan")
        if minute % 30 == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- M45 (15+30 birleşim) ---
        if minute == 44 and second == 0:
            check_all_timeframes(mode="scan")
        if minute == 45 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H1 ---
        if minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H2 ---
        if hour % 2 == 1 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 2 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H3 ---
        if hour % 3 == 2 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 3 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H4 ---
        if hour % 4 == 3 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 4 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H12 ---
        if hour % 12 == 11 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 12 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        time.sleep(1)


def paper_demo(direction="SHORT", sl_pips=35, tp_pips=60):
    symbol = os.getenv("GOLD_SYMBOL") or os.getenv("SYMBOL") or "GOLD"
    si = mt5.symbol_info(symbol)
    if not si:
        debug_log("[PAPER] symbol_info yok")
        return
    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        debug_log("[PAPER] tick yok")
        return
    point = si.point or 0.01
    digits = si.digits or 2
    price = tick.bid if direction == "SHORT" else tick.ask

    # entry = anlık fiyat, SL/TP pips ile
    if direction == "SHORT":
        sl = price + sl_pips * point
        tp = price - tp_pips * point
    else:
        sl = price - sl_pips * point
        tp = price + tp_pips * point

    res = {
        "timeframe": "TEST",
        "direction": direction,
        "symbol": symbol,
        "entry_price": round(price, digits),
        "sl_price": round(sl, digits),
        "tp_price": round(tp, digits),
    }
    diagnose_and_maybe_order("TEST", res, send=True)


def session_gate(symbol: str, mode: str | None = None):
    try:
        cfg = (mode or os.getenv("SESSION_LOCK_MODE") or "HARD").upper()
    except Exception:
        cfg = "HARD"
    if cfg == "OFF":
        return True, None
    if cfg == "AUTO":
        cfg = "HARD"
    si = None
    try:
        si = mt5.symbol_info(symbol)
    except Exception:
        pass
    allow = True
    reason = None
    try:
        tm = int(getattr(si, "trade_mode", 2) or 2) if si else 2
        if tm != 2:
            allow = False
            reason = f"SESSION:MODE:{tm}"
    except Exception:
        pass
    try:
        hard_w = os.getenv("SESSION_HARD_WINDOWS", "")
        if _in_time_windows(now_tr()(ZoneInfo("Europe/Istanbul")), hard_w):
            allow = False
            reason = reason or "SESSION:WINDOW"
    except Exception:
        pass
    if cfg == "SOFT":
        return True, (reason or None)
    return allow, (reason or None)


if __name__ == "__main__":
    run_master_diagnostic()
    # .env vs.
    SYMBOL = os.getenv("SYMBOL", "GOLD")
    # MT5 sadece BİR KERE burada initialize edilsin
    ok = mt5.initialize(login=MT5_LOGIN, password=MT5_PASSWORD, server=MT5_SERVER)
    if not ok:
        debug_log("❌ MT5 initialize başarısız:", mt5.last_error())
    else:
        debug_log("✅ MT5 bağlantısı başarılı")
    symbol = resolve_gold_symbol()
    if not symbol:
        debug_log(
            "[BOOT] GOLD/XAU sembolü bulunamadı. Market Watch'ta görünür yapın.",
            force=True,
        )
        raise SystemExit("Symbol not found")

    # global/ENV senkronize et ki tüm fonksiyonlar aynı sembolü kullansın
    globals()["SYMBOL"] = symbol
    os.environ["SYMBOL"] = symbol

    # garanti: seçili olsun
    try:
        mt5.symbol_select(symbol, True)
    except Exception:
        pass

    debug_log(f"[BOOT] SYMBOL = {symbol}", force=True)

    if DEBUG:
        try:
            sanity_startup_check(SYMBOL)
        except Exception as e:
            debug_log("[CHECK] sanitary_startup_check ERROR:", e)

paper_demo("SHORT", sl_pips=35, tp_pips=60)
paper_demo("LONG", 35, 60)
send_boot_once()
# --- PIP/POINT sanity check ---
info = mt5.symbol_info(SYMBOL)
if not info:
    debug_log("[WARN] symbol_info alınamadı:", SYMBOL)
else:
    point = float(info.point or 0.0)
    try:
        ratio = (PIP_VALUE / point) if point > 0 else 0
    except Exception:
        ratio = 0
    ok = abs(round(ratio) - ratio) < 1e-6 and ratio > 0
    if not ok:
        debug_log(
            f"[WARN] PIP_VALUE({PIP_VALUE}) point({point}) ile uyumlu değil! "
            f"ratio={ratio:.6f} (pip kaç point?)"
        )
    else:
        POINTS_PER_PIP = int(round(ratio))
        debug_log(f"[OK] PIP/POINT: 1 pip = {POINTS_PER_PIP} point (point={point})")


try:
    rows = get_ohlc(SYMBOL, timeframe=mt5.TIMEFRAME_M15, bars=20)[
        ["time", "open", "high", "low", "close", "spread"]
    ]
    if rows is not None:
        debug_log("=" * 108 + " OHLC LAST 20 (once) " + "=" * 108)
        debug_log(f"{'time':<20} {'open':>22} {'high':>22} {'low':>22} {'close':>22}")
        for _, r in rows.iterrows():
            t = (
                pd.to_datetime(r["time"])
                .tz_localize("UTC")
                .astimezone(ZoneInfo("Europe/Istanbul"))
                .strftime("%Y-%m-%d %H:%M")
            )
            debug_log(
                f"{t:<20} {r['open']:>22f} {r['high']:>22f} {r['low']:>22f} {r['close']:>22f}"
            )
except Exception as e:
    debug_log(f"OHLC preview error: {e}")

run_boot(SYMBOL, sleep_sec=5)


def ensure_mt5_alive() -> bool:
    """Basit MT5 sağlık kontrolü ve yeniden başlatma."""
    try:
        ok = mt5.initialize()
    except Exception:
        ok = False
    if not ok:
        try:
            login = int(os.getenv("MT5_LOGIN", "0") or 0)
            password = os.getenv("MT5_PASSWORD") or ""
            server = os.getenv("MT5_SERVER") or ""
            if login and password and server:
                mt5.shutdown()
                if mt5.initialize():
                    mt5.login(login, password=password, server=server)
                    return True
                return False
            return mt5.initialize()
        except Exception:
            return False
    return True


# --- Session Lock Helpers ---
def _parse_time_hhmm(tstr: str):
    try:
        hh, mm = tstr.strip().split(":")
        return int(hh), int(mm)
    except Exception:
        return None


def _in_time_windows(now_dt, windows_str: str) -> bool:
    try:
        if not windows_str:
            return False
        hm = now_dt.hour * 60 + now_dt.minute
        for win in windows_str.split(","):
            win = win.strip()
            if not win or "-" not in win:
                continue
            a, b = win.split("-")
            pa = _parse_time_hhmm(a)
            pb = _parse_time_hhmm(b)
            if not pa or not pb:
                continue
            sa = pa[0] * 60 + pa[1]
            sb = pb[0] * 60 + pb[1]
            if sa <= sb:
                if sa <= hm <= sb:
                    return True
            else:
                if hm >= sa or hm <= sb:
                    return True
        return False
    except Exception:
        return False


# ===== Minimal Stability Helpers (Contract / RCA / Circuit Breaker) =====

# Global counters (lightweight; can be extended by order/closure hooks)
_TRADES_TODAY_BY_TF = {}
_CONSEC_LOSSES = 0
_DAILY_PNL_USD = 0.0


def _env_int(key, default):
    try:
        return int(os.getenv(key, str(default)))
    except Exception:
        return default


def _env_float(key, default):
    try:
        return float(os.getenv(key, str(default)))
    except Exception:
        return default


def normalize_signal(res: dict) -> dict:
    """Field normalization to stabilize downstream usage."""
    try:
        res = dict(res or {})
        # direction
        d = str(res.get("direction", "-")).upper()
        res["direction"] = d if d in ("LONG", "SHORT", "-") else "-"
        # symbol
        res["symbol"] = (
            res.get("symbol")
            or os.getenv("FORCE_SYMBOL")
            or globals().get("SYMBOL")
            or "GOLD"
        )
        # timeframe
        res["timeframe"] = res.get("timeframe") or "-"
        # formasyon
        res["formasyon"] = res.get("formasyon") or res.get("formation") or "-"
        # prices
        if "sl" in res and "sl_price" not in res:
            res["sl_price"] = res.get("sl")
        if "tp" in res and "tp_price" not in res:
            res["tp_price"] = res.get("tp")
        # rr
        if "rr" not in res and "RR" in res:
            res["rr"] = res.get("RR")
        # spread_why
        res["spread_why"] = res.get("spread_why") or "OK"
        return res
    except Exception:
        return res or {}


def assert_contract(res: dict) -> bool:
    """Fail-fast checks for mandatory fields. Returns True if ok."""
    try:
        keys = ["symbol", "timeframe", "direction", "formasyon"]
        for k in keys:
            if not str(res.get(k, "")).strip():
                debug_log(f"[CONTRACT] missing field: {k}")
                return False
        # Price coherence if present
        entry = res.get("entry") or res.get("entry_price")
        sl = res.get("sl_price")
        tp = res.get("tp_price")
        if entry and sl and tp:
            try:
                entry, sl, tp = float(entry), float(sl), float(tp)
                if not (abs(entry - sl) > 0 and abs(tp - entry) > 0):
                    debug_log("[CONTRACT] non-positive distances entry/sl/tp")
                    return False
            except Exception:
                pass
        return True
    except Exception as e:
        debug_log(f"[CONTRACT] exception: {e}")
        return False


def rca_line(tf: str, status: str, reasons: list, regime: str = "-", rr=None):
    """One-line structured RCA for observability."""
    try:
        rr_txt = (
            "-"
            if rr is None
            else (f"{rr:.2f}" if isinstance(rr, (int, float)) else str(rr))
        )
        line = f"RCA tf={tf} status={status} reasons={list(reasons or [])} regime={regime} rr={rr_txt}"
        debug_log(line, force=True)
    except Exception as e:
        debug_log(f"[RCA-LINE ERR] {e}")


def _validate_positive_distances(
    res: dict, entry_price, sl_price, tp_price
) -> tuple[bool, str]:
    """Return (ok, reason). Ensures SL/TP distances are positive."""
    try:
        if entry_price is None or sl_price is None or tp_price is None:
            return False, "dist_missing"
        e = float(entry_price)
        s = float(sl_price)
        t = float(tp_price)
        if not (abs(e - s) > 0 and abs(t - e) > 0):
            return False, "dist_nonpositive"
        return True, "ok"
    except Exception as exc:
        return False, f"dist_exc:{exc}"


try:
    _orig_spread_gate = spread_gate

    def spread_gate(*a, **k):
        allow, why, pts, ratio, mode = _orig_spread_gate(*a, **k)
        mode_u = str(mode or os.getenv("SPREAD_MODE", "OFF")).upper()
        if mode_u != "HARD":
            allow = True
        return allow, why, pts, ratio, mode_u

except NameError:
    pass
