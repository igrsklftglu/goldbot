import os
import sys
import time
import math
import csv
import re
import logging
import random
import traceback
import warnings
from dataclasses import dataclass, field
from typing import Optional
from datetime import datetime, timedelta
from datetime import datetime, timezone
from datetime import time as _dt_time
from zoneinfo import ZoneInfo
import types
import requests
import pandas as pd
import numpy as np
import MetaTrader5 as mt5
from dotenv import load_dotenv
import schedule
import time as _time
import sys, shutil, time as _time
import os, time as _time, requests
import os, time, requests
from os import getenv
from types import SimpleNamespace
from MetaTrader5 import symbol_info_tick
from datetime import datetime
import inspect
import builtins


def run_master_diagnostic():
    results = []

    # === 1. MT5 baƒülantƒ±sƒ± ===
    try:
        if mt5.initialize():
            acc = mt5.account_info()
            if acc:
                results.append("[OK] MT5 baƒülantƒ±sƒ± saƒülandƒ±")
            else:
                results.append("[FAIL] MT5 account_info alƒ±namadƒ±")
        else:
            results.append("[FAIL] MT5 initialize ba≈üarƒ±sƒ±z")
    except Exception as e:
        results.append(f"[FAIL] MT5 initialize exception -> {e}")

    # === 2. ATR Testi ===
    try:
        df = get_ohlc("GOLD", mt5.TIMEFRAME_H1, 100)
        atr = calculate_atr(df)
        if atr is not None and not atr.empty:
            results.append("[OK] ATR hesaplama √ßalƒ±≈üƒ±yor")
        else:
            results.append("[FAIL] ATR hesaplama bo≈ü d√∂nd√º")
    except Exception as e:
        results.append(f"[FAIL] ATR exception -> {e}")

    # === 3. Stop Loss / Take Profit Guard ===
    try:
        si = mt5.symbol_info("GOLD")
        tick = mt5.symbol_info_tick("GOLD")
        guard = compute_sl_tp_guard(
            symbol="GOLD",
            direction="LONG",
            entry=tick.ask,  
            sl=None, 
            tp=None, 
            si=si, 
            tick=tick
        )
        if guard:
            results.append("[OK] SL/TP Guard √ßalƒ±≈üƒ±yor")
        else:
            results.append("[FAIL] SL/TP Guard bo≈ü d√∂nd√º")
    except Exception as e:
        results.append(f"[FAIL] SL/TP Guard exception -> {e}")

    try:
        entry = 3880.0  # test i√ßin sahte deƒüer
        tp = 3890.0
        symbol = "GOLD"
        ok = check_tp_bucket("M15", entry, tp, symbol)
        if ok:
            print("[OK] TP kovasƒ± √ßalƒ±≈üƒ±yor")
        else:
            print("[FAIL] TP kovasƒ± hata: False d√∂nd√º")
    except Exception as e:
        print(f"[FAIL] TP kovasƒ± exception -> {e}")

    # === 4. RR (Risk/Reward) Sistemi ===
    try:
        entry = 1900.0
        sl = 1890.0
        tp = 1920.0
        rr = (tp - entry) / (entry - sl) if (entry - sl) != 0 else None
        if rr and rr > 0:
            results.append(f"[OK] RR hesaplama √ßalƒ±≈üƒ±yor (RR={rr:.2f})")
        else:
            results.append("[FAIL] RR hesaplama sƒ±fƒ±r/negatif")
    except Exception as e:
        results.append(f"[FAIL] RR hesaplama exception -> {e}")

    # === 5. TP Kovalarƒ± ===
    try:
        tf = "M15"
        entry = 1900.0
        tp = 1910.0
        if check_tp_bucket(tf, entry, tp):
            results.append("[OK] TP kovasƒ± ge√ßerli")
        else:
            results.append("[FAIL] TP kovasƒ± ge√ßersiz")
    except Exception as e:
        results.append(f"[FAIL] TP kovasƒ± exception -> {e}")

    # === 6. Formasyonlar ===
    formasyonlar = [
        "hammer",
        "engulfing",
        "double_top",
        "double_bottom",
        "head_shoulders",
        "inverse_head_shoulders",
        "triangle",
        "flag",
        "wedge",
        "doji",
    ]
    for f in formasyonlar:
        try:
            func = globals().get(f"detect_{f}")
            if func:
                results.append(f"[OK] Formasyon: {f}")
            else:
                results.append(f"[FAIL] Formasyon fonksiyonu eksik: {f}")
        except Exception as e:
            results.append(f"[FAIL] Formasyon {f} exception -> {e}")

    # === 7. Konfirmasyon B√∂lgeleri ===
    teyit_bolgeleri = [
        "support_resistance",
        "supply_demand",
        "trendline_break",
        "fibonacci_levels",
        "moving_average_cross",
    ]
    for t in teyit_bolgeleri:
        try:
            func = globals().get(f"check_{t}")
            if func:
                results.append(f"[OK] Teyit b√∂lgesi: {t}")
            else:
                results.append(f"[FAIL] Teyit fonksiyonu eksik: {t}")
        except Exception as e:
            results.append(f"[FAIL] Teyit {t} exception -> {e}")

    # === 8. Timeframe Kontrol ===
    timeframes = [
        ("M15", check_signals_m15),
        ("M30", check_signals_m30),
        ("M45", check_signals_m45),
        ("H1", check_signals_h1),
        ("H2", check_signals_h2),
        ("H3", check_signals_h3),
        ("H4", check_signals_h4),
        ("H12", check_signals_h12),
    ]
    for name, func in timeframes:
        try:
            func("GOLD")
            results.append(f"[OK] Timeframe: {name}")
        except Exception as e:
            results.append(f"[FAIL] Timeframe: {name} -> {e}")

    # === 9. Risk Hesaplama ===
    try:
        lot = calculate_lot(1900.0, 1890.0, 0.02)
        if lot > 0:
            results.append(f"[OK] Risk/Lot hesaplama √ßalƒ±≈üƒ±yor (lot={lot})")
        else:
            results.append("[FAIL] Risk/Lot hesaplama sƒ±fƒ±r")
    except Exception as e:
        results.append(f"[FAIL] Risk hesaplama exception -> {e}")

    # === 10. Spread Gate ===
    try:
        allow, why, pts, ratio = spread_gate("GOLD", 1900.0, 1890.0)
        if allow:
            results.append("[OK] Spread gate √ßalƒ±≈üƒ±yor")
        else:
            results.append(f"[FAIL] Spread gate blocked: {why}")
    except Exception as e:
        results.append(f"[FAIL] Spread gate exception -> {e}")

    # === SONU√á ===
    print("\n=== MASTER DIAGNOSTIC SONU√á ===")
    for r in results:
        print(r)
    print("==============================\n")


def now_tr():
    """T√ºrkiye saati (Europe/Istanbul) d√∂ner"""
    return datetime.now(ZoneInfo("Europe/Istanbul"))


# ======= RESILIENT DISTANCE/Y√ñN GUARD (hotfix v2: pos+kw compatible) =======
# ===== RR-ONLY VALIDATOR (2-tuple, hi√ß bloklamaz) =====
def _validate_positive_distances(*_args, **_kwargs):
    """
    RR-ONLY mode: mesafe/side/broker/env kontrollerini KAPAT.
    Hep (True, "ok") d√∂nd√ºr√ºr ki √ßaƒüƒ±ran yer 2'li unpack ile √ßalƒ±≈üsƒ±n.
    """
    return True, "ok"


# ======================================================

# ==== Optional contract helpers: type hints + safe fallbacks ====
from typing import TYPE_CHECKING

if TYPE_CHECKING:

    def normalize_signal(res: dict) -> dict: ...
    def assert_contract(res: dict) -> bool: ...


try:
    normalize_signal  # type: ignore[name-defined]
except NameError:

    def normalize_signal(res: dict) -> dict:
        return res or {}


try:
    assert_contract  # type: ignore[name-defined]
except NameError:

    def assert_contract(res: dict) -> bool:
        return True


# ===============================================================

print("[BOOT] GOLD BOT FILE:", __file__)  # running file path

# ---- Defensive fallbacks to ensure runtime stability (hotfix) ----
try:
    normalize_signal
except NameError:  # pragma: no cover

    def normalize_signal(res: dict) -> dict:
        # No-op: return as-is so runtime never crashes if helpers are absent
        return res or {}


try:
    assert_contract
except NameError:  # pragma: no cover

    def assert_contract(res: dict) -> bool:
        # Fail-soft: skip strict contract validation; gates will still apply
        return True


# ---------------------------------------------------------------


# safety: eƒüer tanƒ±mlƒ± deƒüilse no-op s√ºr√ºm√º olu≈ütur
if "should_block_trade" not in globals():

    def should_block_trade(*_a, **_k):
        return False, "ok"


# === Early lightweight logger (safe) ===


warnings.simplefilter(action="ignore", category=FutureWarning)


LAST_LOGGED_DEALS = set()
last_signal_minute = None  # en son sinyal zamanƒ±
pending_signal = None
LAST_BAR_TIME = {}
LAST_MSG_SIG = {}
LAST_TRAIL_CHECK = {}
LAST_MGMT_RUN = 0
MODE_HB_NEXT = 0
LAST_CLOSED_CHECK = 0
STARTUP_SENT = False
LAST_TIME = {}
# removed duplicate MIN_TG_INTERVAL (using env-based definition)
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)
LAST_TG_SENT = {}
_last_trade_time = {}
LAST_STATUS_LINE = ""
LAST_STATUS_TIME = 0.0
STATUS_MIN_INTERVAL = 1.0
HANDLE_SIGNAL_LOCK = False
LAST_FORCE_TS = 0
DEBUG = int(os.getenv("DEBUG", "0")) == 1
load_dotenv()


SYMBOL = "GOLD"
LOT_SIZE = 0.10  # her i≈ülemde kullanƒ±lacak lot miktarƒ±
RISK_PERCENT = 0.02  # her i≈ülemde bakiyenin %2‚Äôsi risklenecek
PIP_VALUE = 0.01  # XAUUSD ‚Üí 1 pip = 0.01 USD
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")
MIN_TG_INTERVAL = int(os.getenv("TG_MIN_INTERVAL", "3"))  # sn
_LAST_TG_SENT = 0.0
_STARTUP_SENT = False
BOOT_STARTED_AT = now_tr()
BOOT_GRACE_SEC = int(os.getenv("BOOT_GRACE_SEC", "60"))
POINTS_PER_PIP = float(os.getenv("POINTS_PER_PIP", "1"))


# === Pip Kovalarƒ± ===
pip_buckets = {
    "M15": (100, 200),
    "M30": (200, 300),
    "M45": (300, 400),
    "H1": (400, 500),
    "H2": (500, 600),
    "H3": (600, 700),
    "H4": (700, 1000),
    "H12": (1000, float("inf")),
}


# --- Pip helpers (tek doƒüru kaynak) ---
def _pip_size(si) -> float:
    point = getattr(si, "point", 0.01) or 0.01
    div = float(os.getenv("POINTS_PER_PIP", "1") or 1.0)
    return point * div


def _abs_pips(a: float, b: float, si) -> float:
    return abs(float(b) - float(a)) / _pip_size(si)


def ensure_sltp_and_request(
    symbol, si, side_txt: str, tf: str, res: dict, request: dict = None
):
    print(f"[TRACE] ensure_sltp_and_request √áAƒûRILDI -> side={side_txt}, tf={tf}")

    min_stop = si.trade_stops_level * si.point
    try:
        tick = mt5.symbol_info_tick(symbol)
        if not tick:
            print("[TRACE] tick bilgisi alƒ±namadƒ±")
            return "block", 0.0, 0.0, {"reasons": ["no_tick"], "retcode": None}

        entry = tick.ask if side_txt.upper() == "LONG" else tick.bid
        print(f"[TRACE] entry fiyatƒ± belirlendi: {entry}")

        if res is None:
            res = {}
        sl = float(res.get("sl_price", 0.0))
        tp = float(res.get("tp_price", 0.0))
        print(f"[TRACE] ba≈üta sl={sl}, tp={tp}")

        # Burada RR fallback var
        rr_ratio = float(os.getenv("RR_RATIO", "2.0"))
        if sl > 0.0 and tp == 0.0:
            risk = abs(entry - sl)
            tp = entry + (
                risk * rr_ratio if side_txt.upper() == "LONG" else -risk * rr_ratio
            )
            print(f"[TRACE] RR fallback sonrasƒ± tp={tp}")

        # ATR fallback
        rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_H1, 0, 100)
        df = pd.DataFrame(rates)
        atr = calculate_atr(df, 14).iloc[-1]
        print(f"[TRACE] ATR={atr}")

        if sl == 0.0 or tp == 0.0:
            if atr and atr > 0:
                off = atr
                if side_txt.upper() == "LONG":
                    sl = entry - off
                    tp = entry + (off * rr_ratio)
                else:
                    sl = entry + off
                    tp = entry - (off * rr_ratio)
                print(f"[TRACE] ATR fallback sonrasƒ± sl={sl}, tp={tp}")
            else:
                return "block", 0.0, 0.0, {"reasons": ["no_sl_tp"], "retcode": None}

        print(f"[TRACE] SON KONTROL: entry={entry}, sl={sl}, tp={tp}")

        # Burada y√∂n hatasƒ±nƒ± test ediyoruz
        if side_txt.upper() == "LONG":
            if sl >= entry:
                print(f"[üö® HATA] LONG ama SL entry √ºst√ºnde -> entry={entry}, sl={sl}")
            if tp <= entry:
                print(f"[üö® HATA] LONG ama TP entry altƒ±nda -> entry={entry}, tp={tp}")

        elif side_txt.upper() == "SHORT":
            if sl <= entry:
                print(f"[üö® HATA] SHORT ama SL entry altƒ±nda -> entry={entry}, sl={sl}")
            if tp >= entry:
                print(f"[üö® HATA] SHORT ama TP entry √ºst√ºnde -> entry={entry}, tp={tp}")

        return entry, sl, tp, request

    except Exception as e:
        print(f"[TRACE] EXCEPTION: {e}")
        return "block", 0.0, 0.0, {"reasons": [f"ensure_exc:{e}"], "retcode": None}


def debug_log(*args, force=False, **kwargs):
    """Safe logger: only prints when DEBUG=1/true or force=True; never raises."""
    try:
        dbg_env = os.getenv("DEBUG", "")
        dbg_flag = False
        if isinstance(dbg_env, str):
            dbg_flag = dbg_env.strip().lower() in ("1", "true", "on", "yes")
        elif isinstance(dbg_env, (int, float)):
            dbg_flag = bool(dbg_env)
        try:
            dbg_flag = dbg_flag or bool(globals().get("DEBUG", 0))
        except Exception:
            pass
        if not (dbg_flag or force):
            return
        ts = now_tr()(ZoneInfo("Europe/Istanbul")).strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{ts}]", *map(str, args), **kwargs)
    except Exception:
        pass


def active_trade_count(symbol: str = None) -> int:
    """A√ßƒ±k pozisyon sayƒ±sƒ±nƒ± d√∂ner. Sembol verilirse sadece o sembol i√ßin sayar."""
    try:
        positions = mt5.positions_get()
        if not positions:
            return 0
        if symbol:
            return sum(1 for p in positions if p.symbol == symbol)
        return len(positions)
    except Exception:
        return 0


def _patch_logger_safe():
    """Logging % formatting hatalarƒ±nda √ß√∂kmesin; gerekirse metni birle≈ütirip bas."""
    _old_log = logging.Logger._log

    def _safe_log(self, level, msg, args, **kw):
        try:
            return _old_log(self, level, msg, args, **kw)
        except TypeError:
            # % yer tutucu yoksa arg√ºmanlarƒ± string olarak ekle
            try:
                if args:
                    msg = f"{msg} " + " ".join(str(a) for a in args)
                return _old_log(self, level, msg, (), **kw)
            except Exception:
                print("[LOGSAFE FAIL]", msg, args)

    logging.Logger._log = _safe_log


_patch_logger_safe()  # << erken √ßaƒüƒ±r


# --- GOLD/XAU sembol√º √ß√∂z√ºmleyici -------------------------------------------
def resolve_gold_symbol() -> str | None:

    env = os.getenv("SYMBOL", os.getenv("GOLD_SYMBOL", "")).strip()
    if env:
        try:
            if mt5.symbol_select(env, True):
                return env
        except Exception:
            pass
    candidates = [
        "GOLD",
        "GOLDmicro",
        "GOLD.xm",
        "GOLDm",
        "XAUUSD",
        "XAUUSD.a",
        "XAUUSD.m",
        "XAUUSDmicro",
        "XAUUSD.xm",
        "XAUUSDm",
    ]
    for s in candidates:
        si = mt5.symbol_info(s)
        if si and mt5.symbol_select(s, True):
            return s
    for pat in ("GOLD*", "XAU*"):
        for si in mt5.symbols_get(pat) or []:
            if mt5.symbol_select(si.name, True):
                return si.name
    return None


# ---------------------------------------------------------------------------

MT5_ORDER_SEND = mt5.order_send
MT5_ORDER_CHECK = mt5.order_check


def is_paper() -> bool:
    return os.getenv("PAPER", "0") == "1"


# --- G√ºvenli sarmalayƒ±cƒ±lar ---
def order_check_safe(request):
    if is_paper():
        # Broker'a dokunmadan "ba≈üarƒ±lƒ±" retcode d√∂nd√ºr
        return SimpleNamespace(retcode=0, comment="paper-check")
    return MT5_ORDER_CHECK(request)


def order_send_safe(request: dict, *, base_sleep: float = 0.3):
    """Emir g√∂nderimi i√ßin g√ºvenli kapƒ±:
    - PAPER modda sahte ba≈üarƒ± d√∂nd√ºr√ºr (broker'a gitmez)
    - ƒ∞steƒüi normalize eder
    - BUY->ask, SELL->bid d√ºzeltmesi yapar (fiyat yok/0 ise)
    - RETURN/IOC/FOK doldurma modlarƒ±nƒ± sƒ±rasƒ±yla dener
    """
    # 0) PAPER: hi√ß broker'a gitme
    if is_paper():
        debug_log(f"[PAPER] would send: {request}")
        return SimpleNamespace(retcode=0, comment="paper-send", order=0)

    # 1) normalize
    req = _sanitize_request_plus(request)

    # 2) fiyatƒ± garanti altƒ±na al (BUY->ask, SELL->bid)
    try:
        t = mt5.symbol_info_tick(req.get("symbol"))
        if t:
            if req.get("type") == mt5.ORDER_TYPE_BUY:
                if not req.get("price") or float(req["price"]) <= 0:
                    req["price"] = float(t.ask)
            elif req.get("type") == mt5.ORDER_TYPE_SELL:
                if not req.get("price") or float(req["price"]) <= 0:
                    req["price"] = float(t.bid)
    except Exception:
        pass

    # 3) broker‚Äôƒ±n destekleyebileceƒüi doldurma modlarƒ±nƒ± sƒ±rayla dene
    fillings = (
        getattr(mt5, "ORDER_FILLING_RETURN", 2),
        getattr(mt5, "ORDER_FILLING_IOC", 1),
        getattr(mt5, "ORDER_FILLING_FOK", 3),
    )
    last_result = None
    for f in fillings:
        req["type_filling"] = f
        result = MT5_ORDER_SEND(req)
        last_result = result
        if result and getattr(result, "retcode", -1) == getattr(
            mt5, "TRADE_RETCODE_DONE", 10009
        ):
            return result
        time.sleep(base_sleep)

    # Son denemenin sonucunu d√∂nd√ºr (ba≈üarƒ±sƒ±zsa da)
    return last_result


# --- Proje genelinde kullanƒ±lacak alias'lar ---
RAW_ORDER_CHECK = order_check_safe
RAW_ORDER_SEND = order_send_safe
debug_log("[BOOT] RAW_ORDER_SEND ->", RAW_ORDER_SEND.__name__)


res = locals().get("res", globals().get("res", {}))

try:
    res
except NameError:
    res = {}
print(res.get("entry_price"))


# ===================== SL/TP se√ßici (SEVƒ∞YE-BAZLI) =====================
def _pick_levels_sltp(
    levels: dict,
    direction: str,
    entry: float,
    *,
    point: float,
    pip_div: float,
    atr_pips: float | None,
):
    PRIOR = ["OB", "BRK", "FVG", "FTR", "SD", "MSB", "LQ"]
    side = (direction or "LONG").upper()
    pip = point * (pip_div or 1.0)

    def _nearest(prices, want_gt):
        try:
            ps = sorted(float(x) for x in (prices or []) if x is not None)
        except Exception:
            ps = []
        if want_gt:
            cand = [p for p in ps if p > entry]
            return cand[0] if cand else None
        cand = [p for p in ps if p < entry]
        return cand[-1] if cand else None

    # SL
    sl_price = None
    for k in PRIOR:
        lvl = (levels or {}).get(k) or []
        sl_price = _nearest(lvl, want_gt=(side == "SHORT"))
        if sl_price:
            break

    # TP
    tp_price = None
    for k in PRIOR:
        lvl = (levels or {}).get(k) or []
        tp_price = _nearest(lvl, want_gt=(side == "LONG"))
        if tp_price:
            break

    sl_pips = abs(entry - sl_price) / pip
    tp_pips = abs(tp_price - entry) / pip
    return float(sl_price), float(tp_price), int(round(sl_pips)), int(round(tp_pips))


# fallback tanƒ±mlar (None kalmasƒ±n)
entry_price = float(res.get("entry_price") or res.get("entry", 0.0) or 0.0)
sl_price = float(res.get("sl_price") or 0.0)
tp_price = float(res.get("tp_price") or 0.0)


def compute_sl_tp_guard(
    symbol: str,
    direction: str,
    entry: float,
    sl: float = None,
    tp: float = None,
    si = None,
    tick = None
) -> dict:
    """
    SL/TP deƒüerlerini g√ºvenli ≈üekilde hesaplar ve kontrol eder.
    
    Args:
        symbol (str): ƒ∞≈ülem sembol√º (√∂rn: "GOLD")
        direction (str): ƒ∞≈ülem y√∂n√º ("LONG" veya "SHORT")
        entry (float): Giri≈ü fiyatƒ±
        sl (float, optional): Stop Loss fiyatƒ±. Varsayƒ±lan None.
        tp (float, optional): Take Profit fiyatƒ±. Varsayƒ±lan None.
        si: Sembol bilgisi. Varsayƒ±lan None.
        tick: Anlƒ±k fiyat bilgisi. Varsayƒ±lan None.
    
    Returns:
        dict: SL/TP ve diƒüer bilgileri i√ßeren s√∂zl√ºk
    """
    try:
        # Timestamp i√ßin
        ts = now_tr().strftime("%Y-%m-%d %H:%M:%S")
        debug_log(f"[{ts}] üîÑ compute_sl_tp_guard ba≈üladƒ±: {direction} @ {entry}")

        # Sembol bilgilerini al
        if si is None:
            si = mt5.symbol_info(symbol)
        
        # Temel deƒüerleri ayarla
        digits = getattr(si, "digits", 2) if si else 2
        point = getattr(si, "point", 0.01) if si else 0.01
        pip_div = float(os.getenv("POINTS_PER_PIP", "1") or 1.0)
        pip = point * pip_div

        # ATR hesaplama
        try:
            rates = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_H1, 0, 100)
            df = pd.DataFrame(rates)
            atr = df['high'].rolling(14).max() - df['low'].rolling(14).min()
            atr = float(atr.iloc[-1])
            debug_log(f"[{ts}] üìè ATR: {atr}")
        except Exception as e:
            atr = pip * 10 # Varsayƒ±lan deƒüer
            debug_log(f"[{ts}] ‚ö†Ô∏è ATR hesaplanamadƒ±: {e}, varsayƒ±lan: {atr}")

        # Yuvarlama fonksiyonu
        def round_price(price):
            if price is None:
                return None
            return round(float(price), digits)

        side = direction.upper()
        debug_log(f"[{ts}] Y√∂n: {side}, Entry: {entry}")

        # LONG pozisyonlar i√ßin SL/TP ayarla
        if side == "LONG":
            if sl is None or sl >= entry:
                sl = entry - (atr * 1.5)
                debug_log(f"[{ts}] ‚ö†Ô∏è LONG SL d√ºzeltildi: {sl}")
            
            if tp is None or tp <= entry:
                tp = entry + (atr * 2.0)
                debug_log(f"[{ts}] ‚ö†Ô∏è LONG TP d√ºzeltildi: {tp}")

        # SHORT pozisyonlar i√ßin SL/TP ayarla
        elif side == "SHORT":
            if sl is None or sl <= entry:
                sl = entry + (atr * 1.5)
                debug_log(f"[{ts}] ‚ö†Ô∏è SHORT SL d√ºzeltildi: {sl}")
            
            if tp is None or tp >= entry:
                tp = entry - (atr * 2.0)
                debug_log(f"[{ts}] ‚ö†Ô∏è SHORT TP d√ºzeltildi: {tp}")

        # Risk/√ñd√ºl oranƒ±nƒ± hesapla
        risk = abs(entry - sl)
        reward = abs(tp - entry)
        rr = reward / risk if risk > 0 else 0
        debug_log(f"[{ts}] üìä Risk/√ñd√ºl oranƒ±: {rr:.2f}")

        # Son kontroller
        entry = round_price(entry)
        sl = round_price(sl)
        tp = round_price(tp)

        debug_log(f"[{ts}] ‚úÖ Son deƒüerler -> Entry: {entry}, SL: {sl}, TP: {tp}")

        return {
            "price": entry,
            "sl_price": sl,
            "tp_price": tp,
            "pip": pip,
            "point": point,
            "digits": digits,
            "atr": atr,
            "rr_ratio": rr
        }

    except Exception as e:
        debug_log(f"[{ts}] üö® compute_sl_tp_guard HATA: {str(e)}")
        # Hata durumunda g√ºvenli deƒüerler d√∂nd√ºr
        return {
            "price": entry if entry else 0.0,
            "sl_price": 0.0,
            "tp_price": 0.0,
            "pip": 0.01,
            "point": 0.01,
            "digits": 2,
            "atr": 0.0,
            "rr_ratio": 0.0
        }


# kabul edilen alanlar
_ALLOWED_REQ_KEYS = {
    "action",
    "position",
    "symbol",
    "volume",
    "type",
    "entry",
    "sl",
    "tp",
    "deviation",
    "magic",
    "comment",
    "type_time",
    "type_filling",
    "request_id",
}


# --- Hardened request sanitization & guards ---
def _get_symbol_meta(symbol):
    try:
        si = mt5.symbol_info(symbol)
        tick = mt5.symbol_info_tick(symbol)
        point = float(getattr(si, "point", 0.01) or 0.01) if si else 0.01
        digits = int(getattr(si, "digits", 2) or 2) if si else 2
        vol_min = float(getattr(si, "volume_min", 0.01) or 0.01) if si else 0.01
        vol_step = float(getattr(si, "volume_step", 0.01) or 0.01) if si else 0.01
        vol_max = float(getattr(si, "volume_max", 100.0) or 100.0) if si else 100.0
        return (si, tick, point, digits, vol_min, vol_step, vol_max)
    except Exception:
        return None, None, 0.01, 2, 0.01, 0.01, 100.0, 0, 0


def _round_to_step(x, step, minimum=None, maximum=None):
    try:
        if step <= 0:
            return x
        n = round((float(x) - (minimum or 0.0)) / step)
        val = (minimum or 0.0) + n * step
        if minimum is not None:
            val = max(val, minimum)
        if maximum is not None:
            val = min(val, maximum)
        return float(val)
    except Exception:
        return x


def _dir_from_type(t):
    # t may be int (mt5.ORDER_TYPE_*) or string
    try:
        if t == mt5.ORDER_TYPE_BUY:
            return "BUY"
        if t == mt5.ORDER_TYPE_SELL:
            return "SELL"
    except Exception:
        pass
    ts = str(t).upper()
    if "BUY" in ts:
        return "BUY"
    if "SELL" in ts:
        return "SELL"
    return "BUY"


def _sanitize_request(req: dict) -> dict:
    """Temel normalize: tip d√ºzelt, defaultlarƒ± ata."""
    base = dict(req or {})
    # sayƒ± alanlarƒ±
    for k in ("price", "sl", "tp", "volume"):
        if k in base and base[k] is not None:
            try:
                base[k] = float(base[k])
            except Exception:
                base[k] = 0.0
    # sapma & filling default
    if "deviation" in base:
        try:
            base["deviation"] = int(base["deviation"])
        except Exception:
            base["deviation"] = 20
    if "type_filling" not in base:
        # MT5 sabiti yoksa 2 (ORDER_FILLING_RETURN) varsay
        try:
            base["type_filling"] = getattr(mt5, "ORDER_FILLING_RETURN", 2)
        except Exception:
            base["type_filling"] = 2
    return base


def _sanitize_request_plus(req: dict) -> dict:
    """Geni≈ületilmi≈ü normalize: asla recurse etme; istenmeyen key'leri at."""
    # üîí kritik: burada _sanitize_request_plus(req) **DEƒûƒ∞L**, _sanitize_request(req) √ßaƒürƒ±lƒ±r
    try:
        base = _sanitize_request(req)
    except NameError:
        # √ßok nadir: _sanitize_request hen√ºz tanƒ±mlƒ± deƒüilse, g√ºvenli kopya
        base = dict(req) if isinstance(req, dict) else req

    # burada ekstra ‚Äútemizlikler‚Äù
    base.pop("retries", None)
    base.pop("raw", None)  # varsa log/artƒ±k veri
    base.pop("client", None)  # istemci nesnesini asla g√∂ndermeyelim

    # SL/TP float g√ºvencesi (idempotent)
    for k in ("sl", "tp"):
        if k in base and base[k] is not None:
            try:
                base[k] = float(base[k])
            except Exception:
                base[k] = None

    return base


def fix_order_price(req: dict, guard: dict | None = None, tick=None):
    """BUY i√ßin price=ask, SELL i√ßin price=bid olacak ≈üekilde emri normalize et.
    guard.price varsa onu, yoksa canlƒ± tick'i kullanƒ±r. digits'e g√∂re yuvarlar."""
    try:
        import MetaTrader5 as mt5
    except Exception:
        return req
    if not isinstance(req, dict):
        return req

    sym = req.get("symbol")
    si = mt5.symbol_info(sym) if sym else None
    digits = int(getattr(si, "digits", 2) or 2)

    if tick is None and sym:
        try:
            tick = mt5.symbol_info_tick(sym)
        except Exception:
            tick = None

    typ = req.get("type")

    def _roundf(x):
        try:
            return round(float(x), digits)
        except Exception:
            return req.get("price")

    if typ == getattr(mt5, "ORDER_TYPE_BUY", None):
        p = (guard or {}).get("price")
        if p is None and tick is not None:
            p = getattr(tick, "ask", None)
        if p is not None:
            req["price"] = _roundf(p)
    elif typ == getattr(mt5, "ORDER_TYPE_SELL", None):
        p = (guard or {}).get("price")
        if p is None and tick is not None:
            p = getattr(tick, "bid", None)
        if p is not None:
            req["price"] = _roundf(p)

    return req


def send_telegram_message(text: str) -> bool:
    """Telegram'a raw text g√∂nder. T√ºm g√∂nderimler buradan ge√ßsin."""
    global _LAST_TG_SENT
    if not TELEGRAM_TOKEN or not TELEGRAM_CHAT_ID:
        debug_log("[TG] token/chat id yok")
        return False
    now = time.time()
    if now - _LAST_TG_SENT < MIN_TG_INTERVAL:
        return False  # anti-spam
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": text}
        r = requests.post(url, json=payload, timeout=6)
        ok = r.ok and r.json().get("ok", False)
        if ok:
            _LAST_TG_SENT = now
            return True
        debug_log(f"[TG ERROR] status={r.status_code} resp={r.text[:200]}")
    except Exception as e:
        debug_log(f"[TG EXC] {e}")
    return False


def send_full_diagnostic():
    try:
        report = []
        report.append("üõ† GOLD BOT DIAGNOSTIC REPORT üõ†\n")

        # Telegram baƒülantƒ±sƒ±
        report.append(
            f"üì° Telegram: {'OK' if TELEGRAM_TOKEN and TELEGRAM_CHAT_ID else 'MISSING'}"
        )

        # Saat
        now_local = now_tr()(ZoneInfo("Europe/Istanbul")).strftime("%Y-%m-%d %H:%M:%S")
        report.append(f"‚è± Local Time (Istanbul): {now_local}")

        # Limits
        report.append(
            f"\n‚öñ Max Concurrent Trades: {os.getenv('MAX_CONCURRENT_TRADES','?')}"
        )
        report.append(f"‚è≥ Trade Cooldown: {os.getenv('TRADE_COOLDOWN_SEC','?')} sec")
        report.append(
            f"üîÅ Allow Multiple Positions: {os.getenv('ALLOW_MULTIPLE_POSITIONS','?')}"
        )

        # Risk / lot
        report.append(f"\nüí∞ Lot Size: {LOT_SIZE} | Risk: {RISK_PERCENT*100:.2f}%")
        report.append(f"üìä Points per Pip: {POINTS_PER_PIP} | Pip Value: {PIP_VALUE}")

        # Aktif trade‚Äôler
        trades = mt5.positions_get()
        report.append(f"\nüìÇ Active Trades: {len(trades)}")
        for t in trades or []:
            report.append(
                f" {t.symbol} {'BUY' if t.type==0 else 'SELL'} | "
                f"Entry:{t.price_open} | SL:{t.sl} | TP:{t.tp} | PnL:{t.profit:.2f} USD"
            )

        # TP kovalarƒ±
        report.append("\nüéØ TP Buckets:")
        for tf, rng in pip_buckets.items():
            report.append(f" {tf}: {rng}")

        # Son sinyal √∂rneƒüi (res dict varsa)
        if "res" in globals() and res:
            tf = res.get("timeframe")
            direction = res.get("direction")
            formasyon = res.get("formasyon")
            trues = res.get("trues", [])
            spread = res.get("spread_pts")
            atr = res.get("atr")
            rr = res.get("rr_ratio")
            passed = res.get("ok", False)

            report.append(f"\nüìë Son Sinyal ({tf}):")
            report.append(f" Y√∂n: {direction}")
            report.append(f" Formasyon: {formasyon}")
            report.append(f" Teyitler: {', '.join(trues)}")
            report.append(f" Spread: {spread}")
            report.append(f" ATR: {atr}")
            report.append(f" RR: {rr}")
            report.append(f" Durum: {'PASS ‚úÖ' if passed else 'DROP ‚ùå'}")

        # Mesajƒ± g√∂nder
        text = "\n".join(report)
        send_telegram_message(text)

    except Exception as e:
        debug_log(f"[DIAG ERROR] {e}")


def send_signal_message(tf: str, msg: str) -> bool:
    """Sadece LONG/SHORT giri≈ü sinyali. (tf √∂ne eklenmiyor.)"""
    if int(os.getenv("SEND_SIGNALS", "1")) != 1:
        return False
    text = str(msg)  # ba≈üƒ±na [tf] K O Y M A
    return send_telegram_message(text)


def send_target_message(
    side: str, target_pips, close_time, close_price: float, profit: float
) -> bool:
    """TP 'HEDEFTE' mesajƒ±."""
    if int(os.getenv("SEND_TARGETS", "1")) != 1:
        return False
    try:
        when = close_time.astimezone(ZoneInfo("Europe/Istanbul")).strftime(
            "%Y-%m-%d %H:%M:%S"
        )
    except Exception:
        when = now_tr()(ZoneInfo("Europe/Istanbul")).strftime("%Y-%m-%d %H:%M:%S")
    text = (
        f"üéØXAUUSD {side} {int(target_pips)} Pƒ∞P HEDEFTE | "
        f"ZAMAN: {now_tr()} | "
        f"KAPANI≈û: {close_price:.2f} üí∞K√¢r:{profit:.2f} USD"
    )
    return send_telegram_message(text)


def send_boot_once() -> None:
    """Bot ba≈ülatƒ±ldƒ± mesajƒ±nƒ± 1 kez at."""
    global _STARTUP_SENT
    if _STARTUP_SENT or int(os.getenv("SEND_STARTUP", "1")) != 1:
        return
    if send_telegram_message("üöÄ GOLDBot ba≈ülatƒ±ldƒ±!"):
        _STARTUP_SENT = True
    send_full_diagnostic()


def rca_order(symbol: str, res: dict, tf: str = "", request: dict | None = None):
    """
    Order/sinyal neden gitmiyor? -> k√∂k sebep raporu.
    SL/TP yanlƒ±≈ü veya sƒ±fƒ±r ise i≈ülemi bloklar.
    """

    try:
        si = mt5.symbol_info(symbol)
        if not si:
            print(f"[RCA][{tf}] DROP: symbol_info yok -> {symbol}")
            return {"block": True, "reasons": ["no_symbol_info"], "retcode": None}

        tick = mt5.symbol_info_tick(symbol)
        bid = getattr(tick, "bid", 0.0) or 0.0
        ask = getattr(tick, "ask", 0.0) or 0.0

        direction = str((res or {}).get("direction", "LONG")).upper()
        side_txt = direction
        if direction == "LONG":
            side = mt5.ORDER_TYPE_BUY
            entry = ask
        else:
            side = mt5.ORDER_TYPE_SELL
            entry = bid

        # -------------------------------
        # SL / TP deƒüerlerini al
        # -------------------------------
        sl = float((res or {}).get("sl_price") or 0.0)
        tp = float((res or {}).get("tp_price") or 0.0)

        # ‚ùå Eƒüer SL veya TP yoksa ‚Üí i≈ülemi blokla
        if sl == 0.0 or tp == 0.0:
            print(
                f"[RCA][{tf}] HATA: SL veya TP eksik! entry={entry}, sl={sl}, tp={tp}"
            )
            return {"block": True, "reasons": ["missing_sl_tp"], "retcode": None}

        # -------------------------------
        # LONG kontrol√º
        # -------------------------------
        if side_txt == "LONG":
            if sl >= entry:
                print(
                    f"[RCA][{tf}] HATA: LONG ama SL entry √ºzerinde! entry={entry}, sl={sl}"
                )
                return {"block": True, "reasons": ["invalid_sl_long"], "retcode": None}
            if tp <= entry:
                print(
                    f"[RCA][{tf}] HATA: LONG ama TP entry altƒ±nda! entry={entry}, tp={tp}"
                )
                return {"block": True, "reasons": ["invalid_tp_long"], "retcode": None}

        # -------------------------------
        # SHORT kontrol√º
        # -------------------------------
        if side_txt == "SHORT":
            if sl <= entry:
                print(
                    f"[RCA][{tf}] HATA: SHORT ama SL entry altƒ±nda! entry={entry}, sl={sl}"
                )
                return {"block": True, "reasons": ["invalid_sl_short"], "retcode": None}
            if tp >= entry:
                print(
                    f"[RCA][{tf}] HATA: SHORT ama TP entry √ºzerinde! entry={entry}, tp={tp}"
                )
                return {"block": True, "reasons": ["invalid_tp_short"], "retcode": None}

        # -------------------------------
        # Eƒüer buraya geldiyse SL/TP doƒüru
        # -------------------------------
        print(f"[RCA][{tf}] PASS ‚úÖ entry={entry}, sl={sl}, tp={tp}")
        return {
            "block": False,
            "reasons": [],
            "side": side_txt,
            "entry": entry,
            "sl": sl,
            "tp": tp,
        }

    except Exception as e:
        print(f"[RCA][{tf}] EXC: {e}")
        return {"block": True, "reasons": [f"rca_exc:{e}"], "retcode": None}


def _safe_float(x, d=0.0):
    try:
        return float(x)
    except Exception:
        return d


def compute_rr_ratio(entry, sl, tp, point):
    """
    RR = reward / risk (pip cinsinden).
    Giri≈üler string gelse bile float‚Äôa √ßevirir; point<=0 ise 0.01‚Äôe d√º≈üer.
    entry==sl veya entry==tp ise 0‚Äôa b√∂lme yerine rr=0 d√∂ner.
    """
    e = _safe_float(entry, 0.0)
    s = _safe_float(sl, 0.0)
    t = _safe_float(tp, 0.0)
    p = _safe_float(point, 0.01)
    if p <= 0:
        p = 0.01

    risk_pips = abs(e - s) / p if e != s else 0.0
    reward_pips = abs(t - e) / p if t != e else 0.0

    if risk_pips <= 0:
        return 0.0, risk_pips, reward_pips

    return (reward_pips / risk_pips), risk_pips, reward_pips


def diagnose_and_maybe_order(
    tf: str, res: dict, *, send: bool = False, mode: str | None = None
):

    reasons: list[str] = []  # init once, before any append
    # --- Contract normalization & validation (optional) ---
    try:
        if "normalize_signal" in globals() and callable(normalize_signal):
            res = normalize_signal(res)
        if "assert_contract" in globals() and callable(assert_contract):
            if not assert_contract(res):
                try:
                    reasons.append("contract_missing")
                except Exception:
                    reasons = ["contract_missing"]
                print(f"[RCA][{tf}] DROP: contract_missing")
                return {"status": "DROP", "reasons": reasons}
    except Exception as _exc:
        # Helpers missing or failing: do not DROP; let downstream gates decide
        print(f"[RCA][{tf}] WARN: contract_check_skipped:{_exc}")
    """
    Sinyali te≈ühis eder, kapƒ±lardan (confirm, spread, rr, broker guard) ge√ßirir,
    gerekiyorsa g√ºvenli emir isteƒüi hazƒ±rlar ve *opsiyonel* olarak g√∂nderir.

    Bu s√ºr√ºm, √∂nceki dosyada g√∂r√ºlen `UnboundLocalError: local variable 'j'` ve
    `dict object is not iterable` gibi hatalarƒ± gidermek i√ßin sade/saƒülam
    bir akƒ±≈ü uygular. Eski anahtarlar korunmu≈ütur: res['timeframe'],
    res['direction'], res['entry_price'], res['sl_price'], res['tp_price'], res['symbol'].
    """

    # --- SAFE CAST HELPERS (moved up to avoid _F UnboundLocalError) ---
    def _F(x, d=0.0):
        try:
            return float(x)
        except Exception:
            try:
                return float(str(x).replace(",", "."))
            except Exception:
                return d

    def _I(x, default=2):
        try:
            if x is None:
                return default
            if isinstance(x, int):
                return x
            if isinstance(x, float):
                return int(round(x))
            s = str(x).strip()
            return int(s) if s.lstrip("-").isdigit() else default
        except Exception:
            return default

    # ------------------------------------------------------------------

    try:
        import MetaTrader5 as mt5
    except Exception:  # test ortamƒ±

        class _MT5:
            pass

        mt5 = _MT5()
        mt5.ORDER_TYPE_BUY = 0
        mt5.ORDER_TYPE_SELL = 1
        mt5.TRADE_ACTION_DEAL = 1

        def _noop(*a, **k):
            return None

        mt5.symbol_info = _noop
        mt5.symbol_info_tick = _noop

    # ---- G√ºvenli getter'lar ----
    def _get_si(symbol):
        try:
            return mt5.symbol_info(symbol)
        except Exception:
            return None

    def _get_tick(symbol):
        try:
            return mt5.symbol_info_tick(symbol)
        except Exception:
            return None

    symbol = (
        (res or {}).get("symbol")
        or os.getenv("GOLD_SYMBOL")
        or os.getenv("SYMBOL")
        or "GOLD"
    )
    si = _get_si(symbol)
    point = float(getattr(si, "point", 0.01) or 0.01)
    digits = int(getattr(si, "digits", 2) or 2)

    direction = str((res or {}).get("direction", "")).upper()
    is_short = direction == "SHORT"
    is_long = direction == "LONG"

    entry_price = float(res.get("entry_price") or 0.0)
    sl_price = float(res.get("sl_price") or 0.0)
    tp_price = float(res.get("tp_price") or 0.0)

    # Spread kontrol√º sonu√ßlarƒ± √ºst akƒ±≈ütan gelebilir; yoksa varsayƒ±lan serbest
    allow_spread = True
    spread_reason = "OK"
    if isinstance(res, dict) and "spread_why" in res:
        spread_reason = res.get("spread_why") or "OK"
        allow_spread = spread_reason in ("OK", "OFF", None, "")

    # RR hesapla (varsa)
    rr_ratio = 0.0

    try:
        risk = abs(entry_price - sl_price)
        reward = abs(tp_price - entry_price)
        if risk > 0:
            rr_ratio = reward / risk
    except Exception as e:
        rr_ratio = 0.0

    # --- SL/TP GUARD --- (compute_sl_tp_guard dict d√∂nd√ºr√ºr)
    try:
        guard = compute_sl_tp_guard(
            symbol=symbol,
            direction=("SHORT" if is_short else "LONG" if is_long else direction),
            entry=entry_price,
            sl=sl_price,
            tp=tp_price,
            si=si,
            tick=_get_tick(symbol),
        )
        if isinstance(guard, dict):
            sl_price = float(guard.get("sl_price", sl_price) or sl_price)
            tp_price = float(guard.get("tp_price", tp_price) or tp_price)
            digits = int(guard.get("digits", digits) or digits)
            point = float(guard.get("point", point) or point)
    except Exception as e:
        debug_log(f"[GUARD ERR] {e}")

    # --- Min RR filtresi ---
    try:
        min_rr = float(os.getenv("MIN_RR", "1.6") or 1.6)
    except Exception:
        min_rr = 1.6
    rr_ok = (rr_ratio is None) or (rr_ratio >= min_rr)

    # --- Confirm filtresi (TF bazlƒ±) ---
    tf_used = str(res.get("timeframe") or tf or "?")

    # Yalnƒ±zca *sinyal a≈üamasƒ±nda* (mum kapanƒ±≈üƒ±) terminale detay bas:
    # res['phase'] == 'signal' ise veya PRINT_ON=1 ise yaz.
    _phase = str((res or {}).get("phase", "")).lower()
    _override = str(os.getenv("PRINT_ON", "0")).strip() in ("1", "true", "on", "yes")
    should_print = (_phase == "signal") or _override
    need_conf = get_confirm_threshold(tf_used)
    got_conf = 0
    try:
        got_conf = sum(1 for k, v in res.items() if isinstance(v, bool) and v)
    except Exception:
        got_conf = 0
    confirm_ok = got_conf >= need_conf

    # --- Final gate ---
    reasons = []
    if not allow_spread:
        reasons.append(f"spread:{spread_reason}")
    if not confirm_ok:
        reasons.append(f"confirm {got_conf}/{need_conf}")
    if not rr_ok:
        reasons.append(f"rr:{0.0 if rr_ratio is None else round(rr_ratio,2)}<{min_rr}")

    # RCA kaydƒ±
    try:
        rca_order(symbol, res, tf=tf_used)
    except Exception:
        pass

    # √ñzet metni (terminal i√ßi)
    try:
        summary = build_signal_msg(tf_used, res)
        debug_log(summary, force=True)
    except Exception as e:
        debug_log(f"[SUMMARY ERR] {e}")

    info = {
        "timeframe": tf_used,
        "allow": not reasons,
        "reasons": reasons,
        "entry_price": round(entry_price, digits),
        "sl_price": round(sl_price, digits),
        "tp_price": round(tp_price, digits),
        "rr": rr_ratio,
        "digits": digits,
        "point": point,
    }


def _extract_true_count(res) -> int | None:
    """Return TRUE count from res dict (flexible keys)."""
    if not isinstance(res, dict):
        return None
    for k in ("true_cols", "TRUE", "true_list", "true_count", "TRUE kolonlar", "true"):
        v = res.get(k)
        if isinstance(v, (list, tuple)):  # liste ise uzunluk
            return len(v)
        if isinstance(v, int):  # direkt sayƒ± verilmi≈üse
            return v
    return None


TF_ORDER = ["M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]  # ihtiyaca g√∂re d√ºzenle


def _status_line_str(by_tf: dict[str, dict]) -> str:
    parts = []
    for tf in TF_ORDER:
        need = get_confirm_threshold(tf)  # .env‚Äôden geliyor
        got = _extract_true_count(by_tf.get(tf, {}))
        parts.append(f"{tf}:{'-' if got is None else got}/{need}")
    return " | ".join(parts)


def _print_status_line(s: str):
    """Tek satƒ±rƒ± terminalde g√ºncelle (Windows uyumlu)."""
    cols = shutil.get_terminal_size((120, 20)).columns
    s = s[: max(10, cols - 1)]  # ta≈ümayƒ± engelle
    sys.stdout.write("\r" + s + " " * max(0, cols - len(s) - 1))
    sys.stdout.flush()


def deal_field(d, *names):
    """namedtuple/deal i√ßinden alanƒ± esnek al (reason/deal_reason/Reason vs.)."""
    for n in names:
        if hasattr(d, n):
            return getattr(d, n)
    if hasattr(d, "_asdict"):
        a = d._asdict()
        for n in names:
            if n in a:
                return a[n]
    return None


# === MT5 RETCODE a√ßƒ±klayƒ±cƒ± yardƒ±mcƒ±lar ============================


RETCODE_MAP = {
    getattr(mt5, "TRADE_RETCODE_DONE", 10009): "ƒ∞≈ûLEM TAMAM (DONE)",
    getattr(mt5, "TRADE_RETCODE_PLACED", 10008): "EMƒ∞R YERLE≈ûTƒ∞ (PLACED)",
    getattr(mt5, "TRADE_RETCODE_REQUOTE", 10004): "REQUOTE (fiyat deƒüi≈üti)",
    getattr(mt5, "TRADE_RETCODE_PRICE_CHANGED", 10032): "Fƒ∞YAT DEƒûƒ∞≈ûTƒ∞",
    getattr(mt5, "TRADE_RETCODE_OFFQUOTES", 10027): "OFFQUOTES (akƒ±≈ü yok)",
    getattr(mt5, "TRADE_RETCODE_MARKET_CLOSED", 10018): "Pƒ∞YASA KAPALI",
    getattr(mt5, "TRADE_RETCODE_NO_CONNECTION", 10006): "BAƒûLANTI YOK",
    getattr(mt5, "TRADE_RETCODE_INVALID_EXPIRATION", 10019): "GE√áERSƒ∞Z EXPIRATION",
    getattr(mt5, "TRADE_RETCODE_INVALID_PRICE", 10015): "GE√áERSƒ∞Z Fƒ∞YAT",
    getattr(mt5, "TRADE_RETCODE_TRADE_DISABLED", 10026): "SEMBOLDE TRADE KAPALI",
    getattr(mt5, "TRADE_RETCODE_NO_MONEY", 10031): "YETERSƒ∞Z BAKƒ∞YE",
}


def explain_retcode(code: int) -> str:
    return RETCODE_MAP.get(code, f"Bilinmeyen retcode {code}")


# ===================================================================


# --- TP kapanƒ±≈üƒ±nƒ± tanƒ±yan helper ---------------------------------
def _is_tp_close(deal) -> bool:
    try:
        entry = getattr(deal, "entry", None)
        reason = getattr(deal, "reason", None)
        comment = (getattr(deal, "comment", "") or "").lower()
        is_out = entry == getattr(mt5, "DEAL_ENTRY_OUT", 1)
        is_tp_reason = reason == getattr(mt5, "DEAL_REASON_TP", 0)
        is_tp_comment = "tp" in comment
        return bool(is_out and (is_tp_reason or is_tp_comment))
    except Exception:
        return False


# -------------------------------------------------------------------


def calc_volume_by_risk(
    symbol: str, entry_price: float, sl_price: float, risk_percent: float
) -> float:
    """Calc volume by risk."""

    try:
        si = mt5.symbol_info(symbol)
        if not si:
            raise RuntimeError(f"symbol_info yok: {symbol}")

        point = si.point or 0.01
        # SL mesafesi (point cinsinden)
        risk_pts = abs(float(entry_price) - float(sl_price)) / point
        if risk_pts <= 0:
            return float(os.getenv("LOT", "0.10"))

        ai = mt5.account_info()
        balance = getattr(ai, "balance", 0.0) or getattr(ai, "equity", 0.0)
        risk_usd = balance * (float(risk_percent) / 100.0)

        # 1 lot i√ßin 1 point USD deƒüeri
        if getattr(si, "trade_tick_value", 0) and getattr(si, "trade_tick_size", 0):
            usd_per_point_1lot = si.trade_tick_value / si.trade_tick_size
        else:
            # Fallback: projede varsa PIP_VALUE/ USD_PER_POINT kullan
            usd_per_point_1lot = float(
                globals().get("USD_PER_POINT", globals().get("PIP_VALUE", 1.0))
            )

        if usd_per_point_1lot <= 0:
            return float(os.getenv("LOT", "0.10"))

        vol = risk_usd / (risk_pts * usd_per_point_1lot)

        # Min/Max ve adƒ±m‚Äôa uydur
        vmin = getattr(si, "volume_min", 0.01) or 0.01
        vmax = getattr(si, "volume_max", 100.0) or 100.0
        vstep = getattr(si, "volume_step", 0.01) or 0.01

        vol = max(vmin, min(vol, vmax))
        vol = math.floor(vol / vstep) * vstep
        # g√∂rsellik i√ßin 2 ondalƒ±k (gerekirse artƒ±r)
        return round(vol, 2)
    except Exception:
        # Her ihtimale kar≈üƒ± sabit LOT‚Äôa d√∂n
        return float(os.getenv("LOT", "0.10"))


def RAW_ORDER_SEND(request: dict, *, base_sleep: float = 0.3):
    """
    Order g√∂nderme fonksiyonu.
    - √ñnce order_check ile broker kontrol√º yapƒ±lƒ±r (neden reddettiƒüini g√∂r√ºr√ºz).
    - Ardƒ±ndan order_send ile emir g√∂nderilir.
    - Hatalƒ± olursa alternatif filling modlarƒ± denenir.
    - Ge√ßici hatalarda retry yapƒ±lƒ±r.
    """

    def _explain(rc: int) -> str:
        """MT5 retcode a√ßƒ±klayƒ±cƒ±."""
        table = {
            getattr(mt5, "TRADE_RETCODE_DONE", 10009): "Emir i≈ülendi",
            getattr(mt5, "TRADE_RETCODE_PLACED", 10008): "Emir yerle≈ütirildi",
            getattr(mt5, "TRADE_RETCODE_REQUOTE", 10004): "Requote (fiyat deƒüi≈üti)",
            getattr(mt5, "TRADE_RETCODE_PRICE_CHANGED", 10032): "Fiyat deƒüi≈üti",
            getattr(mt5, "TRADE_RETCODE_OFF_QUOTES", 10027): "Off quotes",
            getattr(mt5, "TRADE_RETCODE_NO_CONNECTION", 10006): "Baƒülantƒ± yok",
            getattr(mt5, "TRADE_RETCODE_SERVER_BUSY", 10003): "Sunucu me≈ügul",
            getattr(mt5, "TRADE_RETCODE_TIMEOUT", 10010): "Zaman a≈üƒ±mƒ±",
            getattr(
                mt5, "TRADE_RETCODE_INVALID_STOPS", 10030
            ): "Ge√ßersiz SL/TP (stops)",
            getattr(
                mt5, "TRADE_RETCODE_INVALID_FILLING", 10028
            ): "Ge√ßersiz filling modu",
            getattr(mt5, "TRADE_RETCODE_MARKET_CLOSED", 10018): "Piyasa kapalƒ±",
            getattr(mt5, "TRADE_RETCODE_TRADE_DISABLED", 10017): "Trading kapalƒ±",
        }
        return table.get(rc, f"Bilinmeyen retcode {rc}")

    try:
        # DEBUG: G√∂nderilen request parametrelerini yaz
        debug_log(f"[ORDER SEND] request={request}", force=True)

        # Broker‚Äôa order_check g√∂nder ‚Üí SL/TP hatasƒ± vs. √∂ƒüren
        check = mt5.order_check(request)
        debug_log(f"[ORDER CHECK RESULT] {check}", force=True)

        if check:
            debug_log(f"[ORDER CHECK RETCODE] {check.retcode}", force=True)
            debug_log(
                f"[ORDER CHECK COMMENT] {getattr(check, 'comment', '')}", force=True
            )
            debug_log(
                f"[ORDER CHECK REQUEST] {getattr(check, 'request', {})}", force=True
            )
            debug_log(
                f"[ORDER CHECK RESULT] {getattr(check, 'result', {})}", force=True
            )

    except Exception as e:
        debug_log(f"[ORDER CHECK EXC] {e}", force=True)

    # filling mod sƒ±rasƒ±
    seq = [
        getattr(mt5, "ORDER_FILLING_IOC", None),
        getattr(mt5, "ORDER_FILLING_FOK", None),
        getattr(mt5, "ORDER_FILLING_RETURN", None),
    ]
    seq = [x for x in seq if x is not None]

    last_result = None
    req = dict(request)  # kopya

    for attempt in range(1, 4):  # max 3 deneme
        try:
            debug_log(f"[ORDER SEND CALL] attempt={attempt} req={req}", force=True)
            result = mt5.order_send(req)
            last_result = result

            if result is None:
                err = mt5.last_error()
                debug_log(
                    f"[ORDER SEND ERROR] None returned! last_error={err}", force=True
                )
                time.sleep(base_sleep * attempt)
                continue

            rc = int(getattr(result, "retcode", -1))
            desc = _explain(rc)
            debug_log(
                f"[ORDER SEND RESULT] retcode={rc} ({desc}) comment={getattr(result, 'comment', '')}",
                force=True,
            )

            # Ba≈üarƒ±lƒ± sonu√ßlar
            if rc in (
                getattr(mt5, "TRADE_RETCODE_DONE", 10009),
                getattr(mt5, "TRADE_RETCODE_PLACED", 10008),
            ):
                return result

            # INVALID_FILLING ‚Üí diƒüer doldurma moduna ge√ß
            if rc == getattr(mt5, "TRADE_RETCODE_INVALID_FILLING", 10028):
                alt = None
                if req.get("type_filling") in seq:
                    i = seq.index(req.get("type_filling"))
                    alt = seq[(i + 1) % len(seq)] if len(seq) > 1 else None
                if alt is not None:
                    req["type_filling"] = alt
                    debug_log(
                        f"[ORDER SEND] filling mode switched to {alt}", force=True
                    )
                    time.sleep(0.1)
                    continue

            # Ge√ßici hatalar ‚Üí retry
            transient = {
                getattr(mt5, "TRADE_RETCODE_REQUOTE", 10004),
                getattr(mt5, "TRADE_RETCODE_PRICE_CHANGED", 10032),
                getattr(mt5, "TRADE_RETCODE_OFF_QUOTES", 10027),
                getattr(mt5, "TRADE_RETCODE_NO_CONNECTION", 10006),
                getattr(mt5, "TRADE_RETCODE_SERVER_BUSY", 10003),
                getattr(mt5, "TRADE_RETCODE_TIMEOUT", 10010),
            }
            if rc in transient:
                debug_log(
                    f"[ORDER SEND] transient error, retrying... rc={rc}", force=True
                )
                time.sleep(base_sleep * attempt)
                continue

            # Kalƒ±cƒ± hata ‚Üí d√∂ng√º kƒ±r
            break

        except Exception as e:
            debug_log(f"[ORDER SEND EXC] {e}", force=True)
            time.sleep(base_sleep * attempt)
            continue

    # T√ºm denemeler ba≈üarƒ±sƒ±z oldu
    return last_result


def _order_send_proxy(request: dict):
    """Single safe entry-point for sending orders.
    - Sanitizes request
    - Always routes through RAW_ORDER_SEND (safe path)
    """
    req = _sanitize_request_plus(request)
    return RAW_ORDER_SEND(req)  # mt5.order_send/MT5_ORDER_SEND kullanma


# T√ºm mevcut √ßaƒürƒ±larƒ± otomatik g√ºvenli h√¢le getir
RAW_ORDER_SEND = _order_send_proxy
# -------------------------------------------------------------------

# Trailing Stop mesafesi
TRAILING_DISTANCE = 200  # pip cinsinden

# Timeframe s√ºreleri (saniye cinsinden)
TF_SECONDS = {
    "M15": 900,  # 15 dk
    "M30": 1800,  # 30 dk
    "M45": 2700,  # 45 dk
    "H1": 3600,  # 1 saat
    "H2": 7200,  # 2 saat
    "H3": 10800,  # 3 saat
    "H4": 14400,  # 4 saat
    "H12": 43200,  # 12 saat
    "D1": 86400,  # 1 g√ºn
}


def get_latest_signals(signals_df: pd.DataFrame) -> dict:
    if signals_df is None or signals_df.empty:
        return {}

    # zaman: index'in son deƒüeri ‚Üí timezone'suz Timestamp
    t = signals_df.index[-1]
    t = pd.to_datetime(t, errors="coerce")
    if t is not None and hasattr(t, "tzinfo") and t.tzinfo is not None:
        t = t.tz_localize(None)

    last = signals_df.iloc[-1]

    clean = {"time": t}
    for col in signals_df.columns:
        if col == "score":
            continue
        val = last[col]
        # deƒüer bool‚Äôa indirgenir
        if hasattr(val, "iloc"):
            val = val.iloc[-1]
        clean[col] = bool(val)

    return clean


def get_server_time():
    tick = mt5.symbol_info_tick(SYMBOL)
    if not tick:
        return now_tr()(ZoneInfo("Europe/Istanbul"))  # fallback: lokal saat
    return datetime.fromtimestamp(tick.time)


def is_candle_closing(tf, df: pd.DataFrame):
    if df is None or df.empty:
        return False

    # Son barƒ±n zamanƒ±nƒ± index‚Äôten al
    last_candle_time = df.index[-1]

    # Eƒüer int tipindeyse ‚Üí datetime‚Äôa √ßevir
    if isinstance(last_candle_time, (int, float)):
        last_candle_time = pd.to_datetime(last_candle_time, unit="s")

    # ≈ûu anki zamanƒ± al
    now = get_server_time()

    # O timeframe i√ßin mum kapanƒ±≈üƒ±nƒ± hesapla
    candle_close_time = last_candle_time + timedelta(seconds=TF_SECONDS[tf])

    # Mum kapanƒ±≈üƒ±na 1 dakika kala true d√∂ns√ºn
    return now >= candle_close_time - timedelta(seconds=60)


def check_tp_bucket(tf: str, entry: float, tp: float, symbol: str) -> bool:
    """
    TF bazlƒ± TP pip kovasƒ± kontrol√º.
    XAUUSD i√ßin 1 pip = 0.01 (PIP_VALUE).
    Aralƒ±k kuralƒ±: [low, high) ‚Üí alt sƒ±nƒ±r dahil, √ºst sƒ±nƒ±r hari√ß.
    Sƒ±nƒ±rda kalan 199.999999 gibi deƒüerler i√ßin k√º√ß√ºk bir tolerans (EPS) kullanƒ±lƒ±r.
    """
    EPS = 1e-6  # sƒ±nƒ±r toleransƒ±

    # Kovayƒ± al
    try:
        low, high = pip_buckets[tf]
    except KeyError:
        debug_log(f"[TP-KOVASI] Tanƒ±msƒ±z TF: {tf}")
        return False

    # Hedef pips
    si = si if ("si" in locals() and si) else mt5.symbol_info(symbol)
    entry = float(locals().get("entry", locals().get("entry_price", 0.0)) or 0.0)
    tp = float(locals().get("tp", locals().get("tp_price", 0.0)) or 0.0)

    hedef_pip = round(_abs_pips(entry, tp, si), 1)
    # √úyelik testi (√ºst sƒ±nƒ±r hari√ß)
    inside = (hedef_pip + EPS) >= low and (hedef_pip - EPS) < high

    # Debug
    debug_log(
        f"[TP-KOVASI] tf={tf} | hedef_pip={hedef_pip:.1f} | aralƒ±k=({low},{high}) | "
        f"entry={entry:.2f} tp={tp:.2f} -> {'OK' if inside else 'RED'}"
    )

    return inside


def choose_target_pips(tf: str, mode: str = "fixed") -> int | None:

    if tf not in pip_buckets:
        return None  # ‚ùå tanƒ±mlƒ± olmayan TF i√ßin pip d√∂nd√ºrme
    low, high = pip_buckets[tf]

    if mode == "low":
        return low
    elif mode == "high":
        return low if high == float("inf") else high - 1  # √ºst sƒ±nƒ±r hari√ß
    elif mode == "mid":
        h = low if high == float("inf") else high - 1
        return (low + h) // 2
    elif mode == "random":
        return (
            low if high == float("inf") else random.randint(low, high - 1)
        )  # √ºst sƒ±nƒ±rƒ± dƒ±≈üla
    else:
        return None


def choose_stop_loss(tf_df, direction, levels, tf="H1"):
    # ATR hesapla
    atr_values = calculate_atr(tf_df, period=14)
    atr_value = (
        float(atr_values.iloc[-1])
        if atr_values is not None and not atr_values.empty
        else 0
    )
    pip_value = 0.01  # XAUUSD -> 1 pip = 0.01 USD

    buffer_table = {
        "M15": atr_value * 0.5,
        "M30": atr_value * 0.5,
        "M45": atr_value * 0.5,
        "H1": atr_value * 0.5,
        "H2": atr_value * 0.5,
        "H3": atr_value * 0.5,
        "H4": atr_value * 0.5,
        "H12": atr_value * 0.5,
    }
    pip_buffer = buffer_table.get(tf, atr_value * 0.5)

    # K√º√ß√ºk TF'lerde farklƒ± √∂ncelik
    if tf in ["M15", "M30", "M45"]:
        priority = ["LQ", "SWING"]
    else:
        priority = ["OB", "BRK", "FVG", "FTR", "SD", "MSB", "LQ"]

    # √ñncelikli seviyelerden SL se√ß
    for key in priority:
        level = levels.get(key)
        if level is not None:
            if isinstance(level, pd.Series):
                level = float(level.iloc[-1])
            else:
                level = float(level)
            return level, key

    # Eƒüer hi√ß seviye yoksa fallback ‚Üí ATR
    last = tf_df.iloc[-1]
    if direction == "LONG":
        return float(last["low"]) - pip_buffer, "ATR-Fallback"
    else:
        return float(last["high"]) + pip_buffer, "ATR-Fallback"


try:

    load_dotenv()
except Exception:
    pass


def should_open_trade(eval_ctx: dict) -> bool:
    force_open = str(getenv("FORCE_OPEN", "0")) == "1"

    rr_ok = bool(eval_ctx.get("rr_ok", True))
    confirm_ok = bool(eval_ctx.get("confirm_ok", True))
    score_ok = bool(eval_ctx.get("score_ok", True))
    spread_ok = bool(eval_ctx.get("spread_ok", True))

    if force_open:
        rr_ok = confirm_ok = score_ok = spread_ok = True
        why = eval_ctx.get("why", [])
        why.append("FORCE_OPEN: t√ºm filtreler baypas")
        eval_ctx["why"] = why

    return rr_ok and confirm_ok and score_ok and spread_ok

    print("DBG-open:", should_open_trade)


# --- unified should_block_trade: TF rate-limit + eval_ctx desteƒüi ---
def should_block_trade(arg=None):
    """
    arg bir dict (eval_ctx) ya da string (tf_used) olabilir.
    - dict gelirse: should_open_trade(eval_ctx) sonucunu tersine √ßevirir, 'why' notunu d√∂ner.
    - TF adƒ± elde edilirse: MAX_TRADES_PER_TF_PER_DAY'a g√∂re rate-limit uygular.
    D√∂n√º≈ü: (block: bool, why: str)
    """
    tf = None
    allow_ctx = None
    why = ""

    # 1) arg t√ºr√ºn√º √ß√∂z
    if isinstance(arg, dict):
        # eval_ctx ‚Üí trade a√ßƒ±lmalƒ± mƒ±?
        allow_ctx = should_open_trade(arg)
        wh = arg.get("why", "")
        if isinstance(wh, (list, tuple)):
            why = ";".join(str(x) for x in wh)
        elif isinstance(wh, str):
            why = wh or ""
        # tf adƒ± varsa al
        tf = (
            arg.get("tf")
            or arg.get("timeframe")
            or arg.get("tf_used")
            or arg.get("tf_name")
        )
    elif isinstance(arg, str):
        tf = arg  # eski stil: sadece timeframe string

    # 2) eval_ctx ile geldiyse onun kararƒ±nƒ± uygula
    if allow_ctx is not None:
        return (not allow_ctx), (why or "ok")

    # 3) Aksi halde bloklama yok
    return False, "ok"

    print("DBG-block:", should_block_trade)


# --- /unified should_block_trade ---


# --- Trailing (.env) ---
TRAILING_MODE = os.getenv("TRAILING_MODE", "OFF").strip().upper()  # OFF | PIPS | ATR

# PIPS tabanlƒ± trailing mesafesi
try:
    TRAILING_DISTANCE_PIPS = float(os.getenv("TRAILING_DISTANCE_PIPS", "150"))
except Exception:
    TRAILING_DISTANCE_PIPS = 150.0
TRAILING_DISTANCE_PIPS = max(0.0, TRAILING_DISTANCE_PIPS)

# ATR tabanlƒ± trailing √ßarpanƒ±
try:
    TRAILING_ATR_MULT = float(os.getenv("TRAILING_ATR_MULT", "1.0"))
except Exception:
    TRAILING_ATR_MULT = 1.0
TRAILING_ATR_MULT = max(0.0, TRAILING_ATR_MULT)

# Geriye d√∂n√ºk uyum (eski kod TRAILING_DISTANCE kullanƒ±yorsa kƒ±rƒ±lmasƒ±n)
TRAILING_DISTANCE = int(TRAILING_DISTANCE_PIPS)

debug_log(
    "[ENV] TRAIL:",
    TRAILING_MODE,
    "| PIPS:",
    TRAILING_DISTANCE_PIPS,
    "| DIST:",
    TRAILING_DISTANCE,
    "| ATRx:",
    TRAILING_ATR_MULT,
)


def _env_list(key, default=""):
    s = os.getenv(key, default) or ""
    return [x.strip().upper() for x in s.split(",") if x.strip()]


# .env: TELEGRAM_WHITELIST=BOOT,SIGNAL,TARGET
_whitelist = set(_env_list("TELEGRAM_WHITELIST", "BOOT,SIGNAL,TARGET"))

# Tek kaynak: ALLOWED_TG
ALLOWED_TG = _whitelist or {"BOOT", "SIGNAL", "TARGET"}

# Eski kod TRAILING_DISTANCE kullanƒ±yorsa kƒ±rƒ±lmasƒ±n:
TRAILING_DISTANCE = int(TRAILING_DISTANCE_PIPS)


# --- Confirm e≈üikleri (.env) ---------------------------------------


def _env_int(key, default):
    try:
        return int(os.getenv(key, str(default)))
    except:
        return default


TF_LIST = ["M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]
CONFIRM_DEFAULT = _env_int("CONFIRM_DEFAULT", 3)

CONFIRM_NEEDED = {tf: _env_int(f"CONFIRM_{tf}", CONFIRM_DEFAULT) for tf in TF_LIST}


def get_confirm_threshold(tf: str) -> int:
    return int(CONFIRM_NEEDED.get(tf.upper(), CONFIRM_DEFAULT))


# -------------------------------------------------------------------

debug_log(
    "[ENV] CONFIRM_NEEDED:",
    CONFIRM_NEEDED,
    "| TG_WHITELIST:",
    ALLOWED_TG,
    "| TRAIL_PIPS:",
    TRAILING_DISTANCE_PIPS,
    "-> DIST:",
    TRAILING_DISTANCE,
)

# --- Risk & Trailing (.env) ---
try:
    RISK_PERCENT = float(os.getenv("RISK_PERCENT", "0.02"))
except Exception:
    RISK_PERCENT = 0.02
RISK_PERCENT = max(0.0, min(RISK_PERCENT, 1.0))  # 0‚Äì1 arasƒ± sƒ±kƒ±≈ütƒ±r

ATR_PERIOD = int(os.getenv("ATR_PERIOD", "14"))

TRAILING_MODE = (os.getenv("TRAILING_MODE", "OFF") or "OFF").upper()
if TRAILING_MODE not in {"OFF", "PIPS", "ATR"}:
    TRAILING_MODE = "OFF"

try:
    TRAILING_DISTANCE_PIPS = float(os.getenv("TRAILING_DISTANCE_PIPS", "0"))
except Exception:
    TRAILING_DISTANCE_PIPS = 0.0
TRAILING_DISTANCE_PIPS = max(0.0, TRAILING_DISTANCE_PIPS)

try:
    TRAILING_ATR_MULT = float(os.getenv("TRAILING_ATR_MULT", "1.0"))
except Exception:
    TRAILING_ATR_MULT = 1.0
TRAILING_ATR_MULT = max(0.0, TRAILING_ATR_MULT)

D1_TREND_MODE = os.getenv("D1_TREND_MODE", "OFF").upper()  # OFF | SOFT | HARD
try:
    D1_TREND_MA = int(os.getenv("D1_TREND_MA", "50"))
except Exception:
    D1_TREND_MA = 50

if D1_TREND_MODE not in {"OFF", "SOFT", "HARD"}:
    D1_TREND_MODE = "OFF"

    debug_log(
        f"[BOOT] D1_TREND_MODE={D1_TREND_MODE} D1_TREND_MA={D1_TREND_MA}", force=True
    )


TP_MODE = os.getenv("TP_BUCKET", "RANDOM").upper()
if TP_MODE not in {"RANDOM", "LOW", "MID", "HIGH", "FIXED"}:
    TP_MODE = "RANDOM"


def get_target_pips(tf: str) -> int | None:
    # choose_target_pips'i .env‚Äôdeki TP_MODE ile √ßaƒüƒ±rƒ±r
    return choose_target_pips(tf, mode=TP_MODE.lower())


SPREAD_MODE = os.getenv("SPREAD_MODE", "AUTO").upper()  # SOFT | HARD | AUTO
MAX_SPREAD_POINTS = int(
    os.getenv("MAXIMUM_SPREAD_POINTS", "40")
)  # .env'deki isim aynen b√∂yle
MAX_SPREAD_SL_RATIO = float(os.getenv("MAX_SPREAD_SL_RATIO", "0.20"))

TZ_NAME = os.getenv("TIMEZONE", "Europe/Istanbul")

HARD_WINDOWS = os.getenv("HARD_WINDOWS", "")  # "16:30-16:45, 17:00-17:10" gibi
SOFT_WINDOWS = os.getenv("SOFT_WINDOWS", "")

if SPREAD_MODE not in {"SOFT", "HARD", "AUTO"}:
    SPREAD_MODE = "SOFT"

MAX_SPREAD_POINTS = max(0.0, MAX_SPREAD_POINTS)
MAX_SPREAD_SL_RATIO = min(max(0.0, MAX_SPREAD_SL_RATIO), 1.0)

# ---- SPREAD modu: AUTO ‚Üí saat pencerelerine g√∂re HARD/SOFT ----

# --- Confirm (teyit) e≈üikleri (.env) ---
TF_LIST = ["M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]


def _get_confirm_needed(tf: str) -> int:
    # TF‚Äôe √∂zel yoksa CONFIRM_DEFAULT‚Äôu al; sayƒ± deƒüilse 3‚Äôe d√º≈ü
    v = os.getenv(f"CONFIRM_{tf}")
    if v is None:
        v = os.getenv("CONFIRM_DEFAULT", "3")
    try:
        return max(0, int(v))
    except Exception:
        return 3


CONFIRM_NEEDED = {tf: _get_confirm_needed(tf) for tf in TF_LIST}
debug_log(f"[BOOT] CONFIRM_NEEDED={CONFIRM_NEEDED}", force=True)


def local_time() -> _dt_time:
    """ENV'deki TZ_NAME'e g√∂re yerel saat nesnesi (datetime.time) d√∂nd√ºr√ºr."""
    return now_tr()(ZoneInfo("Europe/Istanbul"))


def _parse_windows(s: str):
    # "16:30-16:45,17:00-17:10" -> [(16:30,16:45), (17:00,17:10)]
    wins = []
    if not s:
        return wins
    for part in s.split(","):
        part = part.strip()
        if not part:
            continue
        try:
            a, b = part.split("-")
            h1, m1 = map(int, a.split(":"))
            h2, m2 = map(int, b.split(":"))
            wins.append((_dt_time(h1, m1), _dt_time(h2, m2)))
        except Exception:
            # hatalƒ± par√ßa -> g√∂rmezden gel
            continue
    return wins


def _in_windows(now: _dt_time, windows) -> bool:
    """Verilen 'now' (datetime.time) belirtilen saat aralƒ±klarƒ±ndan birinin i√ßinde mi?"""
    if not windows:
        return False

    t = now  # <- √ñNEMLƒ∞: artƒ±k local_time() √ßaƒüƒ±rmƒ±yoruz, parametreyi kullanƒ±yoruz

    for s, e in windows:
        if s <= e:
            # normal aralƒ±k (√∂rn. 16:30‚Äì16:45)
            if s <= t <= e:
                return True
        else:
            # gece devreden aralƒ±k (√∂rn. 23:50‚Äì00:10)
            if t >= s or t <= e:
                return True
    return False


HARD_W = _parse_windows(HARD_WINDOWS or "")
SOFT_W = _parse_windows(SOFT_WINDOWS or "")


def get_effective_spread_mode() -> str:
    """
    SPREAD_MODE = AUTO ise saat pencerelerine g√∂re HARD/SOFT se√ß.
    Hi√ßbir pencereye d√º≈ümezse default SOFT d√∂nd√ºr (None asla yok).
    """
    base = (SPREAD_MODE or "SOFT").upper()
    if base != "AUTO":
        return base

    now = local_time()

    # √ñnce HARD penceresi mi?
    if _in_windows(now, HARD_W):
        return "HARD"
    # Deƒüilse SOFT penceresi mi?
    if _in_windows(now, SOFT_W):
        return "SOFT"

    # AUTO ama hi√ßbir pencereye girmedi ‚Üí default
    return "SOFT"


# === Telegram Ayarlarƒ± ===
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
MIN_TG_INTERVAL = float(os.getenv("MIN_TG_INTERVAL", "2.0"))

# anti-spam
try:
    MIN_TG_INTERVAL = float(os.getenv("MIN_TG_INTERVAL", "2.0"))
except Exception:
    pass  # inserted to satisfy block
# removed duplicate MIN_TG_INTERVAL (using env-based definition)
LAST_TG_SENT = 0.0  # ba≈ülangƒ±√ß


def diagnose_now(tf: str, res: dict) -> None:
    """
    Kapanƒ±≈üƒ±/TF d√∂ng√ºs√ºn√º beklemeden 'neden a√ßmƒ±yorum?' sorusuna anƒ±nda cevap verir.
    A√ßmama nedenlerini tek tek listeler; SL/TP korumasƒ±nƒ± da sim√ºle eder.
    """
    reasons = []

    # 1) Y√∂n / teyit sayƒ±sƒ±
    direction = str(res.get("direction", "")).upper()
    if direction not in ("LONG", "SHORT"):
        reasons.append("direction:NONE")

    try:
        need = get_confirm_threshold(tf)
        got = sum(1 for k, v in res.items() if isinstance(v, bool) and v)
        if got < need:
            reasons.append(f"confirm {got}/{need}")
    except Exception:
        reasons.append("confirm_err")

    # 2) Spread kapƒ±sƒ±
    try:
        allow, why = spread_gate(direction, os.getenv("SPREAD_MODE", "AUTO"))
        if not allow:
            reasons.append(f"spread:{why}")
    except Exception:
        reasons.append("spread_err")

    # 3) RR e≈üiƒüi
    try:
        min_rr = float(os.getenv("MIN_RR", "0"))
    except Exception:
        min_rr = 0.0
    rr = res.get("rr")
    if rr is None or (isinstance(rr, (int, float)) and rr < min_rr):
        reasons.append(f"rr:{rr}")

    # 4) SL/TP mevcut mu?
    entry = float(res.get("entry_price") or 0.0)
    sl = float(res.get("sl_price") or 0.0)
    tp = float(res.get("tp_price") or 0.0)
    if entry == 0.0 or sl == 0.0 or tp == 0.0:
        reasons.append(f"sl/tp missing -> sl={sl} tp={tp}")

    # 5) Sembol & tick
    symbol = (
        res.get("symbol") or os.getenv("GOLD_SYMBOL") or os.getenv("SYMBOL") or "GOLD"
    )
    if not mt5.symbol_select(symbol, True):
        reasons.append(f"symbol not tradable -> {symbol}")

    si = mt5.symbol_info(symbol)
    if not si:
        reasons.append("symbol_info:none")
        point, digits = 0.01, 2
    else:
        point = si.point or 0.01
        digits = si.digits or 2

    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        reasons.append("tick:none")
        price = entry
    else:
        price = tick.ask if direction == "LONG" else tick.bid

    buf = point  # k√º√ß√ºk tampon (1 point)
    base = entry if entry else price  # giri≈ü baz fiyatƒ± (BUY->ask, SELL->bid)

    # Mevcut sl/tp'yi √ßek
    sl_g = float(sl or 0.0)
    tp_g = float(tp or 0.0)

    if direction == "LONG":
        if sl_g <= 0.0:
            sl_g = base - buf
        if tp_g <= 0.0:
            tp_g = base + buf
    else:  # SHORT
        if sl_g <= 0.0:
            sl_g = base + buf
        if tp_g <= 0.0:
            tp_g = base - buf

    # Broker basamaklarƒ±na yuvarla
    sl_g = round(sl_g, digits)
    tp_g = round(tp_g, digits)

    # --- g√ºvenli pips log'u: tf yoksa sessiz ge√ß + b√∂lme hatasƒ±na kar≈üƒ± korumalƒ± ---
    try:
        tf_label = str(tf)  # bazƒ± yerlerde yok; sorun olmasƒ±n
    except Exception:
        tf_label = ""

    try:
        p = float(point)  # 'point' sayƒ± deƒüilse bile d√º≈ümesin
    except Exception:
        p = 0.01

    def _to_pips(dist):
        try:
            return float(dist) / p if p else 0.0
        except Exception:
            return 0.0

    # 7) Lot/volume
    try:
        rp = float(os.getenv("RISK_PERCENT", "0"))
    except Exception:
        rp = 0.0
    volume = 0.0
    try:
        if rp > 0 and entry and sl:
            volume = calc_volume_by_risk(symbol, entry, sl_g, rp)
        else:
            volume = float(os.getenv("LOT", "0.10"))
    except Exception:
        volume = float(os.getenv("LOT", "0.10"))

    if not volume or volume <= 0:
        reasons.append(f"lot/volume:{volume}")

    # 8) TP kovasƒ± vs (varsa)
    try:
        if not check_tp_bucket(tf, entry, tp):
            reasons.append("tp_bucket")
    except Exception:
        # opsiyonel: yoksa g√∂rmezden gel
        pass

    # √ñzet log
    pre_risk = abs(entry - sl) / point if entry and sl else 0.0
    pre_rew = abs(tp - entry) / point if tp and entry else 0.0
    guard_r = abs(entry - sl_g) / point if entry and sl_g else 0.0
    guard_rw = abs(tp_g - entry) / point if tp_g and entry else 0.0
    side_txt = (
        "BUY" if direction == "LONG" else ("SELL" if direction == "SHORT" else "-")
    )

    debug_log(
        f"[DIAG {tf}] side={side_txt} sym={symbol} "
        f"entry={entry:.{digits}f} sl={sl:.{digits}f}->{sl_g:.{digits}f} "
        f"tp={tp:.{digits}f}->{tp_g:.{digits}f} price={price:.{digits}f} "
        f"pre_risk={pre_risk:.1f}p pre_rew={pre_rew:.1f}p "
        f"guard_risk={guard_r:.1f}p guard_rew={guard_rw:.1f}p "
    )

    if reasons:
        debug_log(f"[DIAG {tf}] DROP -> " + ", ".join(reasons))
    else:
        debug_log(f"[DIAG {tf}] PASS -> T√ºm kapƒ±lar OK (dry-run)")


# Telegram mesajƒ± (istersen)
def build_signal_msg(tf, res):
    trues = [k for k, v in res.items() if isinstance(v, bool) and v]
    note = res.get("spread_note") or res.get("trend_note") or ""
    base = (
        f"‚úÖ[{tf}] sinyali\n"
        f"Y√∂n: {res.get('direction','-')}\n"
        f"Formasyon: {res.get('formasyon','-')}\n"
        f"TRUE kolonlar: {trues}"
    )
    return base + (f"\n{note}" if note else "")


# --- Basit tekille≈ütirme kapƒ±sƒ± (aynƒ± dakika/aynƒ± i√ßerik tekrarƒ±nƒ± engelle) ---


def _msg_key(tf: str, res: dict) -> tuple:
    # dakika, y√∂n, formasyon ve TRUE olan kolonlar
    try:

        minute = pd.to_datetime(res.get("time")).floor("T").strftime("%Y-%m-%d %H:%M")
    except Exception:
        minute = ""
    direction = res.get("direction", "")
    formasyon = res.get("formasyon", "")
    true_cols = tuple(sorted(k for k, v in res.items() if isinstance(v, bool) and v))
    return (minute, direction, formasyon, true_cols)


def remember_msg(tf: str, res: dict) -> None:
    LAST_MSG_SIG[tf] = _msg_key(tf, res)


def is_duplicate_msg(tf: str, res: dict) -> bool:
    return False


# === MetaTrader 5 Ayarlarƒ± ===
MT5_LOGIN = int(os.getenv("MT5_LOGIN"))
MT5_PASSWORD = os.getenv("MT5_PASSWORD")
MT5_SERVER = os.getenv("MT5_SERVER")
SYMBOL = os.getenv("GOLD_SYMBOL", "GOLD")
LOT = float(os.getenv("LOT", 0.10))


# === √ñzel 45 Dakika Timeframe ===
TIMEFRAMES = {
    "M15": mt5.TIMEFRAME_M15,
    "M30": mt5.TIMEFRAME_M30,
    "H1": mt5.TIMEFRAME_H1,
    "H2": mt5.TIMEFRAME_H2,
    "H3": mt5.TIMEFRAME_H3,
    "H4": mt5.TIMEFRAME_H4,
    "H12": mt5.TIMEFRAME_H12,
    "D1": mt5.TIMEFRAME_D1,
}


# === √ñzel 45 Dakika Ortalama (15m + 30m) ===
def get_mixed_45m(symbol, num_bars=200):
    # M15 verisini √ßek
    rates_15 = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_M15, 0, num_bars * 3)
    # M30 verisini √ßek
    rates_30 = mt5.copy_rates_from_pos(symbol, mt5.TIMEFRAME_M30, 0, num_bars * 2)

    if rates_15 is None or rates_30 is None:
        debug_log("Veri alƒ±namadƒ±")
        return None

    # 15 dk dataframe
    df15 = pd.DataFrame(rates_15)
    df15["time"] = pd.to_datetime(df15["time"], unit="s")
    df15.set_index("time", inplace=True)
    df15["avg_price"] = (df15["open"] + df15["high"] + df15["low"] + df15["close"]) / 4

    # 30 dk dataframe
    df30 = pd.DataFrame(rates_30)
    df30["time"] = pd.to_datetime(df30["time"], unit="s")
    df30.set_index("time", inplace=True)
    df30["avg_price"] = (df30["open"] + df30["high"] + df30["low"] + df30["close"]) / 4

    # Zaman indeksine g√∂re birle≈ütir
    df = pd.concat([df15["avg_price"], df30["avg_price"]], axis=1)
    df.columns = ["avg15", "avg30"]

    # 45 dakikada ortalama al
    df_45m = pd.DataFrame()
    df_45m["avg15"] = df["avg15"].resample("45T").mean()
    df_45m["avg30"] = df["avg30"].resample("45T").mean()
    df_45m["mixed_avg"] = df_45m[["avg15", "avg30"]].mean(axis=1)

    df_45m.dropna(inplace=True)
    return df_45m


# ========= Configuration =========
CONFIG = {
    # General
    "doji_frac": 0.10,  # body <= range * doji_frac
    "engulf_factor": 1.0,  # current body >= prev body * factor
    "pin_wick_ratio": 2.5,  # long wick >= body * ratio
    "pin_edge_pct": 0.30,  # close near edge: <= range * pct
    "harami_body_frac": 1.0,  # current body <= prev body * frac
    "marubozu_shadow_frac": 0.10,  # total shadows <= range * frac
    "three_candle_body_frac": 0.6,  # soldiers/crows: body >= range * frac
    "ib_min_inside_frac": 0.0,  # inside bar strictness (0=classic)
    "tweezer_tol_pct": 0.0015,  # equal highs/lows tolerance ratio
    "equal_level_tol": 0.0020,  # equality tolerance for sweeps/doubles
    "pivot_lookback": 2,  # local pivot detection neighborhood
    "window_chart_patterns": 120,  # scan window for chart patterns
    "range_narrow_frac": 0.75,  # wedges: range narrowing threshold
    "triangle_min_span": 15,  # min bars in window for triangles/wedges
    "slope_eps": 1e-9,  # numeric epsilon for slope checks
    "abcd_tol": 0.15,  # AB=CD: |AB - CD| <= tol * max(|AB|,|CD|)
    "abcd_bc_min": 0.382,  # BC retracement min
    "abcd_bc_max": 0.786,  # BC retracement max
    "wolfe_tol": 0.02,  # Wolfe heuristic tolerance
    "wedge_lookback": 80,
    "wedge_pivot_lb": 2,
    "wedge_min_touchers": 3,
    "wedge_converge_tol": 0.12,
    "wedge_pretrend_lb": 60,
    "wedge_allow_counter": True,
    "wedge_buffer_pips": 10,
    "cup_lookback": 120,
    "cup_rim_tol": 0.01,
    "cup_handle_min": 5,
    "cup_handle_max": 25,
    "cup_handle_ret_min": 0.2,
    "cup_handle_ret_max": 0.5,
    "pattern_buffer_pips": 10,
}


SAFEY_PIPS = float(os.getenv("SLTP_SAFETY_PIPS", "0.5"))


# ========= Helpers =========
def _require_cols(df: pd.DataFrame):
    req = {"open", "high", "low", "close"}
    miss = req - set(df.columns)
    if miss:
        raise ValueError(f"Missing required columns: {miss}")


def _prep(df: pd.DataFrame) -> pd.DataFrame:
    _require_cols(df)
    d = df.copy()
    d = d.astype(
        {"open": "float64", "high": "float64", "low": "float64", "close": "float64"}
    )
    d["body"] = (d["close"] - d["open"]).abs()
    d["range"] = (d["high"] - d["low"]).replace(0, np.nan)
    upper_base = np.maximum(d["open"], d["close"])
    lower_base = np.minimum(d["open"], d["close"])
    d["upper_wick"] = d["high"] - upper_base
    d["lower_wick"] = lower_base - d["low"]
    d["bull"] = d["close"] > d["open"]
    d["bear"] = ~d["bull"]
    return d


def _pivot_highs(s: pd.Series, lb: int) -> pd.Series:
    # local max relative to neighbors within +/- lb
    cond = s.rolling(lb * 2 + 1, center=True).apply(
        lambda a: a[lb] == np.nanmax(a), raw=True
    )
    return cond.astype(bool)


def _pivot_lows(s: pd.Series, lb: int) -> pd.Series:
    cond = s.rolling(lb * 2 + 1, center=True).apply(
        lambda a: a[lb] == np.nanmin(a), raw=True
    )
    return cond.astype(bool)


def _lin_slope(y: pd.Series) -> float:
    n = len(y)
    if n < 2:
        return 0.0
    x = np.arange(n, dtype=float)
    den = (n * (n - 1) * (2 * n - 1) / 6) - ((n - 1) * n / 2) ** 2 / n
    if abs(den) < 1e-12:
        den = 1e-12
    x_mean = (n - 1) / 2.0
    y_mean = y.mean()
    num = ((x - x_mean) * (y.values - y_mean)).sum()
    return num / den


def _last_window(df: pd.DataFrame, n: int) -> pd.DataFrame:
    if len(df) <= n:
        return df.copy()
    return df.iloc[-n:].copy()


def get_ohlc(
    symbol,
    timeframe=mt5.TIMEFRAME_M15,
    bars: int = 500,
    *,
    base_sleep: float = 0.3,
    max_try: int = 2,
) -> pd.DataFrame:
    """MT5'ten OHLC √ßek; k√º√ß√ºk retry yap; asla exception fƒ±rlatma.
    Ba≈üarƒ±sƒ±z olursa Bo≈ü DataFrame d√∂ner (√ßaƒüƒ±ran kontrol eder).
    """
    for i in range(1, max_try + 1):  # 1..max_try
        try:
            rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, bars)
        except Exception as e:
            rates = None
            try:
                logger.warning(
                    "[MT5] copy_rates_from_pos EXC (try %d/%d): %s", i, max_try, e
                )
            except Exception:
                debug_log(
                    f"[MT5] copy_rates_from_pos EXC (try {i}/{max_try}): {e}",
                    force=True,
                )

        if rates is not None and len(rates) > 0:
            try:
                df = pd.DataFrame(rates)
                # epoch saniyeyi datetime'a √ßevir (naive/yerel)
                try:
                    df["time"] = pd.to_datetime(df["time"], unit="s")
                except Exception:
                    pass
                return df
            except Exception as e:
                try:
                    logger.warning(
                        "[MT5] rates->DataFrame EXC (try %d/%d): %s", i, max_try, e
                    )
                except Exception:
                    debug_log(
                        f"[MT5] rates->DataFrame EXC (try {i}/{max_try}): {e}",
                        force=True,
                    )

        # bo≈ü/None: bilgi ama√ßlƒ± log + kƒ±sa bekleme
        try:
            err = mt5.last_error()  # (code, desc)
        except Exception:
            err = None

        try:
            logger.warning(
                "[MT5] copy_rates_from_pos bo≈ü/None (deneme %d/%d) last_error=%s",
                i,
                max_try,
                repr(err),
            )
        except Exception:
            debug_log(
                f"[MT5] copy_rates_from_pos bo≈ü/None (deneme {i}/{max_try}) last_error={err}",
                force=True,
            )

        try:
            _time.sleep(max(0.0, base_sleep) * i)  # 0.3s, 0.6s, ...
        except Exception:
            pass

    # t√ºm denemeler bittiyse bo≈ü DataFrame
    try:
        logger.warning(
            "[MT5] get_ohlc EMPTY return for %s tf=%s bars=%d",
            symbol,
            str(timeframe),
            bars,
        )
    except Exception:
        debug_log(
            f"[MT5] get_ohlc EMPTY return for {symbol} tf={timeframe} bars={bars}",
            force=True,
        )
    return pd.DataFrame()


# --------------------------------------------------------------------


# ========= Candle / Bar Formations =========


def engulfing_strong(data, ema=None, use_volume=True, strong=True, lookback_trend=5):
    if len(data) < 2:
        return False, False

    last = data.iloc[-1]
    prev = data.iloc[-2]

    tol = 0.2 * PIP_VALUE
    rng_last = max(last["high"] - last["low"], 1e-9)
    body_last = abs(last["close"] - last["open"])
    rng_prev = max(prev["high"] - prev["low"], 1e-9)
    body_prev = abs(prev["close"] - prev["open"])

    # doji/ufak g√∂vdeyi ele
    if body_last / rng_last < CONFIG.get("doji_frac", 0.10):
        return False, False

    # wick/g√∂vde oranƒ± (fitilli sahte sinyal filtresi)
    if body_last < CONFIG.get("engulf_factor", 1.0) * body_prev:
        return False, False

    # temel engulf ko≈üullarƒ± (g√∂vde g√∂vdeyi sarƒ±yor)
    bull_core = (
        prev["close"] < prev["open"]
        and last["close"] > last["open"]
        and last["open"] <= prev["close"] + tol
        and last["close"] >= prev["open"] - tol
    )
    bear_core = (
        prev["close"] > prev["open"]
        and last["close"] < last["open"]
        and last["open"] >= prev["close"] - tol
        and last["close"] <= prev["open"] + tol
    )

    if strong:
        bull_core = bull_core and (last["close"] >= prev["high"] - tol)
        bear_core = bear_core and (last["close"] <= prev["low"] + tol)

    # Trend teyidi (opsiyonel)
    if ema is not None and len(data) >= lookback_trend:
        ema_val = float(ema.iloc[-1]) if hasattr(ema, "iloc") else float(ema)
        bull_core = bull_core and (last["close"] > ema_val)
        bear_core = bear_core and (last["close"] < ema_val)

    # Hacim teyidi (opsiyonel)
    if use_volume and "tick_volume" in data.columns and len(data) >= 20:
        vol_ok = (
            data["tick_volume"].iloc[-1]
            > data["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull_core = bull_core and vol_ok
        bear_core = bear_core and vol_ok

    return bool(bull_core), bool(bear_core)


def pinbar_strict(
    data,
    direction=None,
    wick_ratio=2.5,
    body_frac=0.25,
    close_quartile=True,
    ema=None,
    use_volume=True,
):
    """
    direction: "bull", "bear" ya da None (ikisini de d√∂nd√ºr)
    wick_ratio: fitil/g√∂vde oranƒ± e≈üiƒüi
    body_frac: body/range √ºst sƒ±nƒ±rƒ± (doji filtre)
    close_quartile: close'un u√ß √ßeyrekte olma ≈üartƒ±
    """
    if len(data) < 1:
        return False, False
    last = data.iloc[-1]

    high, low = float(last["high"]), float(last["low"])
    open_, close = float(last["open"]), float(last["close"])
    rng = max(high - low, 1e-9)
    body = abs(close - open_)
    up_w = high - max(open_, close)
    low_w = min(open_, close) - low

    # g√∂vde k√º√ß√ºk olsun
    if body / rng > body_frac:
        return False, False

    # kapanƒ±≈ü konumu (opsiyonel)
    ok_upper = close >= low + 0.75 * rng
    ok_lower = close <= low + 0.25 * rng
    if close_quartile:
        bull_quart_ok = ok_upper
        bear_quart_ok = ok_lower
    else:
        bull_quart_ok = bear_quart_ok = True

    # fitil oranlarƒ±
    bull = (low_w >= wick_ratio * body) and bull_quart_ok
    bear = (up_w >= wick_ratio * body) and bear_quart_ok

    # trend filtresi (opsiyonel)
    if ema is not None:
        ema_v = float(ema.iloc[-1]) if hasattr(ema, "iloc") else float(ema)
        bull = bull and (close > ema_v)
        bear = bear and (close < ema_v)

    # hacim teyidi (opsiyonel)
    if use_volume and "tick_volume" in data.columns and len(data) >= 20:
        vol_ok = (
            data["tick_volume"].iloc[-1]
            > data["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return bool(bull), bool(bear)


def inside_bar(data):
    """Son mum, bir √∂ncekinin i√ßinde mi? (tek kontrol)"""
    if len(data) < 2:
        return False
    last = data.iloc[-1]
    prev = data.iloc[-2]
    return (last["high"] <= prev["high"]) and (last["low"] >= prev["low"])


def inside_chain_breakout(df, lookback=20, buffer_pips=5, vol_confirm=True):
    """
    Son X bar i√ßinde olu≈üan inside-bar zincirinin mother bar sƒ±nƒ±rƒ±nƒ±n kƒ±rƒ±lƒ±mƒ±nƒ± test eder.
    D√∂n√º≈ü: (bull_break, bear_break, meta)
    """
    if len(df) < 3:
        return False, False, {}

    d = df.iloc[-lookback:].copy()
    # zinciri en sondan geri sar: mother'ƒ± bul
    i = len(d) - 1
    inside_cnt = 0
    while i >= 1:
        cur, prev = d.iloc[i], d.iloc[i - 1]
        if (cur["high"] <= prev["high"]) and (cur["low"] >= prev["low"]):
            inside_cnt += 1
            i -= 1
        else:
            # prev mother bar
            mother = prev
            break
    else:
        # hepsi i√ß i√ßeyse ilk barƒ± mother al
        mother = d.iloc[0]

    upper = float(mother["high"])
    lower = float(mother["low"])
    close = float(d.iloc[-1]["close"])

    # k√º√ß√ºk pip tamponu
    buffer = buffer_pips * PIP_VALUE
    bull = close > upper + buffer
    bear = close < lower - buffer

    # hacim teyidi (opsiyonel)
    if vol_confirm and "tick_volume" in d.columns and len(d) >= 20:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    meta = {"mother_high": upper, "mother_low": lower, "inside_count": inside_cnt}
    return bool(bull), bool(bear), meta


def is_outside_bar(data):
    """Son mum, bir √∂ncekinin hem y√ºksek hem d√º≈ü√ºk deƒüerlerini A≈ûIYOR mu?"""
    if len(data) < 2:
        return False
    last = data.iloc[-1]
    prev = data.iloc[-2]
    return (last["high"] >= prev["high"]) and (last["low"] <= prev["low"])


def outside_breakout(df, buffer_pips=5, vol_confirm=False):
    """
    Outside bar sonrasƒ±nda kƒ±rƒ±lƒ±m sinyali √ºretir.
    D√∂n√º≈ü: (bull_break, bear_break, meta)
    - bull_break: close > mother_high + buffer
    - bear_break: close < mother_low - buffer
    """
    if len(df) < 2:
        return False, False, {}

    prev = df.iloc[-2]
    last = df.iloc[-1]
    mother_high = float(prev["high"])
    mother_low = float(prev["low"])
    close = float(last["close"])

    # √∂nce ger√ßekten outside mƒ±?
    outside = (last["high"] >= mother_high) and (last["low"] <= mother_low)
    if not outside:
        return False, False, {"outside": False}

    buffer = buffer_pips * PIP_VALUE
    bull = close > mother_high + buffer
    bear = close < mother_low - buffer

    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        vol_ok = (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return (
        bool(bull),
        bool(bear),
        {"outside": True, "mother_high": mother_high, "mother_low": mother_low},
    )


def horseshoe_concept_bull(
    df, base_bars=2, body_small=0.4, body_big=1.2, buffer_pips=10
):
    """
    Bullish horseshoe concept:
    - Son N (base_bars) mum k√º√ß√ºk g√∂vdeli (range'e g√∂re)
    - Son mum g√º√ßl√º ye≈üil ve √∂nceki N mumun en y√ºksek + buffer √ºzerinde kapanƒ±r
    """
    if len(df) < base_bars + 1:
        return False
    d = df.iloc[-(base_bars + 1) :].copy()
    rng = (d["high"] - d["low"]).replace(0, 1e-9)
    body = (d["close"] - d["open"]).abs()

    small_ok = (body.iloc[:-1] <= body_small * rng.iloc[:-1]).all()  # k√º√ß√ºk g√∂vdeler
    last_green = d["close"].iloc[-1] > d["open"].iloc[-1]  # ye≈üil kapanƒ±≈ü
    big_ok = body.iloc[-1] >= body_big * rng.iloc[-1]  # g√∂rece b√ºy√ºk g√∂vde

    prev_high = float(d["high"].iloc[:-1].max())
    break_ok = float(d["close"].iloc[-1]) > prev_high + buffer_pips * PIP_VALUE

    return bool(small_ok and last_green and big_ok and break_ok)


def horseshoe_concept_bear(
    df, base_bars=2, body_small=0.4, body_big=1.2, buffer_pips=10
):
    """
    Bearish horseshoe concept:
    - Son N mum k√º√ß√ºk g√∂vdeli
    - Son mum g√º√ßl√º kƒ±rmƒ±zƒ± ve √∂nceki N mumun en d√º≈ü√ºk - buffer altƒ±nda kapanƒ±r
    """
    if len(df) < base_bars + 1:
        return False
    d = df.iloc[-(base_bars + 1) :].copy()
    rng = (d["high"] - d["low"]).replace(0, 1e-9)
    body = (d["close"] - d["open"]).abs()

    small_ok = (body.iloc[:-1] <= body_small * rng.iloc[:-1]).all()
    last_red = d["close"].iloc[-1] < d["open"].iloc[-1]
    big_ok = body.iloc[-1] >= body_big * rng.iloc[-1]

    prev_low = float(d["low"].iloc[:-1].min())
    break_ok = float(d["close"].iloc[-1]) < prev_low - buffer_pips * PIP_VALUE

    return bool(small_ok and last_red and big_ok and break_ok)


def is_hammer(
    df, ratio=2.5, body_frac=0.35, close_pos_frac=0.6, top_wick_max_frac=0.25
):
    if len(df) < 1:
        return False
    last = df.iloc[-1]
    o, h, l, c = (
        float(last["open"]),
        float(last["high"]),
        float(last["low"]),
        float(last["close"]),
    )
    rng = max(h - l, 1e-9)
    body = abs(c - o)
    upper_wick = h - max(o, c)
    lower_wick = min(o, c) - l

    cond_long_wick = lower_wick >= ratio * body
    cond_small_body = body <= rng * body_frac
    cond_close_high = (
        c - min(o, c)
    ) >= body * close_pos_frac  # kapanƒ±≈ü g√∂vdenin √ºst tarafƒ±nda
    cond_short_upper = upper_wick <= rng * top_wick_max_frac

    return cond_long_wick and cond_small_body and cond_close_high and cond_short_upper


def is_inverted_hammer(
    df, ratio=2.5, body_frac=0.35, close_pos_frac=0.6, bot_wick_max_frac=0.25
):
    if len(df) < 1:
        return False
    last = df.iloc[-1]
    o, h, l, c = (
        float(last["open"]),
        float(last["high"]),
        float(last["low"]),
        float(last["close"]),
    )
    rng = max(h - l, 1e-9)
    body = abs(c - o)
    upper_wick = h - max(o, c)
    lower_wick = min(o, c) - l

    cond_long_wick = upper_wick >= ratio * body
    cond_small_body = body <= rng * body_frac
    cond_close_low = (
        max(o, c) - c
    ) >= body * close_pos_frac  # kapanƒ±≈ü g√∂vdenin alt tarafƒ±nda
    cond_short_lower = lower_wick <= rng * bot_wick_max_frac

    return cond_long_wick and cond_small_body and cond_close_low and cond_short_lower


def hammer_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 2:
        return False, False, {}
    prev = df.iloc[-2]  # hammer beklenen mum
    last = df.iloc[-1]  # teyit mumu

    is_ham = is_hammer(df.iloc[:-0]) or is_hammer(
        df.iloc[:-1]
    )  # son mum hammer olmayabilir; g√ºvenli yol:
    # en doƒüru yakla≈üƒ±m: prev‚Äôin hammer olup olmadƒ±ƒüƒ±nƒ± kontrol etmek
    is_prev_hammer = is_hammer(df.iloc[:-1])

    if not is_prev_hammer:
        return False, False, {"hammer": False}

    mother_high = float(prev["high"])
    mother_low = float(prev["low"])
    close = float(last["close"])

    buf = buffer_pips * PIP_VALUE
    bull = close > mother_high + buf
    bear = False  # hammer‚Äôda esas kƒ±rƒ±lƒ±m yukarƒ±

    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        vol_ok = (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok

    return bool(bull), bool(bear), {"hammer": True, "mother_high": mother_high}


def inverted_hammer_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 2:
        return False, False, {"inv_hammer": False}
    prev = df.iloc[-2]
    last = df.iloc[-1]

    is_prev_inv = is_inverted_hammer(df.iloc[:-1])
    if not is_prev_inv:
        return False, False, {"inv_hammer": False}

    mother_low = float(prev["low"])
    close = float(last["close"])

    buf = buffer_pips * PIP_VALUE
    bear = close < mother_low - buf
    bull = False

    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        vol_ok = (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and vol_ok

    return bool(bull), bool(bear), {"inv_hammer": True, "mother_low": mother_low}


def is_morning_star(df, body_frac=0.35, middle_close=True):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]
    # 1. mum ayƒ±
    bear1 = a["close"] < a["open"]
    # 2. mum k√º√ß√ºk g√∂vde
    rng_b = max(b["high"] - b["low"], 1e-9)
    body_b = abs(b["close"] - b["open"]) <= rng_b * body_frac
    # 3. mum boƒüa
    bull3 = c["close"] > c["open"]
    # teyit: 3. mum 1. mum g√∂vde ortasƒ±nƒ± ge√ßsin
    mid_a = (a["open"] + a["close"]) / 2.0
    confirm = c["close"] > mid_a if middle_close else bull3
    return bool(bear1 and body_b and bull3 and confirm)


def morning_star_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 4:
        return False, False, {}
    a, b, c, d = df.iloc[-4], df.iloc[-3], df.iloc[-2], df.iloc[-1]
    if not is_morning_star(df.iloc[:-1]):  # son mum teyit mumu
        return False, False, {"ms": False}
    mid_a = (a["open"] + a["close"]) / 2.0
    buf = buffer_pips * PIP_VALUE
    bull = float(d["close"]) > (mid_a + buf)
    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        bull = bull and (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
    return bool(bull), False, {"ms": True}


def is_evening_star(df, body_frac=0.35, middle_close=True):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]
    # 1. mum boƒüa
    bull1 = a["close"] > a["open"]
    # 2. mum k√º√ß√ºk g√∂vde
    rng_b = max(b["high"] - b["low"], 1e-9)
    body_b = abs(b["close"] - b["open"]) <= rng_b * body_frac
    # 3. mum ayƒ±
    bear3 = c["close"] < c["open"]
    # teyit: 3. mum 1. mum g√∂vde ortasƒ±nƒ±n altƒ±nda kapatsƒ±n
    mid_a = (a["open"] + a["close"]) / 2.0
    confirm = c["close"] < mid_a if middle_close else bear3
    return bool(bull1 and body_b and bear3 and confirm)


def evening_star_breakout(df, buffer_pips=10, vol_confirm=False):
    if len(df) < 4:
        return False, False, {}
    a, b, c, d = df.iloc[-4], df.iloc[-3], df.iloc[-2], df.iloc[-1]
    if not is_evening_star(df.iloc[:-1]):
        return False, False, {"es": False}
    mid_a = (a["open"] + a["close"]) / 2.0
    buf = buffer_pips * PIP_VALUE
    bear = float(d["close"]) < (mid_a - buf)
    if vol_confirm and "tick_volume" in df.columns and len(df) >= 20:
        bear = bear and (
            df["tick_volume"].iloc[-1] > df["tick_volume"].rolling(20).mean().iloc[-1]
        )
    return False, bool(bear), {"es": True}


def is_three_white_soldiers(
    df, min_body_frac=0.55, max_upper_wick_frac=0.35, require_higher_opens=True
):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]

    def ok_bull(x):
        return x["close"] > x["open"]

    def body(x):
        return abs(x["close"] - x["open"])

    def rng(x):
        return max(x["high"] - x["low"], 1e-9)

    def upper_wick(x):
        return x["high"] - max(x["open"], x["close"])

    cond_dir = ok_bull(a) and ok_bull(b) and ok_bull(c)
    cond_body = (
        body(a) >= rng(a) * min_body_frac
        and body(b) >= rng(b) * min_body_frac
        and body(c) >= rng(c) * min_body_frac
    )
    cond_wick = (
        upper_wick(a) <= rng(a) * max_upper_wick_frac
        and upper_wick(b) <= rng(b) * max_upper_wick_frac
        and upper_wick(c) <= rng(c) * max_upper_wick_frac
    )
    cond_progress = (b["close"] > a["close"]) and (c["close"] > b["close"])

    if require_higher_opens:
        # her bir sonraki a√ßƒ±lƒ±≈ü √∂nceki g√∂vdenin √ºst yarƒ±sƒ±nda/√ºst√ºnde
        mid_a = (a["open"] + a["close"]) / 2.0
        mid_b = (b["open"] + b["close"]) / 2.0
        cond_open = (b["open"] >= mid_a) and (c["open"] >= mid_b)
    else:
        cond_open = True

    return bool(cond_dir and cond_body and cond_wick and cond_progress and cond_open)


def three_white_soldiers_follow(df, buffer_pips=10):
    if len(df) < 4:
        return False
    if not is_three_white_soldiers(df.iloc[:-1]):  # son mum teyit olsun
        return False
    c = df.iloc[-2]  # √º√ß√ºnc√º asker
    d = df.iloc[-1]  # teyit mumu
    buf = buffer_pips * PIP_VALUE
    return bool(d["close"] > (c["close"] + buf))


def is_three_black_crows(
    df, min_body_frac=0.55, max_lower_wick_frac=0.35, require_lower_opens=True
):
    if len(df) < 3:
        return False
    a, b, c = df.iloc[-3], df.iloc[-2], df.iloc[-1]

    def ok_bear(x):
        return x["close"] < x["open"]

    def body(x):
        return abs(x["close"] - x["open"])

    def rng(x):
        return max(x["high"] - x["low"], 1e-9)

    def lower_wick(x):
        return min(x["open"], x["close"]) - x["low"]

    cond_dir = ok_bear(a) and ok_bear(b) and ok_bear(c)
    cond_body = (
        body(a) >= rng(a) * min_body_frac
        and body(b) >= rng(b) * min_body_frac
        and body(c) >= rng(c) * min_body_frac
    )
    cond_wick = (
        lower_wick(a) <= rng(a) * max_lower_wick_frac
        and lower_wick(b) <= rng(b) * max_lower_wick_frac
        and lower_wick(c) <= rng(c) * max_lower_wick_frac
    )
    cond_progress = (b["close"] < a["close"]) and (c["close"] < b["close"])

    if require_lower_opens:
        mid_a = (a["open"] + a["close"]) / 2.0
        mid_b = (b["open"] + b["close"]) / 2.0
        cond_open = (b["open"] <= mid_a) and (c["open"] <= mid_b)
    else:
        cond_open = True
    return bool(cond_dir and cond_body and cond_wick and cond_progress and cond_open)


def three_black_crows_follow(df, buffer_pips=10):
    if len(df) < 4:
        return False
    if not is_three_black_crows(df.iloc[:-1]):
        return False
    c = df.iloc[-2]  # √º√ß√ºnc√º karga
    d = df.iloc[-1]  # teyit mumu
    buf = buffer_pips * PIP_VALUE
    return bool(d["close"] < (c["close"] - buf))


def double_bottom_breakout(
    df, lookback=120, tol=0.005, min_gap=5, buffer_pips=10, vol_confirm=True
):
    """
    ƒ∞kili dip (W) ‚Äì boyun √ßizgisi √ºst√º kapanƒ±≈üta bullish kƒ±rƒ±lƒ±m verir.
    tol: diplerin e≈üitliƒüi i√ßin oransal tolerans (0.5%)
    min_gap: iki dip arasƒ±nda en az bar
    """
    d = df.iloc[-lookback:].copy()
    lows = d["low"].astype(float)
    highs = d["high"].astype(float)
    close = d["close"].astype(float)

    if len(d) < 30:
        return False, False, {}

    # yerel min/max (basit pivot)
    pl = (lows.shift(1) > lows) & (lows.shift(-1) > lows)
    ph = (highs.shift(1) < highs) & (highs.shift(-1) < highs)
    li = list(lows[pl].index)

    if len(li) < 2:
        return False, False, {}

    # son iki dip ve aralarƒ±ndaki tepe
    d2 = li[-1]
    d1 = None
    # d1'i, d2'den √∂nceki pivotlardan al ve arada min_gap bƒ±rak
    for idx in reversed(li[:-1]):
        if (d2 - idx).days is not None:
            # index datetime ise .days √ßalƒ±≈üƒ±r; deƒüilse bar sayƒ±sƒ± i√ßin:
            pass
        if d.index.get_loc(d2) - d.index.get_loc(idx) >= min_gap:
            d1 = idx
            break
    if d1 is None:
        return False, False, {}

    # aradaki tepe (neckline)
    mid_high = highs.loc[d1:d2]
    ph_mid = mid_high[(mid_high.shift(1) < mid_high) & (mid_high.shift(-1) < mid_high)]
    if ph_mid.empty:
        neckline = float(mid_high.max())
    else:
        neckline = float(ph_mid.iloc[-1])

    # diplerin e≈üitliƒüi
    L1, L2 = float(lows.loc[d1]), float(lows.loc[d2])
    base = max(1e-9, (L1 + L2) / 2.0)
    if abs(L1 - L2) / base > tol:
        return False, False, {}

    # kƒ±rƒ±lƒ±m (neckline √ºst√ºnde kapanƒ±≈ü)
    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bull = float(close.iloc[-1]) > neckline + buffer

    # hacim teyidi opsiyonel
    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and bool(vol_ok)

    meta = {
        "neckline": float(neckline),
        "low1": float(L1),
        "low2": float(L2),
        "close": float(close.iloc[-1]),
    }
    return bool(bull), False, meta


def double_top_breakout(
    df, lookback=120, tol=0.005, min_gap=5, buffer_pips=10, vol_confirm=True
):
    """
    ƒ∞kili tepe (M) ‚Äì boyun √ßizgisi altƒ± kapanƒ±≈üta bearish kƒ±rƒ±lƒ±m verir.
    """
    d = df.iloc[-lookback:].copy()
    lows = d["low"].astype(float)
    highs = d["high"].astype(float)
    close = d["close"].astype(float)

    if len(d) < 30:
        return False, False, {}

    # yerel min/max (basit pivot)
    ph = (highs.shift(1) < highs) & (highs.shift(-1) < highs)
    pl = (lows.shift(1) > lows) & (lows.shift(-1) > lows)
    hi = list(highs[ph].index)

    if len(hi) < 2:
        return False, False, {}

    t2 = hi[-1]
    t1 = None
    for idx in reversed(hi[:-1]):
        if d.index.get_loc(t2) - d.index.get_loc(idx) >= min_gap:
            t1 = idx
            break
    if t1 is None:
        return False, False, {}

    # aradaki dip (neckline)
    mid_low = lows.loc[t1:t2]
    pl_mid = mid_low[(mid_low.shift(1) > mid_low) & (mid_low.shift(-1) > mid_low)]
    if pl_mid.empty:
        neckline = float(mid_low.min())
    else:
        neckline = float(pl_mid.iloc[-1])

    # tepelerin e≈üitliƒüi
    H1, H2 = float(highs.loc[t1]), float(highs.loc[t2])
    base = max(1e-9, (H1 + H2) / 2.0)
    if abs(H1 - H2) / base > tol:
        return False, False, {}

    # kƒ±rƒ±lƒ±m (neckline altƒ±nda kapanƒ±≈ü)
    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bear = float(close.iloc[-1]) < neckline - buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and bool(vol_ok)

    meta = {
        "neckline": float(neckline),
        "high1": float(H1),
        "high2": float(H2),
        "close": float(close.iloc[-1]),
    }
    return False, bool(bear), meta


def head_shoulders_breakout(df, lookback=80, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    h, l = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # --- pivot tepeler/dipler
    s = h.values
    ph = np.r_[False, (s[1:-1] > s[:-2]) & (s[1:-1] > s[2:]), False]
    s = l.values
    pl = np.r_[False, (s[1:-1] < s[:-2]) & (s[1:-1] < s[2:]), False]
    ph_idx = d.index[ph]
    pl_idx = d.index[pl]
    if len(ph_idx) < 3 or len(pl_idx) < 2:
        return False, False  # bull, bear

    # son b√∂l√ºmdeki en y√ºksek tepe = head
    ph_idx = sorted(ph_idx)[-5:]
    head_i = max(ph_idx, key=lambda i: h.loc[i])
    left = [i for i in ph_idx if i < head_i]
    right = [i for i in ph_idx if i > head_i]
    if not left or not right:
        return False, False
    ls_i = max(left)  # sol omuz tepesi
    rs_i = min(right)  # saƒü omuz tepesi
    ls, hd, rs = float(h.loc[ls_i]), float(h.loc[head_i]), float(h.loc[rs_i])

    # omuz benzerliƒüi ve ba≈üƒ±n daha y√ºksek olmasƒ±
    if not (hd > ls and hd > rs and abs(ls - rs) <= 0.015 * hd):
        return False, False

    # omuzlar arasƒ± iki dipten boyun √ßizgisi (lineer fit)
    dips_between = [i for i in pl_idx if ls_i < i < rs_i]
    if len(dips_between) < 2:
        return False, False
    idx = np.array([d.index.get_loc(i) for i in dips_between[:2]], dtype=float)
    y = np.array([float(l.loc[i]) for i in dips_between[:2]], dtype=float)
    a, b = np.polyfit(idx, y, 1)
    x_last = float(d.index.size - 1)
    neckline_last = a * x_last + b

    buf = buffer_pips * PIP_VALUE
    # normal (beklenen) = a≈üaƒüƒ±; ters = yukarƒ±
    bear_break = close < (neckline_last - buf)
    bull_break = close > (neckline_last + buf)

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear_break = bear_break and bool(vol_ok)
        bull_break = bull_break and bool(vol_ok)

    return bool(bull_break), bool(bear_break)


def inverse_head_shoulders_breakout(df, lookback=80, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    h, l = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    s = h.values
    ph = np.r_[False, (s[1:-1] > s[:-2]) & (s[1:-1] > s[2:]), False]
    s = l.values
    pl = np.r_[False, (s[1:-1] < s[:-2]) & (s[1:-1] < s[2:]), False]
    ph_idx = d.index[ph]
    pl_idx = d.index[pl]
    if len(pl_idx) < 3 or len(ph_idx) < 2:
        return False, False

    head_i = min(pl_idx, key=lambda i: l.loc[i])  # en derin dip = head
    left = [i for i in pl_idx if i < head_i]
    right = [i for i in pl_idx if i > head_i]
    if not left or not right:
        return False, False
    ls_i = max(left)  # sol omuz dibi
    rs_i = min(right)  # saƒü omuz dibi
    ls, hd, rs = float(l.loc[ls_i]), float(l.loc[head_i]), float(l.loc[rs_i])

    if not (hd < ls and hd < rs and abs(ls - rs) <= 0.015 * max(ls, rs)):
        return False, False

    tops_between = [i for i in ph_idx if ls_i < i < rs_i]
    if len(tops_between) < 2:
        return False, False
    idx = np.array([d.index.get_loc(i) for i in tops_between[:2]], dtype=float)
    y = np.array([float(h.loc[i]) for i in tops_between[:2]], dtype=float)
    a, b = np.polyfit(idx, y, 1)
    x_last = float(d.index.size - 1)
    neckline_last = a * x_last + b

    buf = buffer_pips * PIP_VALUE
    # normal (beklenen) = yukarƒ±; ters = a≈üaƒüƒ±
    bull_break = close > (neckline_last + buf)
    bear_break = close < (neckline_last - buf)

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull_break = bull_break and bool(vol_ok)
        bear_break = bear_break and bool(vol_ok)

    return bool(bull_break), bool(bear_break)


# Daralan hayali √º√ßgende kƒ±rƒ±lƒ±m noktasƒ±nƒ± belirleyip sinyal verir
def triangle_symmetric_breakout(df, lookback=60, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    highs, lows = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # basit pivotlar
    ph = highs[(highs.shift(1) < highs) & (highs.shift(-1) < highs)]
    pl = lows[(lows.shift(1) > lows) & (lows.shift(-1) > lows)]
    if len(ph) < 2 or len(pl) < 2:
        return False, False, {}

    # √ºst/alt √ßizgi i√ßin lineer fit
    xh = np.arange(len(ph), dtype=float)
    xl = np.arange(len(pl), dtype=float)
    m_up, b_up = np.polyfit(
        (xh - xh.mean()) / (xh.std() + 1e-9), ph.values.astype(float), 1
    )
    m_dn, b_dn = np.polyfit(
        (xl - xl.mean()) / (xl.std() + 1e-9), pl.values.astype(float), 1
    )

    # simetrik √º√ßgen ≈üartƒ± (√ºst eƒüim negatif, alt eƒüim pozitif)
    if not (m_up < 0 and m_dn > 0):
        return False, False, {}

    # son bar i√ßin √ßizgi seviyeleri (normalize edilmi≈ü x‚âà0 kabul)
    upper_last = b_up
    lower_last = b_dn

    buffer = buffer_pips * PIP_VALUE
    bull = close > upper_last + buffer
    bear = close < lower_last - buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull, bear = bull and vol_ok, bear and vol_ok

    return (
        bool(bull),
        bool(bear),
        {"upper": float(upper_last), "lower": float(lower_last), "close": close},
    )


def triangle_ascending_breakout(
    df, lookback=60, flat_tol=0.002, buffer_pips=10, vol_confirm=True
):
    d = df.iloc[-lookback:].copy()
    highs, lows = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # yatay tepe (flat top) ve y√ºkselen dipler arƒ±yoruz
    top_spread = (highs.max() - highs.min()) / (highs.max() + 1e-9)
    rising_lows = lows.is_monotonic_increasing
    if not (top_spread < flat_tol and rising_lows):
        return False, False, {}

    flat_top = float(highs.max())
    buffer = buffer_pips * PIP_VALUE
    bull = close > flat_top + buffer
    # a≈üaƒüƒ± kƒ±rƒ±lƒ±m garanti deƒüil ama istersek:
    bear = False

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok

    return bool(bull), bool(bear), {"flat_top": flat_top, "close": close}


def triangle_descending_breakout(
    df, lookback=60, flat_tol=0.002, buffer_pips=10, vol_confirm=True
):
    d = df.iloc[-lookback:].copy()
    highs, lows = d["high"], d["low"]
    close = float(d["close"].iloc[-1])

    # yatay taban (flat bottom) ve al√ßalan tepeler
    bottom_spread = (lows.max() - lows.min()) / (lows.min() + 1e-9)
    falling_highs = highs.is_monotonic_decreasing
    if not (bottom_spread < flat_tol and falling_highs):
        return False, False, {}

    flat_bottom = float(lows.min())
    buffer = buffer_pips * PIP_VALUE
    bear = close < flat_bottom - buffer
    bull = False

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and vol_ok

    return bool(bull), bool(bear), {"flat_bottom": flat_bottom, "close": close}


def wedge_breakout(
    df,
    lookback=None,
    pivot_lb=None,
    min_touches=None,
    converge_tol=None,
    pretrend_lb=None,
    allow_counter=None,
):
    """
    Ger√ßek wedge (rising/falling) + kƒ±rƒ±lƒ±m tespiti.
    D√∂n√º≈ü: (bull_break, bear_break, meta)
    meta: {"kind": "rising"|"falling"|"none", "expected": "UP"|"DOWN"|None, "counter": bool}
    """
    if lookback is None:
        lookback = CONFIG["wedge_lookback"]
    if pivot_lb is None:
        pivot_lb = CONFIG["wedge_pivot_lb"]
    if min_touches is None:
        min_touches = CONFIG["wedge_min_touchers"]
    if converge_tol is None:
        converge_tol = CONFIG["wedge_converge_tol"]
    if pretrend_lb is None:
        pretrend_lb = CONFIG["wedge_pretrend_lb"]
    if allow_counter is None:
        allow_counter = CONFIG["wedge_allow_counter"]

    if len(df) < max(lookback, pretrend_lb) + 5:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    window = df.iloc[-lookback:].copy()
    closes = df["close"]

    # 1) Pivotlar
    highs = window["high"]
    lows = window["low"]
    ph = _pivot_highs(highs, pivot_lb)
    pl = _pivot_lows(lows, pivot_lb)
    hi_pts = highs[ph].dropna()
    lo_pts = lows[pl].dropna()
    if len(hi_pts) < min_touches or len(lo_pts) < min_touches:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    # 2) √úst/Alt √ßizgi regresyonu
    # x ekseni: 0..n-1 (pencere g√∂re relatif)
    x_hi = (hi_pts.index - window.index[0]).total_seconds()
    x_hi = (x_hi / max(x_hi.max(), 1)).values  # normalize
    y_hi = hi_pts.values
    a_hi, b_hi = np.polyfit(x_hi, y_hi, 1)  # √ºst √ßizgi eƒüim

    x_lo = (lo_pts.index - window.index[0]).total_seconds()
    x_lo = (x_lo / max(x_lo.max(), 1)).values
    y_lo = lo_pts.values
    a_lo, b_lo = np.polyfit(x_lo, y_lo, 1)  # alt √ßizgi eƒüim

    # 3) Takoz tipi
    kind = "none"
    if a_hi > 0 and a_lo > 0:
        kind = "rising"
    elif a_hi < 0 and a_lo < 0:
        kind = "falling"
    else:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    # 4) Daralma (band geni≈üliƒüi azalƒ±yor mu?)
    # ba≈ülangƒ±√ß-x=0, biti≈ü-x=1 varsayƒ±mƒ±yla band geni≈üliƒüi
    band_start = (a_hi * 0 + b_hi) - (a_lo * 0 + b_lo)
    band_end = (a_hi * 1 + b_hi) - (a_lo * 1 + b_lo)
    if band_start <= 0:  # g√ºvenlik
        return False, False, {"kind": "none", "expected": None, "counter": False}
    narrowing = (band_start - band_end) / band_start  # % azalma
    if narrowing < converge_tol:
        return False, False, {"kind": "none", "expected": None, "counter": False}

    # 5) Pre-trend (pencere √∂ncesi)
    pre = df.iloc[-(lookback + pretrend_lb) : -lookback]["close"]
    if len(pre) < 2:
        pretrend = 0.0
    else:
        pretrend = _lin_slope(pre)

    # Beklenen kƒ±rƒ±lƒ±m y√∂n√º (klasik)
    expected = "DOWN" if kind == "rising" else "UP"

    # 6) Kƒ±rƒ±lƒ±m kontrol√º (son kapanƒ±≈ü)
    last_close = window["close"].iloc[-1]
    # √ºst/alt √ßizgi son x=1 deƒüeri:
    upper_end = a_hi * 1 + b_hi
    lower_end = a_lo * 1 + b_lo
    bull_break = last_close > upper_end
    bear_break = last_close < lower_end

    # 7) Beklenen vs Kontra etiketi
    counter = False
    if bull_break and expected == "DOWN":
        counter = True
        if not allow_counter:
            bull_break = False
    if bear_break and expected == "UP":
        counter = True
        if not allow_counter:
            bear_break = False

    return (
        bool(bull_break),
        bool(bear_break),
        {"kind": kind, "expected": expected, "counter": counter},
    )


def channel_breakout(
    df, lookback=60, buffer_pips=10, parallel_tol=0.15, slope_eps=1e-9, vol_confirm=True
):
    """
    Paralel kanal (ascending/descending/horizontal) kƒ±rƒ±lƒ±m tespiti.
    close > √ºst √ßizgi + buffer ‚Üí bull, close < alt √ßizgi - buffer ‚Üí bear
    parallel_tol: √ºst-alt eƒüim farkƒ± i√ßin baƒüƒ±l tolerans (‚âà%15)
    """

    d = df.iloc[-lookback:].copy()
    if len(d) < lookback:
        return False, False, {"kind": "none"}

    highs = d["high"]
    lows = d["low"]
    close = float(d["close"].iloc[-1])

    # --- basit pivotlar (yerel tepe/dip)
    ph = highs[(highs.shift(1) < highs) & (highs.shift(-1) < highs)]
    pl = lows[(lows.shift(1) > lows) & (lows.shift(-1) > lows)]
    if len(ph) < 2 or len(pl) < 2:
        return False, False, {"kind": "none"}

    # --- √ºst/alt √ßizgiler i√ßin lineer fit
    xh = (
        (ph.index - ph.index[0]).total_seconds()
        if hasattr(ph.index, "tz") or hasattr(ph.index, "tzinfo")
        else np.arange(len(ph))
    )
    xl = (
        (pl.index - pl.index[0]).total_seconds()
        if hasattr(pl.index, "tz") or hasattr(pl.index, "tzinfo")
        else np.arange(len(pl))
    )
    xh = np.asarray(xh, dtype=float)
    xl = np.asarray(xl, dtype=float)

    a_up, b_up = np.polyfit(xh, ph.values.astype(float), 1)  # √ºst √ßizgi eƒüimi
    a_dn, b_dn = np.polyfit(xl, pl.values.astype(float), 1)  # alt √ßizgi eƒüimi

    # paralellik testi (baƒüƒ±l fark)
    denom = max(abs(a_up), abs(a_dn), slope_eps)
    if abs(a_up - a_dn) / denom > parallel_tol:
        return False, False, {"kind": "not_parallel"}

    # kanal tipi
    if a_up > 0 and a_dn > 0:
        kind = "ascending"
    elif a_up < 0 and a_dn < 0:
        kind = "descending"
    else:
        kind = "horizontal"

    # son bar i√ßin √ßizgi seviyeleri
    # zaman eksenini son bar‚Äôa normalize edelim
    last_x = max(xh[-1], xl[-1])  # yakƒ±nsama i√ßin kabaca
    upper_last = a_up * last_x + b_up
    lower_last = a_dn * last_x + b_dn

    # tamponu fiyata √ßevir (pip)
    buffer = buffer_pips * PIP_VALUE

    bull = close > upper_last + buffer
    bear = close < lower_last - buffer

    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return (
        bool(bull),
        bool(bear),
        {
            "kind": kind,
            "upper": float(upper_last),
            "lower": float(lower_last),
            "close": float(close),
            "slope_up": float(a_up),
            "slope_dn": float(a_dn),
        },
    )


def cup_breakout(df, lookback=120, rim_tol=0.01, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    close = d["close"].astype(float).values
    if len(close) < 30:
        return False, False, {}

    L = len(close)
    third = max(10, L // 3)
    left_rim = close[:third].max()
    right_rim = close[-third:].max()
    rim = max(left_rim, right_rim)
    trough = float(close.argmin())
    trough = float(close[int(trough)])

    if rim <= trough:
        return False, False, {}
    if abs(left_rim - right_rim) / rim > rim_tol:
        return False, False, {}

    x = np.arange(L, dtype=float)
    a1 = np.polyfit(x[:third], close[:third], 1)[0]  # sol taraf d√º≈ü√º≈ü
    a2 = np.polyfit(x[-third:], close[-third:], 1)[0]  # saƒü taraf y√ºkseli≈ü
    if not (a1 < 0 and a2 > 0):
        return False, False, {}

    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bull = float(close[-1]) > rim + buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and bool(vol_ok)

    return (
        bool(bull),
        False,
        {"rim": float(rim), "trough": float(trough), "close": float(close[-1])},
    )


def dome_breakout(df, lookback=120, rim_tol=0.01, buffer_pips=10, vol_confirm=True):
    d = df.iloc[-lookback:].copy()
    close = d["close"].astype(float).values
    if len(close) < 30:
        return False, False, {}

    L = len(close)
    third = max(10, L // 3)
    left_rim = close[:third].min()
    right_rim = close[-third:].min()
    rim = min(left_rim, right_rim)
    peak = float(close.max())

    if peak <= rim:
        return False, False, {}
    if abs(left_rim - right_rim) / max(1e-9, abs(rim)) > rim_tol:
        return False, False, {}

    x = np.arange(L, dtype=float)
    a1 = np.polyfit(x[:third], close[:third], 1)[0]  # sol taraf y√ºkseli≈ü
    a2 = np.polyfit(x[-third:], close[-third:], 1)[0]  # saƒü taraf d√º≈ü√º≈ü
    if not (a1 > 0 and a2 < 0):
        return False, False, {}

    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bear = float(close[-1]) < rim - buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bear = bear and bool(vol_ok)

    return (
        False,
        bool(bear),
        {"rim": float(rim), "peak": float(peak), "close": float(close[-1])},
    )


def cup_handle_breakout(
    df,
    lookback=160,
    rim_tol=0.01,
    handle_min=5,
    handle_max=25,
    handle_ret_min=0.2,
    handle_ret_max=0.5,
    buffer_pips=10,
    vol_confirm=True,
):
    bull_cup, _, meta = cup_breakout(
        df, lookback=lookback, rim_tol=rim_tol, buffer_pips=0, vol_confirm=False
    )
    if not bull_cup:
        return False, False, {}

    d = df.iloc[-lookback:].copy()
    close = d["close"].astype(float).values
    rim = meta["rim"]
    trough = meta["trough"]

    L = len(close)
    third = max(10, L // 3)
    recent_peak_idx = np.argmax(close[-(third * 2) :]) + (L - third * 2)
    recent_peak = close[recent_peak_idx]
    if abs(recent_peak - rim) / rim > rim_tol:
        return False, False, {}

    handle = close[recent_peak_idx + 1 :]
    if len(handle) < handle_min or len(handle) > handle_max:
        return False, False, {}

    cup_h = rim - trough
    if cup_h <= 0:
        return False, False, {}

    pullback = recent_peak - handle.min()
    ret = pullback / cup_h
    if not (handle_ret_min <= ret <= handle_ret_max):
        return False, False, {}

    PIP_VALUE = 0.01
    buffer = buffer_pips * PIP_VALUE
    bull = float(close[-1]) > rim + buffer

    if vol_confirm and "tick_volume" in d.columns:
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and bool(vol_ok)

    return (
        bool(bull),
        False,
        {"rim": float(rim), "trough": float(trough), "close": float(close[-1])},
    )


def abcd_strict(
    df,
    lookback=120,
    retrace=0.618,
    ext=1.272,
    tol=0.03,
    confirm_break=False,
    buffer_pips=10,
):
    """
    AB=CD (harmonik) ‚Äì BC ~ 0.618*AB, CD ~ 1.272*BC.
    D noktasƒ± tamamlandƒ±ƒüƒ±nda sinyal verir. ƒ∞steƒüe baƒülƒ± olarak D sonrasƒ±
    ters y√∂nde k√º√ß√ºk bir kƒ±rƒ±lƒ±m (reversal) teyidi aranabilir.
    D√∂nd√ºr√ºr: (bull, bear)
    """
    d = df.iloc[-lookback:].copy()
    h, l = d["high"], d["low"]
    c = float(d["close"].iloc[-1])

    # --- basit pivotlar (tepe/dip)
    s = h.values
    ph = np.r_[False, (s[1:-1] > s[:-2]) & (s[1:-1] > s[2:]), False]
    s = l.values
    pl = np.r_[False, (s[1:-1] < s[:-2]) & (s[1:-1] < s[2:]), False]
    piv_hi = d.index[ph]
    piv_lo = d.index[pl]
    if len(piv_hi) < 2 or len(piv_lo) < 2:
        return False, False

    # --- son 6‚Äì8 pivottan AB=CD dizilimi ara (‚Ä¶A-B-C-D)
    piv = sorted(list({*piv_hi, *piv_lo}), key=lambda i: d.index.get_loc(i))[-8:]

    bull = bear = False
    buf = buffer_pips * PIP_VALUE

    def near(x, y, rel=tol):
        return abs(x - y) <= rel * max(abs(y), 1e-9)

    # her 4‚Äôl√º ardƒ±≈üƒ±k pivotu dene
    for i in range(len(piv) - 3):
        A, B, C, D = piv[i : i + 4]
        PA, PB, PC, PD = (
            float(d.loc[A, "close"]),
            float(d.loc[B, "close"]),
            float(d.loc[C, "close"]),
            float(d.loc[D, "close"]),
        )

        AB = PB - PA
        BC = PC - PB
        CD = PD - PC

        # YUKARI trendli varyant (AB>0, BC<0, CD>0) ‚Üí biti≈üte d√º≈ü√º≈ü beklenen AB=CD (bearish)
        if AB > 0 and BC < 0 and CD > 0:
            bc_ok = near(abs(BC), retrace * abs(AB))
            cd_ok = near(abs(CD), ext * abs(BC))
            if bc_ok and cd_ok:
                if not confirm_break:
                    bear = True
                else:
                    # D sonrasƒ± k√º√ß√ºk bir a≈üaƒüƒ± kƒ±rƒ±lƒ±m teyidi
                    bear = c < (PD - buf)
                # devam etmeden √∂nce daha g√ºncel bir e≈üle≈üme var mƒ± diye aramaya devam edebiliriz
        # A≈ûAƒûI trendli varyant (AB<0, BC>0, CD<0) ‚Üí biti≈üte y√ºkseli≈ü beklenen AB=CD (bullish)
        if AB < 0 and BC > 0 and CD < 0:
            bc_ok = near(abs(BC), retrace * abs(AB))
            cd_ok = near(abs(CD), ext * abs(BC))
            if bc_ok and cd_ok:
                if not confirm_break:
                    bull = True
                else:
                    bull = c > (PD + buf)

    return bool(bull), bool(bear)


def wolfe_breakout(df, lookback=120, buffer_pips=10, tol=None, vol_confirm=True):
    """
    Wolfe Wave breakout:
      - Bullish: falling channel tipi dalga, 5 olu≈ütuktan sonra close > line(1-4)+buffer
      - Bearish: rising channel tipi dalga, 5 sonrasƒ± close < line(1-4)-buffer
    return: (bull, bear, meta)
    """
    d = df.iloc[-lookback:].copy()
    if tol is None:
        tol = CONFIG.get("wolfe_tol", 0.02)

    h, l = d["high"].values, d["low"].values
    c = float(d["close"].iloc[-1])
    idx = d.index

    # --- kaba pivotlar (yerel tepe/dip)
    ph = np.r_[False, (h[1:-1] > h[:-2]) & (h[1:-1] > h[2:]), False]
    pl = np.r_[False, (l[1:-1] < l[:-2]) & (l[1:-1] < l[2:]), False]
    piv_hi = np.where(ph)[0]
    piv_lo = np.where(pl)[0]
    if len(piv_hi) + len(piv_lo) < 5:
        return False, False, {"kind": "none"}

    # pivotlarƒ± zaman sƒ±rasƒ±na g√∂re topla (son 10‚Äì12 taneden ara)
    piv = sorted(list(set(piv_hi.tolist() + piv_lo.tolist())))[-12:]
    if len(piv) < 5:
        return False, False, {"kind": "none"}

    bull = bear = False
    meta = {"kind": "none"}
    buf = buffer_pips * PIP_VALUE

    def line_y(x0, y0, x1, y1, xq):
        # x: bar index (0..n-1)
        if x1 == x0:
            return y0
        m = (y1 - y0) / (x1 - x0)
        return y0 + m * (xq - x0)

    # Wolfe ≈üablonu arayƒ±≈üƒ±:
    # Bullish: 1 (tepe) ‚Äì 2 (dip) ‚Äì 3 (tepe) ‚Äì 4 (dip) ‚Äì 5 (alt sarkma) ~ d√º≈üen kanal
    # Bearish: 1 (dip) ‚Äì 2 (tepe) ‚Äì 3 (dip) ‚Äì 4 (tepe) ‚Äì 5 (√ºst sarkma) ~ y√ºkselen kanal
    # Son noktadan (5) sonra 1‚Äì4 hattƒ±nƒ±n kƒ±rƒ±lmasƒ± sinyal.

    # son 8 ardƒ±≈üƒ±k pivot dizilerinden dene
    for i in range(len(piv) - 4):
        p1, p2, p3, p4, p5 = piv[i : i + 5]
        # sƒ±ra korunmalƒ±
        if not (p1 < p2 < p3 < p4 < p5):
            continue

        P1c, P2c, P3c, P4c, P5c = d["close"].iloc[[p1, p2, p3, p4, p5]].astype(float)

        # Bullish aday (d√º≈üen yapƒ±: P1>P3>P5 ve P2>P4)
        bull_shape = (P1c > P3c > P5c) and (P2c > P4c)
        # Bearish aday (y√ºkselen yapƒ±: P1<P3<P5 ve P2<P4)
        bear_shape = (P1c < P3c < P5c) and (P2c < P4c)

        # Kanal eƒüimlerinin yakƒ±nlƒ±ƒüƒ± (1‚Äì3‚Äì5 ile 2‚Äì4 arasƒ±nda eƒüim farkƒ± k√º√ß√ºk)
        x = np.array([p1, p3, p5], dtype=float)
        y_top = np.array([P1c, P3c, P5c], dtype=float)
        mt = np.polyfit(x, y_top, 1)[0]
        x2 = np.array([p2, p4], dtype=float)
        y_bot = np.array([P2c, P4c], dtype=float)
        mb = np.polyfit(x2, y_bot, 1)[0] if len(x2) == 2 else mt
        parallel_ok = abs(abs(mt) - abs(mb)) <= tol * max(1e-6, abs(mt) + abs(mb))

        if not parallel_ok:
            continue

        # 1‚Äì4 hattƒ±
        x14_0, x14_1 = float(p1), float(p4)
        y14_0, y14_1 = P1c, P4c
        last_x = float(len(d) - 1)
        line14_now = line_y(x14_0, y14_0, x14_1, y14_1, last_x)

        if bull_shape:
            # 5‚Äôten sonra yukarƒ± kƒ±rƒ±lƒ±m
            bull_break = c > (line14_now + buf)
            if bull_break:
                bull = True
                meta = {
                    "kind": "bullish",
                    "p": [int(p1), int(p2), int(p3), int(p4), int(p5)],
                    "line14": float(line14_now),
                }
        if bear_shape:
            # 5‚Äôten sonra a≈üaƒüƒ± kƒ±rƒ±lƒ±m
            bear_break = c < (line14_now - buf)
            if bear_break:
                bear = True
                meta = {
                    "kind": "bearish",
                    "p": [int(p1), int(p2), int(p3), int(p4), int(p5)],
                    "line14": float(line14_now),
                }

    # Hacim teyidi istenirse
    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    return bool(bull), bool(bear), meta


def po3_signal(
    df,
    lookback=80,
    box_lb=20,
    box_tol=0.002,
    spike_pips=20,
    disp_atr=1.0,
    vol_confirm=True,
):
    """
    PO3 (Power of Three) tespiti:
      - bull: √∂nce kutu, a≈üaƒüƒ± stop-hunt (spike), sonra yukarƒ± g√º√ßl√º close
      - bear: √∂nce kutu, yukarƒ± stop-hunt (spike), sonra a≈üaƒüƒ± g√º√ßl√º close
    """

    d = df.iloc[-lookback:].copy()
    c = float(d["close"].iloc[-1])
    h = d["high"].values
    l = d["low"].values

    # --- 1) Kutu (dar aralƒ±k)
    box = d.iloc[-(box_lb + 5) : -5] if len(d) >= box_lb + 5 else d.iloc[:-5]
    if box.empty:
        return False, False, {"stage": "none"}
    box_hi = float(box["high"].max())
    box_lo = float(box["low"].min())
    box_mid = (box_hi + box_lo) / 2.0
    cond_box = (box_hi - box_lo) / max(1e-9, box_mid) <= box_tol

    if not cond_box:
        return False, False, {"stage": "no_box"}

    # --- 2) Manip√ºlasyon (son 5 mumda kutu DI≈ûINA spike)
    last5 = d.iloc[-5:]
    buf = spike_pips * PIP_VALUE
    # bullish senaryo: kutu altƒ± altƒ±na spike
    bull_spike = last5["low"].min() < box_lo - buf
    # bearish: kutu √ºst√º √ºst√ºne spike
    bear_spike = last5["high"].max() > box_hi + buf

    # --- 3) Displacement kƒ±rƒ±lƒ±m (son mum)
    # ATR (varsa) ile g√∂vde g√ºc√º
    if "atr" in d.columns:
        atr = float(d["atr"].iloc[-1])
    else:
        # hƒ±zlƒ± ATR ~ True Range'in 14 ortalamasƒ±
        tr = np.maximum(h[1:], l[1:]) - np.minimum(h[1:], l[1:])
        atr = (
            float(np.mean(tr[-14:]))
            if len(tr) >= 14
            else float(np.mean(tr)) if len(tr) > 0 else 0.0
        )

    body = abs(float(d["close"].iloc[-1]) - float(d["open"].iloc[-1]))
    power_ok = body >= disp_atr * max(1e-9, atr)

    bull_break = bull_spike and (c > box_hi + buf) and power_ok
    bear_break = bear_spike and (c < box_lo - buf) and power_ok

    # Hacim teyidi (isteƒüe baƒülƒ±)
    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull_break = bull_break and vol_ok
        bear_break = bear_break and vol_ok

    meta = {
        "stage": "done" if (bull_break or bear_break) else "waiting",
        "box_hi": box_hi,
        "box_lo": box_lo,
        "spike_pips": spike_pips,
        "atr": atr,
    }
    return bool(bull_break), bool(bear_break), meta


def quasimodo_breakout(df, lookback=80, retouch_pips=12, vol_confirm=True):
    """
    QML (Quasimodo) kƒ±rƒ±lƒ±m/retouch tespiti.
    - Bearish: H1 -> H2 (HH) -> L2 (LL) yapƒ±sƒ± ve close ‚âà H1 (retouch) => bear=True
    - Bullish: L1 -> L2 (LL) -> H2 (HH) yapƒ±sƒ± ve close ‚âà L1 (retouch) => bull=True
    """
    d = df.iloc[-lookback:].copy()
    if len(d) < 10:
        return False, False, {}

    h, l, c = d["high"], d["low"], d["close"]

    # basit pivotlar
    ph = (h.shift(1) < h) & (h.shift(-1) < h)  # pivot high
    pl = (l.shift(1) > l) & (l.shift(-1) > l)  # pivot low
    H = h[ph]
    L = l[pl]
    if len(H) < 2 or len(L) < 2:
        return False, False, {}

    # --- Bearish QML: H1 < H2 (HH) ve H2'den sonra L2 < L1 (LL)
    bear = False
    qml_bear = None
    # son iki pivot high: H1, H2
    h2i = H.index[-1]
    h1i = H.index[-2]
    # H2 sonrasƒ± son pivot low: L2 ; H2 √∂ncesi son pivot low: L1
    L_after = L[L.index > h2i]
    L_before = L[L.index < h2i]
    if len(L_after) >= 1 and len(L_before) >= 1:
        l2i = L_after.index[-1]
        l1i = L_before.index[-1]
        cond_struct_bear = (h.loc[h2i] > h.loc[h1i]) and (l.loc[l2i] < l.loc[l1i])
        qml_bear = float(h.loc[h1i])  # left-shoulder seviyesi
        # retouch yakƒ±nlƒ±ƒüƒ± (pip)
        tol = retouch_pips * PIP_VALUE
        retouch_bear = c.iloc[-1] <= qml_bear + tol and c.iloc[-1] >= qml_bear - 2 * tol
        bear = bool(cond_struct_bear and retouch_bear)

    # --- Bullish QML: L1 > L2 (LL) ve L2'den sonra H2 > H1 (HH)
    bull = False
    qml_bull = None
    l2i = L.index[-1]
    l1i = L.index[-2]
    H_after = H[H.index > l2i]
    H_before = H[H.index < l2i]
    if len(H_after) >= 1 and len(H_before) >= 1:
        h2i_b = H_after.index[-1]
        h1i_b = H_before.index[-1]
        cond_struct_bull = (l.loc[l2i] < l.loc[l1i]) and (h.loc[h2i_b] > h.loc[h1i_b])
        qml_bull = float(l.loc[l1i])  # left-shoulder low seviyesi
        tol = retouch_pips * PIP_VALUE
        retouch_bull = c.iloc[-1] >= qml_bull - tol and c.iloc[-1] <= qml_bull + 2 * tol
        bull = bool(cond_struct_bull and retouch_bull)

    # opsiyonel hacim teyidi
    if vol_confirm and ("tick_volume" in d.columns):
        vol_ok = (
            d["tick_volume"].iloc[-1] > d["tick_volume"].rolling(20).mean().iloc[-1]
        )
        bull = bull and vol_ok
        bear = bear and vol_ok

    meta = {
        "qml_bear_level": qml_bear,
        "qml_bull_level": qml_bull,
        "close": float(c.iloc[-1]),
    }
    return bull, bear, meta


# 21. Three Sweep Concept
def three_sweep(data):
    if len(data) < 6:
        return False, False
    highs = data["high"][-6:]
    lows = data["low"][-6:]
    bull = lows.iloc[-1] < lows.iloc[-2] < lows.iloc[-3]
    bear = highs.iloc[-1] > highs.iloc[-2] > highs.iloc[-3]
    return bull, bear


# ‚úÖ ALIAS
def three_sweep_concept(data):
    return three_sweep(data)


# ========= Triangles/Wedges helpers are above =========


# ========= Aggregate =========
def generate_signals(df: pd.DataFrame) -> pd.DataFrame:
    d = _prep(df)
    last_index = d.index[-1]  # sadece son barƒ± kullan

    # ‚¨áÔ∏è Time fix
    if not isinstance(last_index, pd.Timestamp):
        try:
            last_index = pd.to_datetime(last_index, errors="coerce")
        except Exception as e:
            # print("‚ö†Ô∏è DEBUG time conversion error:", e, last_index)
            return pd.DataFrame()

    # print("üîç DEBUG last_index type:", type(last_index), last_index)
    parts = []

    # ========= Candle / Bar formations =========
    ema20 = d["close"].ewm(span=20, adjust=False).mean()
    bull, bear = engulfing_strong(d, ema=ema20, use_volume=True, strong=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "engulf_strong_bull": [bull],
                "engulf_strong_bear": [bear],
            }
        )
    )

    ema20 = d["close"].ewm(span=20, adjust=False).mean()
    bull, bear = pinbar_strict(d, ema=ema20, use_volume=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "pinbar_strict_bull": [bull],
                "pinbar_strict_bear": [bear],
            }
        )
    )

    bull, bear, meta_ib = inside_chain_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "inside_break_bull": [bull],
                "inside_break_bear": [bear],
                # istersen metayƒ± da loglamak i√ßin:
                # "inside_count": [meta_ib["inside_count"]],
            }
        )
    )

    # Basit outside i≈üareti
    parts.append(
        pd.DataFrame({"time": [last_index], "outside_bar": [is_outside_bar(d)]})
    )
    # Outside kƒ±rƒ±lƒ±m sinyali
    ob_bull, ob_bear, ob_meta = outside_breakout(d, buffer_pips=10, vol_confirm=True)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "outside_break_bull": [ob_bull],
                "outside_break_bear": [ob_bear],
            }
        )
    )

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "horseshoe_concept_bull": [horseshoe_concept_bull(d)],
                "horseshoe_concept_bear": [horseshoe_concept_bear(d)],
            }
        )
    )

    # Hammer / Inverted Hammer basit i≈üaretleri
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "hammer_mark": [is_hammer(d)],
                "inv_hammer_mark": [is_inverted_hammer(d)],
            }
        )
    )

    # Kƒ±rƒ±lƒ±m teyitleri
    h_bull, h_bear, _ = hammer_breakout(d, buffer_pips=10, vol_confirm=True)
    ih_bull, ih_bear, _ = inverted_hammer_breakout(d, buffer_pips=10, vol_confirm=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "hammer_break_bull": [h_bull],
                "hammer_break_bear": [h_bear],  # genelde False
                "inv_hammer_break_bull": [ih_bull],  # genelde False
                "inv_hammer_break_bear": [ih_bear],
            }
        )
    )

    # Morning/Evening Star i≈üaretleri (3 mum morfolojisi)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "morning_star_mark": [is_morning_star(d)],
                "evening_star_mark": [is_evening_star(d)],
            }
        )
    )

    # Kƒ±rƒ±lƒ±m teyitleri (sonraki mum)
    ms_bull, ms_bear, _ = morning_star_breakout(d, buffer_pips=10, vol_confirm=True)
    es_bull, es_bear, _ = evening_star_breakout(d, buffer_pips=10, vol_confirm=True)

    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "morning_star_break_bull": [ms_bull],  # beklenen: True/False
                "evening_star_break_bear": [es_bear],  # beklenen: True/False
            }
        )
    )

    # Three White Soldiers / Three Black Crows (g√º√ßl√º)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "three_white_soldiers_mark": [is_three_white_soldiers(d)],
                "three_black_crows_mark": [is_three_black_crows(d)],
                "three_white_soldiers_follow": [three_white_soldiers_follow(d)],
                "three_black_crows_follow": [three_black_crows_follow(d)],
            }
        )
    )

    # ========= Chart Patterns =========
    bull, bear, _ = double_bottom_breakout(d, lookback=120, tol=0.005, buffer_pips=10)
    parts.append(
        pd.DataFrame({"time": [last_index], "double_bottom_break_bull": [bull]})
    )

    bull, bear, _ = double_top_breakout(d, lookback=120, tol=0.005, buffer_pips=10)
    parts.append(pd.DataFrame({"time": [last_index], "double_top_break_bear": [bear]}))

    # OBO: normal = bear, counter = bull
    bull, bear = head_shoulders_breakout(d, lookback=80, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "head_shoulders_break_bear": [bear],  # beklenen
                "head_shoulders_counter_bull": [bull],  # TERS kƒ±rƒ±lƒ±m
            }
        )
    )

    # TOBO: normal = bull, counter = bear
    bull, bear = inverse_head_shoulders_breakout(d, lookback=80, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "inverse_head_shoulders_break_bull": [bull],  # beklenen
                "inverse_head_shoulders_counter_bear": [bear],  # TERS kƒ±rƒ±lƒ±m
            }
        )
    )

    bull, bear, _ = triangle_symmetric_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "triangle_sym_break_bull": [bull],
                "triangle_sym_break_bear": [bear],
            }
        )
    )

    bull, bear, _ = triangle_ascending_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame({"time": [last_index], "triangle_asc_break_bull": [bull]})
    )

    bull, bear, _ = triangle_descending_breakout(d, lookback=60, buffer_pips=10)
    parts.append(
        pd.DataFrame({"time": [last_index], "triangle_desc_break_bear": [bear]})
    )

    bull, bear, meta_w = wedge_breakout(d)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "wedge_break_bull": [bull],
                "wedge_break_bear": [bear],
            }
        )
    )

    bull, bear, meta_ch = channel_breakout(
        d, lookback=60, buffer_pips=10, parallel_tol=0.15
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "channel_break_bull": [bull],
                "channel_break_bear": [bear],
                # istersen meta‚Äôyƒ± da sakla:
                # "channel_kind": [meta_ch.get("kind","none")]
            }
        )
    )

    bull, bear, _ = cup_breakout(d, lookback=120, rim_tol=0.01, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {"time": [last_index], "cup_break_bull": [bull], "cup_break_bear": [False]}
        )
    )

    bull, bear, _ = dome_breakout(d, lookback=120, rim_tol=0.01, buffer_pips=10)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "dome_break_bull": [False],
                "dome_break_bear": [bear],
            }
        )
    )

    bull, bear, _ = cup_handle_breakout(
        d,
        lookback=160,
        rim_tol=0.01,
        handle_min=5,
        handle_max=25,
        handle_ret_min=0.2,
        handle_ret_max=0.5,
        buffer_pips=10,
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "cup_handle_bull": [bull],
                "cup_handle_bear": [False],
            }
        )
    )

    bull, bear = abcd_strict(
        d,
        lookback=120,
        retrace=0.618,
        ext=1.272,
        tol=0.03,
        confirm_break=False,
        buffer_pips=10,
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "abcd_strict_bull": [bull],
                "abcd_strict_bear": [bear],
            }
        )
    )

    bull, bear, meta_wv = wolfe_breakout(
        d, lookback=120, buffer_pips=10, vol_confirm=True
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "wolfe_break_bull": [bull],
                "wolfe_break_bear": [bear],
                # istersen meta:
                # "wolfe_kind": [meta_wv.get("kind","none")]
            }
        )
    )

    bull, bear, meta_po3 = po3_signal(
        d,
        lookback=80,
        box_lb=20,
        box_tol=0.002,
        spike_pips=20,
        disp_atr=1.0,
        vol_confirm=True,
    )
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "po3_bull": [bull],
                "po3_bear": [bear],
                # "po3_box_hi": [meta_po3["box_hi"]], # istersen meta da saklayabilirsin
                # "po3_box_lo": [meta_po3["box_lo"]],
            }
        )
    )

    bull, bear, _ = quasimodo_breakout(d, lookback=80, retouch_pips=12)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "qml_bull": [bull],
                "qml_bear": [bear],
            }
        )
    )

    bull, bear = three_sweep_concept(d)
    parts.append(
        pd.DataFrame(
            {
                "time": [last_index],
                "three_sweep_bull": [bull],
                "three_sweep_bear": [bear],
            }
        )
    )

    # ========= Combine all signals =========
    signals = pd.concat(parts, axis=1)

    # duplicate kolonlarƒ± temizle
    signals = signals.loc[:, ~signals.columns.duplicated()]

    # time kolonunu datetime garantiye al
    if "time" in signals.columns:
        signals["time"] = pd.to_datetime(signals["time"], errors="coerce")
        signals = signals.dropna(subset=["time"])  # bo≈ü varsa at
        signals.set_index("time", inplace=True)

    # sadece formasyon kolonlarƒ±nƒ± bool yap
    for col in signals.columns:
        if col != "score":
            signals[col] = signals[col].fillna(False).astype(bool)

    # score hesapla
    signals["score"] = signals.astype(int).sum(axis=1)

    # üü¢ DEBUG son tabloyu yazdƒ±r
    # print("üü¢ DEBUG Son mum sinyal tablosu:")
    # print(signals.tail(1).T)
    # print("WEDGE:", signals[["wedge_break_bull", "wedge_break_bear"]].tail(1).T)
    return signals


bullish_keys = {
    "engulf_strong_bull",
    "pinbar_strict_bull",
    "inside_break_bull",
    "outside_break_bull",
    "hammer_break_bull",
    "inv_hammer_break_bull",
    "morning_star_break_bull",
    "three_white_soldiers_follow",
    "double_bottom_break_bull",
    "head_shoulders_counter_bull",
    "triangle_sym_break_bull",
    "triangle_asc_break_bull",
    "wedge_break_bull",
    "channel_break_bull",
    "cup_break_bull",
    "cup_handle_bull",
    "dome_break_bull",
    "abcd_strict_bull",
    "wolfe_break_bull",
    "po3_bull",
    "qml_bull",
    "three_sweep_bull",
}
bearish_keys = {
    "engulf_strong_bear",
    "pinbar_strict_bear",
    "inside_break_bear",
    "outside_break_bear",
    "hammer_break_bear",
    "inv_hammer_break_bear",
    "evening_star_break_bear",
    "three_black_crows_follow",
    "double_top_break_bear",
    "head_shoulders_break_bear",
    "triangle_sym_break_bear",
    "triangle_desc_break_bear",
    "wedge_break_bear",
    "channel_break_bear",
    "cup_break_bear",
    "cup_handle_bear",
    "dome_break_bear",
    "abcd_strict_bear",
    "wolfe_break_bear",
    "po3_bear",
    "qml_bear",
    "three_sweep_bear",
}
FORMATION_LABELS = {
    "engulf_strong_bull": "Engulf (Bull)",
    "engulf_strong_bear": "Engulf (Bear)",
    "pinbar_strict_bull": "Pin Bar (Bull)",
    "pinbar_strict_bear": "Pin Bar (Bear)",
    "inside_break_bull": "Inside Break (Up)",
    "inside_break_bear": "Inside Break (Down)",
    "outside_break_bull": "Outside Break (Up)",
    "outside_break_bear": "Outside Break (Down)",
    "hammer_break_bull": "Hammer Break",
    "inv_hammer_break_bear": "Inverted Hammer Break",
    "morning_star_break_bull": "Morning Star",
    "evening_star_break_bear": "Evening Star",
    "three_white_soldiers_follow": "3 White Soldiers",
    "three_black_crows_follow": "3 Black Crows",
    "double_bottom_break_bull": "Double Bottom",
    "double_top_break_bear": "Double Top",
    "head_shoulders_counter_bull": "H&S (Counter Up)",
    "head_shoulders_break_bear": "H&S (Break Down)",
    "triangle_sym_break_bull": "Sym Triangle (Up)",
    "triangle_sym_break_bear": "Sym Triangle (Down)",
    "triangle_asc_break_bull": "Asc Triangle (Up)",
    "triangle_desc_break_bear": "Desc Triangle (Down)",
    "wedge_break_bull": "Wedge (Up)",
    "wedge_break_bear": "Wedge (Down)",
    "channel_break_bull": "Channel (Up)",
    "channel_break_bear": "Channel (Down)",
    "cup_break_bull": "Cup (Break Up)",
    "cup_break_bear": "Cup (Break Down)",
    "cup_handle_bull": "Cup&Handle (Up)",
    "cup_handle_bear": "Cup&Handle (Down)",
    "dome_break_bull": "Dome (Break Up)",
    "dome_break_bear": "Dome (Break Down)",
    "abcd_strict_bull": "AB=CD (Bull)",
    "abcd_strict_bear": "AB=CD (Bear)",
    "wolfe_break_bull": "Wolfe (Up)",
    "wolfe_break_bear": "Wolfe (Down)",
    "po3_bull": "PO3 (Up)",
    "po3_bear": "PO3 (Down)",
    "qml_bull": "Quasimodo (Bull)",
    "qml_bear": "Quasimodo (Bear)",
    "three_sweep_bull": "Three Sweep (Bull)",
    "three_sweep_bear": "Three Sweep (Bear)",
}
PRIORITY_BULL = [
    "po3_bull",
    "wolfe_break_bull",
    "wedge_break_bull",
    "triangle_sym_break_bull",
    "triangle_asc_break_bull",
    "channel_break_bull",
    "cup_handle_bull",
    "cup_break_bull",
    "inverse_head_shoulders_break_bull",
    "double_bottom_break_bull",
    "engulf_strong_bull",
    "pinbar_strict_bull",
    "morning_star_break_bull",
    "three_white_soldiers_follow",
    "inside_break_bull",
    "outside_break_bull",
    "abcd_strict_bull",
    "qml_bull",
    "three_sweep_bull",
]
PRIORITY_BEAR = [
    "po3_bear",
    "wolfe_break_bear",
    "wedge_break_bear",
    "triangle_sym_break_bear",
    "triangle_desc_break_bear",
    "channel_break_bear",
    "cup_handle_bear",
    "cup_break_bear",
    "head_shoulders_break_bear",
    "double_top_break_bear",
    "engulf_strong_bear",
    "pinbar_strict_bear",
    "evening_star_break_bear",
    "three_black_crows_follow",
    "inside_break_bear",
    "outside_break_bear",
    "abcd_strict_bear",
    "qml_bear",
    "three_sweep_bear",
]


def pick_direction(latest: dict) -> str:
    # bullish/bearish setleri yukarƒ±da tanƒ±mlƒ±
    bull_hit = any(bool(latest.get(k, False)) for k in bullish_keys)
    bear_hit = any(bool(latest.get(k, False)) for k in bearish_keys)
    if bull_hit and not bear_hit:
        return "LONG"
    if bear_hit and not bull_hit:
        return "SHORT"
    return "NONE"  # ikisi de yoksa ya da ikisi birden varsa


def pick_formasyon(latest: dict, direction: str) -> str:
    if direction == "LONG":
        order = PRIORITY_BULL
    elif direction == "SHORT":
        order = PRIORITY_BEAR
    else:
        order = PRIORITY_BULL + PRIORITY_BEAR  # y√∂ns√ºzse genel √∂ncelik

    # 1) √∂ncelik listesine g√∂re ilk TRUE olanƒ± se√ß
    for k in order:
        if bool(latest.get(k, False)):
            return FORMATION_LABELS.get(k, k)

    # 2) yedek: tabloda herhangi bir TRUE varsa ilkini al
    for k, v in latest.items():
        if (
            k not in ("time", "score", "direction", "formasyon")
            and isinstance(v, bool)
            and v
        ):
            return FORMATION_LABELS.get(k, k)

    return "-"  # hi√ßbiri yoksa


def postprocess(latest: dict) -> dict:
    direction = pick_direction(latest)
    latest["direction"] = direction
    latest["formasyon"] = pick_formasyon(latest, direction)
    return latest


def get_tf_bar_time(res: dict) -> datetime | None:
    """
    latest/result s√∂zl√ºƒü√ºndeki 'time' alanƒ±nƒ± g√ºvenle datetime'e √ßevirir.
    pandas Timestamp, string veya datetime gelebilir; None d√∂nebilir.
    """
    t = res.get("time")
    if t is None:
        return None
    try:
        # pd.to_datetime t√ºm tipleri normalize eder; ardƒ±ndan pure datetime'a √ßevir.
        return pd.to_datetime(t).to_pydatetime()
    except Exception:
        return None


def _now_minutes_in_tz(tz_name: str) -> int:
    now = get_server_time(ZoneInfo(tz_name))
    return now.hour * 60 + now.minute


# ---- Sinyal i≈üleme (basit s√ºr√ºm) ----
def handle_signal(tf: str, res: dict):
    global HANDLE_SIGNAL_LOCK
    if HANDLE_SIGNAL_LOCK:
        debug_log("[GUARD] handle_signal reentry blocked")
        return  # recursion kilidi

    HANDLE_SIGNAL_LOCK = True
    try:
        # --- mevcut mesaj in≈üa kƒ±smƒ±n ---
        direction = res.get("direction", "-")
        formasyon = res.get("formasyon", "-")
        true_cols = [k for k, v in res.items() if isinstance(v, bool) and v]

        msg = (
            f"‚úÖ[{tf}] sinyali\n"
            f"Y√∂n: {direction}\n"
            f"Formasyon: {formasyon}\n"
            f"TRUE kolonlar: {true_cols}"
        )
        note = res.get("spread_note")
        if note:
            msg += f"\n{note}"

        debug_log(msg)
        # send_signal_message(tf, msg) # istersen a√ß

        # ‚¨á‚¨á FORCE kancasƒ± ‚Äì kesin √ßaƒürƒ± + g√∂r√ºn√ºr log
        # print("[FORCE] hook √ßaƒürƒ±lƒ±yor‚Ä¶")
        # force_open_market_from_res(res)
        # ‚¨Ü‚¨Ü

        r = dict(res or {})
        r["timeframe"] = tf  # log i√ßin
        diagnose_and_maybe_order(tf, r, send=(int(os.getenv("SEND_ORDERS", "1")) == 1))
        return msg
    finally:
        HANDLE_SIGNAL_LOCK = False


# ========= MT5 helper (optional) =========
def mt5_rates_to_ohlc_df(rates) -> pd.DataFrame:
    df = pd.DataFrame(rates)
    df["time"] = pd.to_datetime(df["time"], unit="s")
    df.set_index("time", inplace=True)
    return df[["open", "high", "low", "close"]].copy()


# √∂rnek √ßaƒürƒ±
# stats = mini_backtest(SYMBOL, mt5.TIMEFRAME_M15, lookback=500)
# print(stats)


# --- Mini backtest ---
def mini_backtest(symbol: str, timeframe, lookback: int = 500):
    """
    Emir yok, Telegram yok. Son 'lookback' mum i√ßin:
    - Ka√ß sinyal √ºretildi
    - Win/Loss sayƒ±sƒ±
    - Ortalama RR
    - En iyi / en k√∂t√º RR
    - Basit max drawdown (RR bazlƒ±)
    """

    # 1) Veri √ßek
    rates = mt5.copy_rates_from_pos(symbol, timeframe, 0, lookback + 2)
    if rates is None or len(rates) < 50:
        return {"error": "veri yok / kƒ±sa"}

    df = pd.DataFrame(rates)
    df["time"] = pd.to_datetime(df["time"], unit="s")

    wins = 0
    losses = 0
    rrs = []
    equity = [0.0]  # RR birikimli
    max_peak = 0.0
    max_dd = 0.0
    total_signals = 0

    # 2) Sinyal √ºretimi i√ßin kendi generate_signals akƒ±≈üƒ±n
    # NOT: a≈üaƒüƒ±da, her bar kapanƒ±≈üƒ±nda "latest" s√∂zl√ºƒü√º olu≈üturup
    # senin postprocess/pick_direction/pick_formasyon ile aynƒ± ≈üekilde okuyoruz.
    def build_latest(i: int):
        # i: kapanmƒ±≈ü bar (i >= 1)
        row = df.iloc[i]
        latest = {
            "time": row["time"],
            "open": float(row["open"]),
            "high": float(row["high"]),
            "low": float(row["low"]),
            "close": float(row["close"]),
            # a≈üaƒüƒ±daki kolonlar senin generate_signals()‚Äôtan beklenen boolean anahtarlar olmalƒ±
        }
        return latest

    # Bu iki seti senin projedekiyle aynƒ± tut
    bullish_keys = (
        set(PRIORITY_BULL)
        if "PRIORITY_BULL" in globals()
        else {"OB", "FVG", "BRK", "FTR", "SD", "NSB", "LQ"}
    )
    bearish_keys = (
        set(PRIORITY_BEAR)
        if "PRIORITY_BEAR" in globals()
        else {"OB", "FVG", "BRK", "FTR", "SD", "NSB", "LQ"}
    )

    # 3) Bar bar dola≈ü
    for i in range(50, len(df) - 1):  # ilk 50 barƒ± ƒ±sƒ±nma
        latest = build_latest(i)

        # Senin ana sinyal jenerat√∂r√ºn (varsa) ile g√ºncel i≈üaretleri doldur
        try:
            # Eƒüer sende generate_signals(df) gibi toplu bir fonksiyon varsa,
            # yukarƒ±da bir defa √ºretip df ile merge edebilirsin.
            # Burada min yalƒ±n: mevcut barƒ±n basit teyidi i√ßin kendi rules fonksiyonlarƒ±nƒ± √ßaƒüƒ±r.
            pass
        except:
            pass

        # Direction + formasyon se√ß
        try:
            direction = pick_direction(latest)
        except:
            # basit fallback: close > open ise long, deƒüilse short
            direction = "LONG" if latest["close"] >= latest["open"] else "SHORT"

        try:
            formasyon = pick_formasyon(latest, direction)
        except:
            # fallback: herhangi bir anahtar yoksa "-"
            formasyon = "-"

        # Teyit sayƒ±sƒ± (TRUE sayƒ±mƒ±) ‚Äî senin confirm e≈üiƒüinle tutarlƒ± olsun
        true_cols = []
        for k, v in list(latest.items()):
            if isinstance(v, bool) and v:
                true_cols.append(k)
        confirm = len(true_cols)
        th = (
            get_confirm_threshold(timeframe)
            if "get_confirm_threshold" in globals()
            else 3
        )

        if confirm < th or formasyon == "-":
            continue  # sinyal kabul edilmedi

        total_signals += 1

        # 4) Giri≈ü/√áƒ±kƒ±≈ü (basit sim√ºlasyon)
        entry = df.iloc[i + 1]["open"]  # bir sonraki bar a√ßƒ±lƒ±≈üƒ±ndan giri≈ü
        # TP/SL mesafesi
        try:
            pips = choose_target_pips(timeframe, mode=TP_MODE.lower())
        except:
            pips = 30  # fallback

        # point ‚Üí pip d√∂n√º≈ü√ºm√º projene g√∂re deƒüi≈üiyorsa ayarla
        point = mt5.symbol_info(symbol).point
        pip_value_in_price = 10 * point  # √∂r: 5 basamaklƒ±ysa 10*point = 0.001

        tp_dist = pips * pip_value_in_price
        sl_dist = pips * pip_value_in_price  # 1:1 RR basit yakla≈üƒ±m

        if direction == "LONG":
            tp = entry + tp_dist
            sl = entry - sl_dist
        else:
            tp = entry - tp_dist
            sl = entry + sl_dist

        # bar-bar ileri sar, TP mi SL mi √∂nce?
        rr = None
        for j in range(i + 1, len(df)):
            hi = df.iloc[j]["high"]
            lo = df.iloc[j]["low"]
            if direction == "LONG":
                hit_tp = hi >= tp
                hit_sl = lo <= sl
            else:
                hit_tp = lo <= tp
                hit_sl = hi >= sl

            if hit_tp and hit_sl:
                # aynƒ± bar i√ßinde ikisine de dokunursa ‚Äúk√∂t√ºmser‚Äù SL say
                rr = -1.0
                break
            elif hit_tp:
                rr = +1.0
                break
            elif hit_sl:
                rr = -1.0
                break

        # sonu√ß yoksa (veri bitti) break
        if rr is None:
            break

        rrs.append(rr)
        if rr > 0:
            wins += 1
        else:
            losses += 1

        # equity & max DD
        equity.append(equity[-1] + rr)
        if equity[-1] > max_peak:
            max_peak = equity[-1]
        dd = max_peak - equity[-1]
        if dd > max_dd:
            max_dd = dd

    # 5) √ñzet
    if rrs:
        avg_rr = float(np.mean(rrs))
        best = float(np.max(rrs))
        worst = float(np.min(rrs))
    else:
        avg_rr, best, worst = 0.0, 0.0, 0.0

    return {
        "symbol": symbol,
        "timeframe": str(timeframe),
        "lookback": lookback,
        "signals": total_signals,
        "wins": wins,
        "losses": losses,
        "winrate_%": round(100 * wins / max(1, wins + losses), 1),
        "avg_RR": round(avg_rr, 3),
        "best_RR": best,
        "worst_RR": worst,
        "max_DD_RR": round(max_dd, 2),
    }


def get_spread_points(symbol: str):
    """
    Sembole ait anlƒ±k spread'i point cinsinden d√∂nd√ºr√ºr.
    return: (spread_pts, bid, ask) veya (None, None, None)
    """
    tick = mt5.symbol_info_tick(symbol)
    info = mt5.symbol_info(symbol)
    if tick is None or info is None:
        return None, None, None

    point = info.point or 0.01  # emniyet kemeri
    bid = float(tick.bid)
    ask = float(tick.ask)
    spread_pts = abs(ask - bid) / point
    return spread_pts, bid, ask


def spread_gate(
    symbol: str, entry_price: float, sl_price: float, mode: str | None = None
):
    """
    Spread kapƒ±sƒ±.
    return: (ok: bool, reason: str|None, spread_pts: float, ratio: float)
    """
    # Dƒ±≈üarƒ±dan mode verilmemi≈üse aktif modu i√ßeride hesapla
    eff_mode = (mode or get_effective_spread_mode()).upper()  # "SOFT" | "HARD" | "AUTO"

    max_pts = float(MAX_SPREAD_POINTS)
    max_ratio = float(MAX_SPREAD_SL_RATIO)

    spread_pts, bid, ask = get_spread_points(symbol)
    if spread_pts is None:
        return True, "NO-SPREAD-DATA", 0.0, 0.0  # veri yoksa engelleme

    info = mt5.symbol_info(symbol)
    point = max(info.point, 1e-9)

    sl_dist_pts = abs(entry_price - sl_price) / point
    ratio = spread_pts / max(sl_dist_pts, 1e-9)

    breach_pts = spread_pts > max_pts
    breach_ratio = ratio > max_ratio

    # SOFT: bloklama yok, sadece uyarƒ± nedeni d√∂nd√ºr
    if eff_mode == "SOFT":
        reason = None
        if breach_pts and breach_ratio:
            reason = "WARN:SPREAD:PTS&RATIO"
        elif breach_pts:
            reason = "WARN:SPREAD:PTS"
        elif breach_ratio:
            reason = "WARN:SPREAD:RATIO"
        return True, reason, spread_pts, ratio

    # HARD: iki limitten biri a≈üƒ±lƒ±rsa blokla
    if eff_mode == "HARD":
        if breach_pts or breach_ratio:
            return False, "BLOCK:HARD", spread_pts, ratio
        return True, None, spread_pts, ratio

    # AUTO: ikisinden biri a≈üƒ±lƒ±rsa blokla (gece/volatilite korumasƒ± gibi)
    if breach_pts or breach_ratio:
        return False, "BLOCK:AUTO", spread_pts, ratio
    return True, None, spread_pts, ratio


# --- 15 dk ---
def check_signals_m15(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M15"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


def sanity_startup_check(symbol):
    # 1) .env okundu mu?
    debug_log(
        "[CHECK] SPREAD_MODE:",
        SPREAD_MODE,
        "HARD_W:",
        HARD_WINDOWS,
        "SOFT_W:",
        SOFT_WINDOWS,
    )

    # 2) Saat penceresi / AUTO modu
    try:
        debug_log("[CHECK] effective_mode:", get_effective_spread_mode())
    except Exception as e:
        debug_log("[CHECK] get_effective_spread_mode ERROR:", e)

    # 3) Spread fonksiyonu
    try:
        sp, bid, ask = get_spread_points(symbol)
        debug_log(f"[CHECK] spread={sp}p bid={bid} ask={ask}")
    except Exception as e:
        debug_log("[CHECK] get_spread_points ERROR:", e)


# --- 30 dk ---
def check_signals_m30(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M30"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 45 dk (M15 + M30 ortalamasƒ±) ---
def check_signals_m45(symbol):
    rates15 = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M15"], 0, 300)
    rates30 = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["M30"], 0, 300)
    if (rates15 is None or len(rates15) == 0) or (rates30 is None or len(rates30) == 0):
        return None

    df15 = mt5_rates_to_ohlc_df(rates15)
    df30 = mt5_rates_to_ohlc_df(rates30)
    df_mixed = (df15 + df30) / 2
    df_mixed.dropna(inplace=True)
    if df_mixed.empty:
        return None

    sig = generate_signals(df_mixed).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 1 saat ---
def check_signals_h1(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H1"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 2 saat ---
def check_signals_h2(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H2"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 3 saat ---
def check_signals_h3(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H3"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 4 saat ---
def check_signals_h4(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H4"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# --- 12 saat ---
def check_signals_h12(symbol):
    rates = mt5.copy_rates_from_pos(symbol, TIMEFRAMES["H12"], 0, 300)
    if rates is None or len(rates) == 0:
        return None
    df = mt5_rates_to_ohlc_df(rates)
    sig = generate_signals(df).astype(bool)
    latest = get_latest_signals(sig)
    return postprocess(latest)


# TF ‚Üí fonksiyon e≈ülemesi
TF_FUNS = {
    "M15": check_signals_m15,
    "M30": check_signals_m30,
    "M45": check_signals_m45,
    "H1": check_signals_h1,
    "H2": check_signals_h2,
    "H3": check_signals_h3,
    "H4": check_signals_h4,
    "H12": check_signals_h12,
}


def run_boot(symbol: str, sleep_sec: int = 5):
    """Tarama d√∂ng√ºs√º + kapƒ±lar + RR/Mesafe sanity."""

    # TF ‚Üí sinyal fonksiyonu e≈ülemesi (sende isimler farklƒ±ysa uyarlayabilirsin)
    fns = {
        "M15": check_signals_m15,
        "M30": check_signals_m30,
        "M45": check_signals_m45,
        "H1": check_signals_h1,
        "H2": check_signals_h2,
        "H3": check_signals_h3,
        "H4": check_signals_h4,
        "H12": check_signals_h12,
    }

    # Global bar-zaman takibi
    global LAST_BAR_TIME
    if "LAST_BAR_TIME" not in globals():
        LAST_BAR_TIME = {}

    while True:
        loop_start = time.time()
        m15_closed = False

        try:
            for tf, fn in fns.items():
                # --- 0) Sinyal √ßek
                res = fn(symbol)
                if not res:
                    continue

                # --- 1) Aynƒ± bar tekrarƒ±nƒ± engelle
                bar_time = get_tf_bar_time(res)
                is_new_bar = False

                if tf not in LAST_BAR_TIME:
                    if bar_time is not None:
                        LAST_BAR_TIME[tf] = bar_time
                    # warm-up
                    continue

                last_t = LAST_BAR_TIME.get(tf)
                if (last_t is not None) and (bar_time is not None):
                    if bar_time == last_t:
                        continue  # aynƒ± bar
                    else:
                        is_new_bar = True

                if bar_time is not None:
                    LAST_BAR_TIME[tf] = bar_time

                if tf == "M15" and is_new_bar:
                    m15_closed = True

                # --- 2) Aynƒ± i√ßerikli mesajƒ± tekrarlama
                if is_duplicate_msg(tf, res):
                    continue
                remember_msg(tf, res)

                # --- SPREAD debug + RCA'ya not bƒ±rak ---

                limit_pts = float(os.getenv("MAXIMUM_SPREAD_POINTS", "99999"))
                limit_ratio = float(os.getenv("MAX_SPREAD_LS_RATIO", "9.99"))

                # --- 4) D1 trend kapƒ±sƒ±
                ok_trend, trend_note = d1_trend_gate(res.get("direction"), symbol)
                if not ok_trend:
                    # print(f"[{tf}] SKIP d1_trend: note={trend_note}")
                    continue
                if trend_note:
                    res["trend_note"] = trend_note

                # --- 5) Y√∂n kontrol√º
                if str(res.get("direction", "NONE")).upper() not in ("LONG", "SHORT"):
                    # print(f"[{tf}] SKIP direction=NONE")
                    continue

                # --- 6) RR/Mesafe sanity (ENV'den) <<<<<< EKLEDƒ∞ƒûƒ∞Mƒ∞Z BLOK
                si = mt5.symbol_info(symbol)
                point = si.point if si else 0.01
                digits = si.digits if si else 2

                entry = float(res.get("entry_price") or 0.0)
                sl = float(res.get("sl_price") or 0.0)
                tp = float(res.get("tp_price") or 0.0)

                # ENTRY YOKSA: tarafƒ± belirle ve anlƒ±k fiyatƒ± kullan
                tick = mt5.symbol_info_tick(symbol)
                dir_val = str(res.get("direction", "LONG")).upper()
                side = mt5.ORDER_TYPE_SELL if dir_val == "SHORT" else mt5.ORDER_TYPE_BUY
                price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask

                if entry <= 0:
                    entry = float(price)
                    res["entry_price"] = entry  # log ve devam i√ßin kaydet

                def _pips(a, b):
                    if not a or not b:
                        return 0.0
                    pts = abs(a - b) / point
                    return pts / max(1, POINTS_PER_PIP)

                risk_pips = _pips(entry, sl)
                reward_pips = _pips(tp, entry)

                # --- 3) Spread kapƒ±sƒ±
                mode_now = get_effective_spread_mode()
                ok, spread_reason, spread_pts, ratio = spread_gate(
                    symbol, entry_price=entry, sl_price=sl, mode=mode_now
                )

                debug_log(
                    f"[SPREAD][{tf}] spread_pts={spread_pts:.1f} ratio={ratio:.2f} "
                    f"limit_pts={limit_pts:.0f} limit_ratio={limit_ratio:.2f} "
                    f"mode={mode_now} why={spread_reason}"
                )
                res["spread_why"] = spread_reason
                if not ok:
                    res["spread_note"] = spread_reason
                    continue
                else:
                    res.pop("spread_note", None)

                # === RCA: PRE-GATE (sinyal neden SKIP?) ===
                tf_used = str((res or {}).get("timeframe") or tf)
                why_val = locals().get("why", os.getenv("SPREAD_MODE", "OFF"))

                res["spread_why"] = (
                    why_val  # elindeki spread kararƒ± (OK / RATIO / POINTS vs.)
                )

                # --- AUTO FILL: SL/TP eksikse seviyelerden doldur ---
                try:
                    # her ≈üeyi res s√∂zl√ºƒü√ºnden oku; yoksa g√ºvenli fallback
                    dir_side = (
                        res.get("side") or res.get("direction") or "LONG"
                    ).upper()
                    entry_px = float(
                        res.get("entry_price", res.get("entry", 0.0)) or 0.0
                    )

                    sl_val = res.get("sl_price")
                    tp_val = res.get("tp_price")
                    sl_in = None if (sl_val in (None, 0)) else float(sl_val)
                    tp_in = None if (tp_val in (None, 0)) else float(tp_val)

                    lvls = res.get("levels")
                    atr_p = res.get("atr_pips")

                    if (sl_in is None) or (tp_in is None):
                        g = compute_sl_tp_guard(
                            symbol=symbol,
                            direction=dir_side,
                            entry=entry_price,
                            sl=sl_in,
                            tp=tp_in,
                            si=None,
                            tick=None,  # scope'ta yoksa None sorun deƒüil
                            levels=lvls,
                            atr_pips=atr_p,
                        )
                        res["sl_price"] = g["sl_price"]
                        res["tp_price"] = g["tp_price"]
                        # varsa local deƒüi≈ükenleri de g√ºncelle
                        sl_price = res["sl_price"]
                        tp_price = res["tp_price"]
                except Exception as _e:
                    print("[RCA] WARN auto-fill(check_all_timeframes):", _e)
                # --- /AUTO FILL ---

                print(f"[RCA][{tf_used}] -- pre-gate --")
                rca_order(
                    symbol, res, tf=tf_used
                )  # request yok; gate sebeplerini d√∂ker

                EPS = 1e-9
                rr = reward_pips / max(risk_pips, EPS)
                res["rr"] = rr
                try:
                    tf_used = res.get("timeframe", tf)
                    handle_signal(tf_used, res)
                except Exception as e:
                    debug_log(f"[{tf_used}] handle_signal hata: {e}")

                # 6.c) RR'yi hesapla ve res'e koy
                # EPS = 1e-9
                # rr = reward_pips / max(risk_pips, EPS)
                # res["rr"] = rr

                # --- 7) Normal akƒ±≈ü (telegram/i≈ülem)
                try:
                    tf_used = res.get("timeframe", tf)
                    handle_signal(tf_used, res)
                except Exception as e:
                    debug_log(f"[{tf_used}] handle_signal hata: {e}")

            # --- TF taramasƒ± bitti; M15 kapanƒ±≈üƒ±nda evaluate
            if m15_closed:
                try:
                    print("[EVAL] M15 close -> evaluate")
                    eval_mode = (
                        "trade" if int(os.getenv("SEND_ORDERS", "0")) == 1 else "signal"
                    )
                    check_all_timeframes(mode=eval_mode)
                except Exception as e:
                    debug_log(f"[EVAL ERROR] {e.__class__.__name__}:{e}")
                    traceback.print_exc()
                finally:
                    m15_closed = False

        except Exception as e:
            debug_log(f"[LOOP ERROR] {e}")

        # tempo
        elapsed = time.time() - loop_start
        time.sleep(max(0.0, sleep_sec - elapsed))


def ema(series, span):
    return series.ewm(span=span, adjust=False).mean()


def sma(series, window):
    return series.rolling(window=window).mean()


def atr(data, window=14):
    high = data["high"]
    low = data["low"]
    close = data["close"]
    tr1 = high - low
    tr2 = (high - close.shift(1)).abs()
    tr3 = (low - close.shift(1)).abs()
    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)
    return tr.rolling(window).mean()


# ----------------- 1) RSI -----------------
def rsi_confirmation(data, period=14, lower=30, upper=70):
    close = data["close"]
    delta = close.diff()
    gain = delta.clip(lower=0)
    loss = -delta.clip(upper=0)
    avg_gain = gain.rolling(window=period).mean()
    avg_loss = loss.rolling(window=period).mean()
    rs = avg_gain / (avg_loss.replace(0, np.nan))
    rsi = 100 - (100 / (1 + rs))
    rsi_val = float(rsi.iloc[-1]) if not rsi.empty else np.nan
    return rsi_val <= lower, rsi_val >= upper


# ----------------- 2) MACD -----------------
def macd_confirmation(data, fast=12, slow=26, signal=9):
    close = data["close"]
    ema_fast = close.ewm(span=fast, adjust=False).mean()
    ema_slow = close.ewm(span=slow, adjust=False).mean()
    macd_line = ema_fast - ema_slow
    signal_line = macd_line.ewm(span=signal, adjust=False).mean()
    hist = macd_line - signal_line
    return (macd_line.iloc[-1] > signal_line.iloc[-1]) and (hist.iloc[-1] > 0), (
        macd_line.iloc[-1] < signal_line.iloc[-1]
    ) and (hist.iloc[-1] < 0)


# ----------------- 3) Bollinger -----------------
def bollinger_confirmation(data, length=20, dev=2.0):
    close = data["close"]
    mid = close.rolling(window=length).mean()
    std = close.rolling(window=length).std()
    upper = mid + dev * std
    lower = mid - dev * std
    c = float(close.iloc[-1])
    return c > float(upper.iloc[-1]), c < float(lower.iloc[-1])


# ----------------- 4) Heikin Ashi -----------------
def heikin_ashi_confirmation(data):
    o = data["open"]
    h = data["high"]
    l = data["low"]
    c = data["close"]
    ha_close = (o + h + l + c) / 4.0
    ha_open = pd.Series(index=data.index, dtype=float)
    ha_open.iloc[0] = (o.iloc[0] + c.iloc[0]) / 2.0
    for i in range(1, len(data)):
        ha_open.iloc[i] = (ha_open.iloc[i - 1] + ha_close.iloc[i - 1]) / 2.0
    ha_o = ha_open.iloc[-1]
    ha_c = ha_close.iloc[-1]
    return ha_c > ha_o, ha_c < ha_o


# ----------------- 5) Fibonacci -----------------
def fib_confirmation(data, lookback=200, tol_percent=0.003):
    high = data["high"][-lookback:]
    low = data["low"][-lookback:]
    swing_high = float(high.max())
    swing_low = float(low.min())
    rng = swing_high - swing_low
    if rng == 0:
        return False, False
    level382 = swing_high - 0.382 * rng
    level618 = swing_high - 0.618 * rng
    c = float(data["close"].iloc[-1])
    in_zone = (c >= level618) and (c <= level382)
    return in_zone, False


# ----------------- 6) Trendline Breakout -----------------
def trendline_breakout_check(data, lookback=50):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    last_high = float(highs.max())
    last_low = float(lows.min())
    c = float(data["close"].iloc[-1])
    return c > last_high, c < last_low


# ----------------- 7) Mavilim (MA Filter) -----------------
def mavilim_confirmation(data, short=50, long=200):
    if len(data) < long:
        return False, False
    ma_s = float(ema(data["close"], short).iloc[-1])
    ma_l = float(ema(data["close"], long).iloc[-1])
    return ma_s > ma_l, ma_s < ma_l


# ----------------- 8) Supertrend -----------------
def supertrend_confirmation(data, period=10, multiplier=3):
    hl2 = (data["high"] + data["low"]) / 2
    atr_val = atr(data, period)
    upperband = hl2 + multiplier * atr_val
    lowerband = hl2 - multiplier * atr_val
    c = data["close"].iloc[-1]
    return c > lowerband.iloc[-1], c < upperband.iloc[-1]


# ----------------- 9) EMA Ribbon -----------------
def ema_ribbon_confirmation(data, spans=(8, 13, 21, 34, 55, 89)):
    emas = [ema(data["close"], s) for s in spans]
    last = [float(e.iloc[-1]) for e in emas]
    return all(last[i] > last[i + 1] for i in range(len(last) - 1)), all(
        last[i] < last[i + 1] for i in range(len(last) - 1)
    )


# ----------------- 10) Liquidity Sweep -----------------
def liquidity_sweep_confirmation(data):
    if len(data) < 3:
        return False, False
    prev = data.iloc[-2]
    last = data.iloc[-1]
    ok_long = (prev["high"] < last["high"]) and (last["close"] < prev["close"])
    ok_short = (prev["low"] > last["low"]) and (last["close"] > prev["close"])
    return ok_long, ok_short


# ----------------- 11) Old High/Low -----------------
def old_high_low_confirmation(data, lookback=200):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return c > float(highs.max()), c < float(lows.min())


# ----------------- 12) MSB -----------------
def msb_confirmation(data, lookback=20):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return c > float(highs.max()), c < float(lows.min())


# ----------------- 13) ChoCH -----------------
def choch_confirmation(data, lookback=50):
    if len(data) < 6:
        return False, False
    highs = data["high"][-6:]
    lows = data["low"][-6:]
    if highs.iloc[-1] > highs.iloc[-2] and lows.iloc[-1] > lows.iloc[-2]:
        return True, False
    if highs.iloc[-1] < highs.iloc[-2] and lows.iloc[-1] < lows.iloc[-2]:
        return False, True
    return False, False


# ----------------- 14) Order Block -----------------
def order_block_confirmation(data, lookback=100):
    bodies = (data["close"] - data["open"]).abs()
    idx = bodies[-lookback:].idxmax()
    ob_open = float(data.loc[idx, "open"])
    ob_close = float(data.loc[idx, "close"])
    c = float(data["close"].iloc[-1])
    return (c >= min(ob_open, ob_close)) and (c <= max(ob_open, ob_close)) and (
        ob_close > ob_open
    ), (c >= min(ob_open, ob_close)) and (c <= max(ob_open, ob_close)) and (
        ob_close < ob_open
    )


# ----------------- 15) Breaker Block -----------------
def breaker_block_confirmation(data, lookback=100):
    ok_long, ok_short = order_block_confirmation(data, lookback)
    last_body = data["close"].iloc[-1] - data["open"].iloc[-1]
    if ok_long and last_body < 0:
        return True, False
    if ok_short and last_body > 0:
        return False, True
    return False, False


# ----------------- 16) OTE -----------------
def ote_confirmation(data, lookback=200):
    high = float(data["high"][-lookback:].max())
    low = float(data["low"][-lookback:].min())
    rng = high - low
    if rng == 0:
        return False, False
    ote_top = high - 0.618 * rng
    ote_bot = high - 0.705 * rng
    c = float(data["close"].iloc[-1])
    return (c >= ote_bot) and (c <= ote_top), False


# ----------------- 17) Supply & Demand -----------------
def supply_demand_confirmation(data, lookback=200):
    close = data["close"]
    pct = close.pct_change()
    idx = pct[-lookback:].abs().idxmax()
    zone = float(data.loc[idx, "close"])
    c = float(close.iloc[-1])
    return c >= zone, c <= zone


# ----------------- 18) FTR -----------------
def ftr_confirmation(data, lookback=50):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return c > float(highs.max()), c < float(lows.min())


# ----------------- 19) FVG -----------------
def fvg_confirmation(data):
    if len(data) < 3:
        return False, False
    a = data.iloc[-3]
    b = data.iloc[-2]
    c = data.iloc[-1]
    return (b["low"] > a["high"] and c["low"] > a["high"]), (
        b["high"] < a["low"] and c["high"] < a["low"]
    )


# ----------------- 20) SR Flip -----------------
def sr_flip_confirmation(data, lookback=200):
    highs = data["high"][-lookback:]
    lows = data["low"][-lookback:]
    c = float(data["close"].iloc[-1])
    return (c > float(highs.max())) and (data["close"].iloc[-2] < float(highs.max())), (
        c < float(lows.min())
    ) and (data["close"].iloc[-2] > float(lows.min()))


# ----------------- 21) Sniper Entry -----------------
def sniper_entry_confirmation(data):
    fib_ok_long, fib_ok_short = fib_confirmation(data)
    ob_ok_long, ob_ok_short = order_block_confirmation(data)
    return fib_ok_long and ob_ok_long, fib_ok_short and ob_ok_short


# ----------------- 22) CRT -----------------
def crt_confirmation(data):
    if len(data) < 3:
        return False, False
    b = data.iloc[-2]
    c = data.iloc[-1]
    be = (
        (b["close"] < b["open"])
        and (c["close"] > c["open"])
        and (c["close"] > b["open"])
    )
    se = (
        (b["close"] > b["open"])
        and (c["close"] < c["open"])
        and (c["close"] < b["open"])
    )
    return be, se


# === Order Block (OB) ===
def ob_check(df):
    if len(df) < 2:
        return False, False, None
    last = df.iloc[-1]
    prev = df.iloc[-2]

    ok_long = last.close > prev.high
    ok_short = last.close < prev.low

    level = prev.low if ok_long else prev.high if ok_short else None
    return ok_long, ok_short, level


# === Breaker Block (BRK) ===
def brk_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = prev.high < mid.low and last.close > mid.high
    ok_short = prev.low > mid.high and last.close < mid.low

    level = mid.low if ok_long else mid.high if ok_short else None
    return ok_long, ok_short, level


# === SR Flip (Destek ‚Üî Diren√ß) ===
def sr_flip_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = prev.low < mid.low < last.close
    ok_short = prev.high > mid.high > last.close

    level = mid.low if ok_long else mid.high if ok_short else None
    return ok_long, ok_short, level


# === FVG (Fair Value Gap) ===
def fvg_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = prev.high < last.low
    ok_short = prev.low > last.high

    level = prev.high if ok_long else prev.low if ok_short else None
    return ok_long, ok_short, level


# === FTR (Failed To Return) ===
def ftr_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = last.close > prev.high and mid.low > prev.low
    ok_short = last.close < prev.low and mid.high < prev.high

    level = prev.low if ok_long else prev.high if ok_short else None
    return ok_long, ok_short, level


# === Supply & Demand Zones (SD) ===
def sd_check(df):
    if len(df) < 5:
        return False, False, None
    zone_high = df["high"].iloc[-5:].max()
    zone_low = df["low"].iloc[-5:].min()

    ok_long = df["close"].iloc[-1] > zone_high
    ok_short = df["close"].iloc[-1] < zone_low

    level = zone_low if ok_long else zone_high if ok_short else None
    return ok_long, ok_short, level


# === Market Structure Break (MSB) ===
def msb_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-3]
    mid = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = last.high > mid.high and last.close > mid.close
    ok_short = last.low < mid.low and last.close < mid.close

    level = mid.low if ok_long else mid.high if ok_short else None
    return ok_long, ok_short, level


# === Liquidity Sweep (Equal High/Low, Old High/Low) ===
def liquidity_sweep_check(df):
    if len(df) < 3:
        return False, False, None
    prev = df.iloc[-2]
    last = df.iloc[-1]

    ok_long = last.low < prev.low and last.close > prev.close
    ok_short = last.high > prev.high and last.close < prev.close

    level = prev.low if ok_long else prev.high if ok_short else None
    return ok_long, ok_short, level


# ----------------- Hepsini Topla -----------------
def all_confirmations(data):
    funcs = [
        rsi_confirmation,
        macd_confirmation,
        bollinger_confirmation,
        heikin_ashi_confirmation,
        fib_confirmation,
        trendline_breakout_check,
        mavilim_confirmation,
        supertrend_confirmation,
        ema_ribbon_confirmation,
        liquidity_sweep_confirmation,
        old_high_low_confirmation,
        msb_confirmation,
        choch_confirmation,
        order_block_confirmation,
        breaker_block_confirmation,
        ote_confirmation,
        supply_demand_confirmation,
        ftr_confirmation,
        fvg_confirmation,
        sr_flip_confirmation,
        sniper_entry_confirmation,
        crt_confirmation,
    ]
    teyit_sayisi_long = 0
    teyit_sayisi_short = 0
    for fn in funcs:
        try:
            ok_long, ok_short = fn(data)
        except:
            ok_long, ok_short = False, False
        if ok_long:
            teyit_sayisi_long += 1
        if ok_short:
            teyit_sayisi_short += 1

    # üîΩüîΩüîΩ BURAYA STOP LOSS FONKSƒ∞YONLARINI √áAƒûIRACAKSIN üîΩüîΩüîΩ
    ob_long, ob_short, ob_level = ob_check(data)
    brk_long, brk_short, brk_level = brk_check(data)
    sr_long, sr_short, sr_level = sr_flip_check(data)
    fvg_long, fvg_short, fvg_level = fvg_check(data)
    ftr_long, ftr_short, ftr_level = ftr_check(data)
    sd_long, sd_short, sd_level = sd_check(data)
    msb_long, msb_short, msb_level = msb_check(data)
    lq_long, lq_short, lq_level = liquidity_sweep_check(data)

    levels = {
        "OB": ob_level,
        "BRK": brk_level,
        "SR": sr_level,
        "FVG": fvg_level,
        "FTR": ftr_level,
        "SD": sd_level,
        "MSB": msb_level,
        "LQ": lq_level,
    }

    return teyit_sayisi_long, teyit_sayisi_short, levels

    # √ñncelikli seviyelerden SL se√ß
    for key in priority:
        level = levels.get(key)
        if level is not None:
            if isinstance(level, pd.Series):
                level = float(level.iloc[-1])
            else:
                level = float(level)
            return level, key

    # Eƒüer hi√ß seviye yoksa fallback ‚Üí son barƒ±n low/high
    last = tf_df.iloc[-1]
    if direction == "LONG":
        return float(last["low"]) - (pip_buffer * 0.5), "ATR-Fallback"
    else:
        return float(last["high"]) + (pip_buffer * 0.5), "ATR-Fallback"


# G√ºnl√ºk trend analizi
# D1 trend y√∂n√ºn√º √ºretir: "LONG" / "SHORT" / "NONE"
def get_d1_trend(symbol: str, ma_period: int | None = None) -> str:
    try:
        # env'den default MA
        if ma_period is None:
            try:
                ma_period = int(os.getenv("D1_TREND_MA", "50"))
            except Exception:
                ma_period = 50

        # D1 OHLC al
        df = get_ohlc(symbol, mt5.TIMEFRAME_D1, 200)
        if df is None or df.empty or len(df) < ma_period + 1:
            return "NONE"

        close = df["close"]
        ma = close.rolling(window=ma_period).mean()
        last_close = float(close.iloc[-1])
        last_ma = float(ma.iloc[-1])

        if np.isnan(last_ma):
            return "NONE"

        if last_close > last_ma:
            return "LONG"
        elif last_close < last_ma:
            return "SHORT"
        else:
            return "NONE"

    except Exception:
        return "NONE"


timeframes_to_check = {
    "M15": check_signals_m15,
    "M30": check_signals_m30,
    "M45": check_signals_m45,  # 15dk + 30dk karƒ±≈üƒ±mƒ±
    "H1": check_signals_h1,
    "H2": check_signals_h2,
    "H3": check_signals_h3,
    "H4": check_signals_h4,
    "H12": check_signals_h12,
}


def d1_trend_gate(direction: str, symbol: str) -> tuple[bool, str | None]:
    """
    D1 trend filtresi:
      OFF -> her zaman True
      SOFT -> trend tersse not d√º≈ü; yine de kabul et
      HARD -> trend tersse reddet
    return: (ok, note)
    """
    mode = D1_TREND_MODE  # .env‚Äôden okunuyor (OFF / SOFT / HARD)
    if mode == "OFF":
        return True, None

    try:
        # get_d1_trend LONG/SHORT/NONE d√∂nd√ºr√ºr
        d1_dir = get_d1_trend(symbol, D1_TREND_MA)  # ma periyodunu da iletelim
    except Exception as e:
        debug_log(f"D1 trend hesaplanamadƒ±: {e}")
        # SOFT‚Äôta ge√ß, HARD‚Äôda reddet
        return (True, "trend_unavailable") if mode == "SOFT" else (False, None)

    # Trend yoksa
    if d1_dir == "NONE" or d1_dir is None:
        return (True, "trend_none") if mode == "SOFT" else (False, None)

    # Trend aynƒ± y√∂nde ‚Üí serbest
    if direction == d1_dir:
        return True, None

    # Trend ters
    if mode == "SOFT":
        return True, f"D1 trend {d1_dir}"
    else:  # HARD
        return False, None


# --- MT5 ƒ∞≈ülem A√ßma Fonksiyonu ---


def calculate_lot(
    entry_price: float, sl_price: float, risk_percent: float = 0.02
) -> float:
    """
    Risk ba≈üƒ±na lot: SL mesafesine spread tamponu eklenmi≈ü olarak hesaplar.
    """
    # 1) Hesap bilgisi
    account = mt5.account_info()
    if account is None:
        debug_log(f"‚ùå Hesap bilgisi alƒ±namadƒ±: {mt5.last_error()}", force=True)
        return 0.10  # fallback sabit lot

    balance = float(account.balance)
    risk_usd = max(0.0, balance * float(risk_percent))  # riske edilecek para

    # 2) Enstr√ºman bilgisi
    info = mt5.symbol_info(SYMBOL)
    if info is None:
        debug_log("‚ùå symbol_info alƒ±namadƒ±", force=True)
        return 0.10

    point = float(info.point or 0.01)
    tick_val = float(getattr(info, "trade_tick_value", 1.0) or 1.0)
    tick_size = float(getattr(info, "trade_tick_size", point) or point)

    # 1 lot i√ßin 1 'point'lik fiyat hareketinin USD kar≈üƒ±lƒ±ƒüƒ±
    usd_per_point_per_lot = tick_val / max(tick_size, 1e-9)

    # 3) SL mesafesi ‚Üí puan
    sl_dist_pts = abs(float(entry_price) - float(sl_price)) / max(point, 1e-9)

    # 4) SPREAD tamponunu ekle
    spread_pts, bid, ask = get_spread_points(SYMBOL)  # (spread_pts "point" cinsinden)
    sl_dist_effective = sl_dist_pts + float(spread_pts)

    # A≈üƒ±rƒ± k√º√ß√ºk mesafelere kar≈üƒ± koruma
    sl_dist_effective = max(sl_dist_effective, 1.0)

    # 5) Lot hesabƒ±
    # risk_usd ‚âà lot * sl_dist_effective * usd_per_point_per_lot
    raw_lot = risk_usd / (sl_dist_effective * usd_per_point_per_lot)

    # 6) Broker limitlerine yuvarla / kƒ±sƒ±tla
    vol_min = float(getattr(info, "volume_min", 0.01) or 0.01)
    vol_max = float(getattr(info, "volume_max", 100.0) or 100.0)
    vol_step = float(getattr(info, "volume_step", 0.01) or 0.01)

    # adƒ±ma yuvarla
    lot_steps = max(1, round(raw_lot / vol_step))
    lot = lot_steps * vol_step
    lot = min(max(lot, vol_min), vol_max)

    debug_log(
        f"[LOT] balance={balance:.2f} risk={risk_usd:.2f}USD "
        f"SL_pts={sl_dist_pts:.1f} spread_pts={spread_pts:.1f} "
        f"eff_pts={sl_dist_effective:.1f} usd/pt/lot={usd_per_point_per_lot:.4f} "
        f"lot={lot}",
        force=True,
    )
    return round(lot, 2)


def has_open_position(symbol):
    positions = mt5.positions_get(symbol=symbol)
    if positions:
        return True
    return False


def calculate_atr(df: pd.DataFrame, period: int = 14) -> pd.Series:
    """
    Average True Range (ATR) hesaplar.
    :param df: OHLC DataFrame (open, high, low, close kolonlarƒ± olmalƒ±)
    :param period: ATR periyodu (varsayƒ±lan 14)
    :return: ATR serisi
    """
    high = df["high"]
    low = df["low"]
    close = df["close"]

    # True Range hesapla
    df["prev_close"] = close.shift(1)
    tr1 = high - low
    tr2 = (high - df["prev_close"]).abs()
    tr3 = (low - df["prev_close"]).abs()

    tr = pd.concat([tr1, tr2, tr3], axis=1).max(axis=1)

    # ATR = TR'nin √ºssel hareketli ortalamasƒ± (EMA)
    atr = tr.ewm(span=period, adjust=False).mean()

    return atr


def place_order(symbol, order_type, lot, entry_price, sl_price, tp_price, side_txt):
    reasons: list[str] = []  # init reasons list
    order_type_mt5 = mt5.ORDER_TYPE_BUY if order_type == "BUY" else mt5.ORDER_TYPE_SELL

    allow_multi = int(os.getenv("ALLOW_MULTIPLE_POSITIONS", "1"))
    if not allow_multi:
        # Aynƒ± sembolde ve aynƒ± y√∂nde a√ßƒ±k pozisyon var mƒ±?
        positions = mt5.positions_get(symbol=symbol)
        if positions:
            for pos in positions:
                if pos.type == order_type_mt5:  # aynƒ± y√∂ndeyse
                    debug_log(
                        f"[BLOCK] {symbol} i√ßin aynƒ± y√∂nde a√ßƒ±k pozisyon var, yeni i≈ülem a√ßƒ±lmadƒ±."
                    )
                    return None

    # Cooldown kontrol√º
    global LAST_TRADE_TIME
    cooldown = int(os.getenv("TRADE_COOLDOWN_SEC", "0"))

    if cooldown > 0 and "LAST_TRADE_TIME" in globals():
        elapsed = (
            now_tr()(ZoneInfo("Europe/ISTANBUL")) - LAST_TRADE_TIME.total_seconds()
        )
        if elapsed < cooldown:
            debug_log(
                f"[BLOCK] Cooldown aktif ({elapsed:.0f}/{cooldown} sn) -> yeni i≈ülem a√ßƒ±lmadƒ±"
            )
            return None

    max_trades = int(os.getenv("MAX_CONCURRENT_TRADES", "0"))
    if max_trades > 0:
        current = active_trade_count()
        if current >= max_trades:
            debug_log(
                f"[BLOCK] Maksimum a√ßƒ±k i≈ülem limiti a≈üƒ±ldƒ±: {current}/{max_trades}"
            )
            return None

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": float(os.getenv("LOT_SIZE", "0.1")),
        "type": order_type,
        "entry": float(entry_price),
        "sl": float(sl_price),
        "tp": float(tp_price),
        "deviation": 20,
        "magic": 123456,
        "comment": "Gold Bot",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }

    request = _sanitize_request_plus(request)

    si = mt5.symbol_info(symbol)
    try:
        tick = mt5.symbol_info_tick(symbol)
    except Exception:
        tick = None

    direction = "LONG" if order_type_mt5 == mt5.ORDER_TYPE_BUY else "SHORT"

    # sadece eksikse guard √ßaƒüƒ±r
    if not sl_price or not tp_price:
        guard = compute_sl_tp_guard(
            symbol,
            direction,
            entry_price,
            (tick.ask if direction == "LONG" else tick.bid) if tick else entry_price,
            sl_price,
            tp_price,
            si=si,
            tick=tick,
        )

    # BUY->ask, SELL->bid, digits‚Äôe g√∂re yuvarla; guard.price varsa kullan
    request = fix_order_price(
        request,
        guard=guard,
        tick=tick,
    )

    # Broker'ƒ±n destekleyebileceƒüi modlarƒ± sƒ±rayla dene
    fillings = [
        getattr(mt5, "ORDER _FILLING_RETURN", 2),
        getattr(mt5, "ORDER_FILLING_IOC", 1),
        getattr(mt5, "ORDER_FILLING_FOK", 3),
    ]
    base_req = dict(request)

    last_result = None

    for f in fillings:
        req = dict(base_req)
        req["type_filling"] = f
        result = RAW_ORDER_SEND(req)
    if result and getattr(result, "retcode", -1) == mt5.TRADE_RETCODE_DONE:
        debug_log(f"‚úÖ DEAL OK ticket={result.order} filling={f}")
        return result
    else:
        debug_log(f"‚ùå DEAL FAIL retcode={getattr(result,'retcode',None)} filling={f}")


LAST_TRADE_TIME = now_tr()

LOG_FILE = "trades_log.csv"


def log_trade(time_str, order_type, entry, volume, sl, tp, lot, rr, ticket):
    file_exists = os.path.isfile(LOG_FILE)

    with open(LOG_FILE, mode="a", newline="") as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(
                ["Time", "Type", "Entry", "volume", "SL", "TP", "Lot", "R:R", "Ticket"]
            )
        writer.writerow([time_str, order_type, entry, volume, sl, tp, lot, rr, ticket])


def log_close_trade(
    time_str, order_type, entry, volume, sl, tp, lot, rr, ticket, close_price, profit
):
    file_exists = os.path.isfile(LOG_FILE)

    with open(LOG_FILE, mode="a", newline="") as file:
        writer = csv.writer(file)
        if not file_exists:
            writer.writerow(
                [
                    "Time",
                    "Type",
                    "Volume" "Entry",
                    "SL",
                    "TP",
                    "Lot",
                    "R:R",
                    "Ticket",
                    "ClosePrice",
                    "Profit",
                ]
            )
        writer.writerow(
            [
                time_str,
                order_type,
                entry,
                volume,
                sl,
                tp,
                lot,
                rr,
                ticket,
                close_price,
                profit,
            ]
        )


# --- Kapanƒ±≈ülarƒ± tarayƒ±p 'HEDEFTE'yi tek kez g√∂nder ----------------
def check_closed_positions():
    global LAST_CLOSED_CHECK, LAST_LOGGED_DEALS

    # Alan adƒ± farklarƒ± i√ßin k√º√ß√ºk yardƒ±mcƒ±
    def deal_field(d, *names):
        for n in names:
            if hasattr(d, n):
                return getattr(d, n)
            if hasattr(d, "_asdict"):
                a = d._asdict()
                if n in a:
                    return a[n]
        return None

    # Zaman aralƒ±ƒüƒ±: son kontrolden bu ana (ilk turda 1 saat geriye bak)
    t1 = (
        datetime.fromtimestamp(LAST_CLOSED_CHECK, tz=ZoneInfo("Europe/Istanbul"))
        if isinstance(LAST_CLOSED_CHECK, (int, float)) and LAST_CLOSED_CHECK > 0
        else now_tr()(ZoneInfo("Europe/Istanbul")) - timedelta(hours=1)
    )
    t2 = now_tr()(ZoneInfo("Europe/Istanbul"))
    try:
        history = mt5.history_deals_get(t1, t2) or []
    except Exception:
        history = []

    if not history:
        LAST_CLOSED_CHECK = t2.timestamp()
        return

    for deal in history:
        try:
            # 1) sadece kapanƒ±≈ülar
            entry = deal_field(deal, "entry", "Entry")
            if entry != mt5.DEAL_ENTRY_OUT:
                continue

            # 2) duplicate: aynƒ± ticket‚Äôi iki kez i≈üleme
            ticket = deal_field(deal, "ticket", "Ticket")
            if ticket in LAST_LOGGED_DEALS:
                continue
            LAST_LOGGED_DEALS.add(ticket)

            # 3) sadece TP kapanƒ±≈ülarƒ±
            reason = str(
                deal_field(deal, "reason", "deal_reason", "Reason") or ""
            ).lower()
            comment = str(deal_field(deal, "comment", "Comment") or "").lower()
            if (
                mt5.DEAL_REASON_TP not in [deal_field(deal, "reason", "Reason"), None]
                and "tp" not in comment
            ):
                continue

            # 4) alanlar
            close_time = datetime.fromtimestamp(deal_field(deal, "time", "Time"))
            close_price = deal_field(deal, "price", "Price")
            profit = deal_field(deal, "profit", "Profit")
            side = (
                "LONG"
                if deal_field(deal, "type", "Type") == mt5.ORDER_TYPE_BUY
                else "SHORT"
            )
            pos_id = int(
                deal_field(deal, "position_id", "position", "PositionID") or ticket
            )

            # Telegram: HEDEFTE
            try:
                tgt_pips = globals().get("target_pips") or globals().get("PIPS")
                if tgt_pips is None:
                    tgt_pips = 0

                # mesajƒ± fonksiyona yolla
                send_target_message(side, tgt_pips, close_time, close_price, profit)

                # terminal log
                debug_log(
                    f"[TARGET] üéØXAUUSD {side} {tgt_pips} Pƒ∞P HEDEFTE | "
                    f"KAPANI≈û:{close_price:.2f} üí∞K√¢r:{profit:.2f} USD"
                )

            except Exception as e:
                debug_log(f"[TARGET SEND EXC] {e}")

            # kƒ±sa log
            debug_log(
                f"[OK] POZƒ∞SYON KAPANDI | Ticket:{ticket} Pos:{pos_id} üí∞K√¢r:{profit:.2f} USD"
            )

        except Exception:
            continue

    LAST_CLOSED_CHECK = t2.timestamp()


# -------------------------------------------------------------------
def update_trailing_stop(
    symbol, ticket, order_type, entry_price, sl_price, direction, trailing_distance=200
):
    # Mevcut pozisyonu √ßek
    position = mt5.positions_get(ticket=ticket)
    if not position:
        return False  # pozisyon yok

    price = (
        mt5.symbol_info_tick(symbol).bid
        if direction == "BUY"
        else mt5.symbol_info_tick(symbol).ask
    )
    profit_distance = (
        (price - entry_price) if direction == "BUY" else (entry_price - price)
    )

    # trailing stop devreye girecek mi?
    if profit_distance > trailing_distance * PIP_VALUE:
        # yeni SL: fiyat - trailing_distance
        new_sl = (
            price - trailing_distance * PIP_VALUE
            if direction == "BUY"
            else price + trailing_distance * PIP_VALUE
        )

        # sadece ileriye ta≈üƒ±rƒ±z (asla geri almayƒ±z)
        if (direction == "BUY" and new_sl > sl_price) or (
            direction == "SELL" and new_sl < sl_price
        ):
            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": float(os.getenv("LOT_SIZE", "0.1")),
                "type": order_type,
                "entry": float(entry_price),
                "sl": float(sl_price),
                "tp": float(tp_price),
                "deviation": 20,
                "magic": 123456,
                "comment": "Gold Bot",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }

        result = RAW_ORDER_SEND(request)
        if result is None:
            debug_log(f"‚ùå Trailing Stop: order_send None ‚Üí {mt5.last_error()}")
            return False
        if result.retcode == mt5.TRADE_RETCODE_DONE:
            debug_log(f"‚úÖ Trailing Stop g√ºncellendi ‚Üí Yeni SL: {new_sl}")
            return True
        else:
            debug_log(f"‚ùå Trailing Stop g√ºncellenemedi: {result.retcode}")
            return False


def move_sl_to_entry(symbol, ticket, order_type, entry_price, tp_price, direction):
    try:
        current_price = (
            mt5.symbol_info_tick(symbol).bid
            if direction == "BUY"
            else mt5.symbol_info_tick(symbol).ask
        )

        # %70 hedef seviyesi
        hedef_seviye = (
            entry_price + (tp_price - entry_price) * 0.7
            if direction == "BUY"
            else entry_price - (entry_price - tp_price) * 0.7
        )

        if (direction == "BUY" and current_price >= hedef_seviye) or (
            direction == "SELL" and current_price <= hedef_seviye
        ):

            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": float(os.getenv("LOT_SIZE", "0.1")),
                "type": order_type,
                "entry": float(entry_price),
                "sl": float(sl_price),
                "tp": float(tp_price),
                "deviation": 20,
                "magic": 123456,
                "comment": "Gold Bot",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }
            ok_sess, sess_reason = session_gate(symbol)
            if not ok_sess:
                debug_log(f"[SESSION][MODIFY] blocked: {sess_reason}")
                return False
            result = RAW_ORDER_SEND(request)
            if result and result.retcode == mt5.TRADE_RETCODE_DONE:
                debug_log(f"üîí SL entry price‚Äôa ta≈üƒ±ndƒ±! Ticket: {ticket}")
                debug_log(
                    f"üîí[INFO] {symbol}SL entry price‚Äôa ta≈üƒ±ndƒ± (Ticket {ticket})"
                )
                return True
    except Exception as e:
        debug_log(f"move_sl_to_entry hata: {e}")
    return False


def manage_open_positions(
    symbol: str, trailing_distance: int = TRAILING_DISTANCE, throttle_sec: int = 5
):
    """
    A√ßƒ±k pozisyonlarƒ± periyodik kontrol eder:
      - Trailing Stop'u g√ºnceller (5 sn throttle)
      - Fiyat TP'nin %70'ine gelmi≈üse SL'yi entry'e ta≈üƒ±r
    """
    try:
        positions = mt5.positions_get(symbol=symbol)
        if not positions:
            return

        now_ts = time.time()

        for pos in positions:
            ticket = pos.ticket
            direction = "BUY" if pos.type == mt5.ORDER_TYPE_BUY else "SELL"
            entry = float(pos.price_open)
            sl = float(pos.sl) if pos.sl else entry  # yoksa entry baz al
            tp = float(pos.tp) if pos.tp else None

            # 1) Trailing Stop (throttle: 5 sn)
            last = LAST_TRAIL_CHECK.get(ticket, 0.0)
            if now_ts - last >= throttle_sec:
                try:
                    update_trailing_stop(
                        SYMBOL,
                        ticket,
                        entry,
                        sl,
                        direction,
                        trailing_distance=trailing_distance,
                    )
                except Exception as e:
                    debug_log(f"Trailing hata (ticket {ticket}): {e}")
                LAST_TRAIL_CHECK[ticket] = now_ts

            # 2) SL'yi giri≈üe ta≈üƒ± (TP tanƒ±mlƒ±ysa)
            if tp is not None:
                try:
                    move_sl_to_entry(SYMBOL, ticket, entry, tp, direction)
                except Exception as e:
                    debug_log(f"BE hata (ticket {ticket}): {e}")

    except Exception as e:
        debug_log(f"manage_open_positions genel hata: {e}")


def maybe_check_closed_positions(throttle_sec: int = 10):
    """
    check_closed_positions()'ƒ± en fazla 'throttle_sec' saniyede bir √ßalƒ±≈ütƒ±r.
    """
    pass_msg = None
    global LAST_CLOSED_CHECK
    now = time.time()
    if now - LAST_CLOSED_CHECK >= throttle_sec:
        try:
            check_closed_positions()
        except Exception as e:
            debug_log(f"check_closed_positions hatasƒ±: {e}")
        LAST_CLOSED_CHECK = now


def check_all_timeframes(mode="order"):

    sl_price = 0.0
    tp_price = 0.0
    sl_source = 0.0

    reasons = []
    tfs = ["M5", "M15", "M30", "M45", "H1", "H2", "H3", "H4", "H12"]
    # Safe symbol resolution for downstream calls
    try:
        symbol = os.getenv("FORCE_SYMBOL") or globals().get("SYMBOL") or "GOLD"
    except Exception:
        symbol = "GOLD"

    info = {}

    request = None  # safe default to avoid UnboundLocalError
    volume = float(os.getenv("LOT", "0.10"))  # default to avoid UnboundLocalError

    # --- local RR text helper (safe) ---
    def _rr_text():
        _v = locals().get("rr_ratio")
        try:
            if _v is None:
                return "-"
            _v = float(_v)
            if not (_v == _v) or _v == float("inf") or _v == float("-inf"):
                return "-"
            return f"{_v:.2f}"
        except Exception:
            return "-"

    if str(os.getenv("FAST_TEST", "0")).strip() in ("1", "true", "on", "yes"):
        tfs = ["M5"]
    pending_msg = ""
    global last_signal_minute
    total_long = 0
    total_short = 0
    results = []  # t√ºm timeframe sonu√ßlarƒ±
    msg: str = ""
    if mode == "signal":
        current_minute = now_tr()(ZoneInfo("Europe/Istanbul")).strftime(
            "%Y-%m-%d %H:%M"
        )
        last_signal_minute = current_minute

    # üîπ 1) T√ºm TF'leri tara
    for tf, func in timeframes_to_check.items():
        try:
            latest = func(SYMBOL)
            if latest is None:
                debug_log(f"{tf} | DATA ALINAMADI (NONE)")
                continue

            aktif = [k for k, v in latest.items() if v]
            formasyon = latest.get("formasyon", "-")

            long_sinyal = any(sig in bullish_keys for sig in aktif)
            short_sinyal = any(sig in bearish_keys for sig in aktif)

            if long_sinyal and not short_sinyal:
                direction_local = "LONG"
                total_long += 1
            elif short_sinyal and not long_sinyal:
                direction_local = "SHORT"
                total_short += 1
            else:
                direction_local = "NONE"

            # teyit sayƒ±larƒ±
            tf_df = get_ohlc(SYMBOL, TIMEFRAMES.get(tf, mt5.TIMEFRAME_H1), 300)
            teyit_long, teyit_short, _ = (
                all_confirmations(tf_df)
                if tf_df is not None and not tf_df.empty
                else (0, 0, {})
            )

            results.append(
                {
                    "timeframe": tf,
                    "direction": direction_local,
                    "formasyon": formasyon,
                    "teyit_long": teyit_long,
                    "teyit_short": teyit_short,
                }
            )

        except Exception as e:
            debug_log(f"{tf} HATASI: {e}")

    # üîπ 2) Genel y√∂n
    if total_long > total_short:
        direction = "LONG"
    elif total_short > total_long:
        direction = "SHORT"
    else:
        direction = "NONE"

    if direction == "NONE":
        return None

    # üîπ 3) En g√º√ßl√º sinyali se√ß (teyit sayƒ±sƒ±na g√∂re)
    best_signal = None
    best_score = -1
    for r in results:
        if r["direction"] == direction:
            teyit = r["teyit_long"] if direction == "LONG" else r["teyit_short"]
            if teyit > best_score:
                best_score = teyit
                best_signal = r

    if not best_signal:
        debug_log("‚ùå Uygun sinyal bulunamadƒ±")
        return None

    formasyon = best_signal["formasyon"]
    tf_used = best_signal["timeframe"]

    debug_log(
        f"üìä GENEL PUANLAMA: LONG={total_long}, SHORT={total_short}, Y√ñN={direction}, SE√áƒ∞LEN={tf_used} (TEYƒ∞T={best_score})"
    )

    dir_val = str(direction).upper() if direction else "-"
    if dir_val not in ("LONG", "SHORT"):
        dir_val = "-"

    res = {
        "direction": dir_val,  # LONG / SHORT / -
        "formasyon": formasyon or "-",  # se√ßilen formasyon
        "symbol": (
            os.getenv("FORCE_SYMBOL")  # GOLD vs. .env'den
            or globals().get("SYMBOL")
            or "GOLD"
        ),
        "timeframe": tf_used,  # bilgi ama√ßlƒ±
    }
    # üîπ 4) OHLC datasƒ± (H1 baz alƒ±nƒ±r)
    tf_df = get_ohlc(SYMBOL, mt5.TIMEFRAME_H1, 500)
    if tf_df is None or tf_df.empty:
        debug_log("H1 OHLC DATASI ALINAMADI")
        return None

    teyit_sayisi_long, teyit_sayisi_short, levels = all_confirmations(tf_df)
    last_close = float(tf_df["close"].iloc[-1])
    target_pips = choose_target_pips(tf_used, mode=TP_MODE.lower())

    th = get_confirm_threshold(tf_used)  # tf_used zaten best_signal‚Äôdan geliyor
    debug_log(f"[{tf_used}] teyit_e≈üiƒüi = {th}")  # (opsiyonel)

    now = get_server_time().strftime("%d-%m-%Y %H:%M:%S")
    atr_values = calculate_atr(tf_df, period=14)
    atr = (
        float(atr_values.iloc[-1])
        if atr_values is not None and not atr_values.empty
        else 0
    )

    # --- LONG ---
    if direction == "LONG":
        if teyit_sayisi_long < th:
            return None

            # default'lar (her durumda tanƒ±mlƒ± olsun)
        warn_tag = ""
        why = None
        spread_pts = 0.0
        rr_ratio = 0.0
        entry_price = None
        tp_price = None
        sl_price = None
        sl_source = ""

        entry_price = last_close
        tp_price = entry_price + target_pips * PIP_VALUE
        sl_price, sl_source = choose_stop_loss(tf_df, "LONG", levels)

        if isinstance(sl_price, pd.Series):
            sl_price = float(sl_price.iloc[-1])
        else:
            sl_price = float(sl_price)

        if sl_price >= entry_price:
            sl_price = entry_price - (atr * 1)
            sl_source = "ATR-FALLBACK"

        # --- SPREAD Fƒ∞LTRESƒ∞ ---
        allow, why, spread_pts, ratio = spread_gate(SYMBOL, entry_price, sl_price)
        if not allow:
            # istersen not d√º≈ü
            res["spread_note"] = why
            return None

        # Uyarƒ± metni (OK/NO-SPREAD-DATA ise bo≈ü)
        warn_tag = (
            ""
            if why in ("OK", "NO-SPREAD-DATA", None)
            else f"\nWARN:{why} (spread={spread_pts:.0f}pt, ratio={ratio:.2f})"
        )

        min_rr = float(os.getenv("MIN_RR", "0"))
        tol = float(os.getenv("RR_TOL", "1e-9"))  # .env‚Äôde opsiyonel

        if rr_ratio + tol < min_rr:
            debug_log(
                f"‚ùå {('LONG' if entry_price > sl_price else 'SHORT')} i√ßin RR {_rr_text()} < {min_rr:.6f} ‚Üí ƒ∞ptal"
            )
            return None

        if not check_tp_bucket(tf_used, entry_price, tp_price):
            hedef_pip = abs(tp_price - entry_price) / PIP_VALUE
            debug_log(
                f"[DEBUG] TP KOVASI REDDEDƒ∞LDƒ∞ ‚Üí hedef_pip={hedef_pip:.1f}, entry={entry_price}, tp={tp_price}"
            )
            return None

        lot = calculate_lot(entry_price, sl_price, risk_percent=0.02)
        if lot <= 0:
            debug_log(
                f"[DEBUG] LOT REDDEDƒ∞LDƒ∞ ‚Üí hesaplanan lot={lot}, entry={entry_price}, sl={sl_price}, tp={tp_price}"
            )
            return None

        warn_tag = (
            ""
            if why in ("OK", "NO-SPREAD-DATA")
            else f" [SPREAD:{spread_pts:.0f}pt {ratio:.2f}]"
        )

        if reasons:
            # ‚ùå DROP ‚Üí sadece terminal
            print(f"[DROP] [{tf_used}] direction -> {', '.join(reasons)}")
        else:
            # ‚úÖ PASS ‚Üí terminal + telegram
            print(f"[PASS] [{tf_used}] direction -> t√ºm kapƒ±lar OK")
            send_telegram_message
            place_order(symbol, direction, lot, entry_price, sl_price, tp_price)

        msg = (
            f"üü©üö®XAUUSD LONG Gƒ∞R HEDEF {target_pips} Pƒ∞P  ({tf_used}) | "
            f"ZAMAN: {now_tr()} ({formasyon}) | "
            f"ENTRY: {entry_price:.2f} | "
            f"TP: {tp_price:.2f} | "
            f"SL: {sl_price:.2f} ({sl_source}) | "
            f"RR: {rr_ratio:.2f} | "
        )
        send_telegram_message(msg)
        place_order(
            symbol="GOLD",
            order_type=direction,
            lot=LOT_SIZE,
            entry_price=entry_price,
            sl_price=sl_price,
            tp_price=tp_price,
        )

        try:
            info["request"] = request  # (may be None; safe)
        except Exception:
            pass

        # --- RCA: GATE √ñNCESƒ∞ (sinyal niye SKIP/PASS?) ---
        tf_used = str(
            (res or {}).get("timeframe") or tf
        )  # tf deƒüi≈ükenin varsa onu da kullanabilirsin
        res["spread_why"] = (
            why  # spread kararƒ±nƒ± RCA'ya ge√ßir (why deƒüi≈ükeni sende var)
        )

        # --- AUTO FILL: SL/TP eksikse seviyelerden doldur ---
        try:
            # her ≈üeyi res s√∂zl√ºƒü√ºnden oku; yoksa g√ºvenli fallback
            dir_side = (res.get("side") or res.get("direction") or "LONG").upper()
            entry_px = float(res.get("entry_price", res.get("entry", 0.0)) or 0.0)

            sl_val = res.get("sl_price")
            tp_val = res.get("tp_price")
            sl_in = None if (sl_val in (None, 0)) else float(sl_val)
            tp_in = None if (tp_val in (None, 0)) else float(tp_val)

            lvls = res.get("levels")
            atr_p = res.get("atr_pips")

            if (sl_in is None) or (tp_in is None):
                g = compute_sl_tp_guard(
                    symbol=symbol,
                    direction=dir_side,
                    entry=entry_price,
                    sl=sl_in,
                    tp=tp_in,
                    si=None,
                    tick=None,  # scope'ta yoksa None sorun deƒüil
                    levels=lvls,
                    atr_pips=atr_p,
                )
                res["sl_price"] = g["sl_price"]
                res["tp_price"] = g["tp_price"]
                # varsa local deƒüi≈ükenleri de g√ºncelle
                sl_price = res["sl_price"]
                tp_price = res["tp_price"]
        except Exception as _e:
            print("[RCA] WARN auto-fill(check_all_timeframes):", _e)
        # --- /AUTO FILL ---

        print(f"[RCA][{tf_used}] -- pre-gate --")
        rca_order(
            symbol, res, tf=tf_used
        )  # request YOK -> gate sebeplerini d√∂ker (confirm/spread/min pip vs.)

        tf_used = str((res or {}).get("timeframe") or tf)
        why_val = locals().get("why", os.getenv("SPREAD_MODE", "OFF"))

        res["spread_why"] = why_val  # elindeki spread kararƒ± (OK / RATIO / POINTS vs.)

        # --- AUTO FILL: SL/TP eksikse seviyelerden doldur ---
        try:
            # eldeki alanlarƒ± toparla
            dir_side = (res.get("side") or res.get("direction") or "LONG").upper()
            entry_px = float(entry_price)
            sl_in = None if (sl_price in (None, 0)) else float(sl_price)
            tp_in = None if (tp_price in (None, 0)) else float(tp_price)
            lvls = res.get("levels")  # H1 teyitlerinden gelen seviye s√∂zl√ºƒü√º
            atr_p = res.get("atr_pips")  # varsa ATR pips
            si_local = si if "si" in locals() else None
            tick_local = tick if "tick" in locals() else None

            # AUTO FILL: SL/TP eksikse guard ile doldur
            if not sl_in or not tp_in:
                g = compute_sl_tp_guard(
                    symbol=symbol,
                    direction=dir_side,
                    entry=entry_px,
                    sl=sl_in,
                    tp=tp_in,
                    si=None,
                    tick=None,
                    levels=lvls,
                    atr_pips=atr_p,
                )
                sl_in = g.get("sl_price") or sl_in
                tp_in = g.get("tp_price") or tp_in
                # res i√ßine de yaz
                res["sl_price"] = sl_in
                res["tp_price"] = tp_in
                sl_price = res["sl_price"]
                tp_price = res["tp_price"]
        except Exception as _e:
            print("[RCA] WARN auto-fill(check_all_timeframes):", _e)
        # --- /AUTO FILL ---

        print(f"[RCA][{tf_used}] -- pre-gate --")
        rca_order(symbol, res, tf=tf_used)  # request yok; gate sebeplerini d√∂ker

        # --- PRE-GATE DIST CHECK ---
        try:
            _vd = _validate_positive_distances(res, entry_price, sl_price, tp_price)
            # _validate_* bazen tuple, bazen dict, bazen bool d√∂nebiliyor: esnek parse
            if isinstance(_vd, (list, tuple)):
                _ok_dist = bool(_vd[0])
                _why = _vd[1] if len(_vd) > 1 else ""
            elif isinstance(_vd, dict):
                _ok_dist = bool(_vd.get("ok", False))
                _why = _vd.get("why", "")
            else:
                _ok_dist = bool(_vd)
                _why = ""
        except Exception as e:
            # Asla √ß√∂kmesin; RCA'ya sebebi yaz ama akƒ±≈üƒ± s√ºrd√ºr
            _ok_dist = True
            _why = f"dist_guard_exc:{e}"

        if not _ok_dist:
            try:
                res.setdefault("why", []).append(_why)
            except Exception:
                pass

                # --- AUTO FILL: SL/TP eksikse seviyeden doldur; yine yoksa hard fallback ---
        try:
            side = (res.get("side") or res.get("direction") or "LONG").upper()
            entry_px = float(
                res.get("entry_price", res.get("entry", res.get("price", 0.0))) or 0.0
            )

            sl_val = res.get("sl_price")
            tp_val = res.get("tp_price")
            sl_in = None if (sl_val in (None, 0)) else float(sl_val)
            tp_in = None if (tp_val in (None, 0)) else float(tp_val)

            if (sl_in is None) or (tp_in is None):
                g = compute_sl_tp_guard(
                    symbol=symbol,
                    direction=side,
                    entry=entry_px,
                    sl=sl_in,
                    tp=tp_in,
                    si=None,
                    tick=None,
                    levels=res.get("levels"),
                    atr_pips=res.get("atr_pips"),
                )
                sl_in, tp_in = g["sl_price"], g["tp_price"]

            # son √ßare: 1 pip hard fallback (asla 0/None kalmasƒ±n)
            if (sl_in in (None, 0)) or (tp_in in (None, 0)):

                pip_div = float(os.getenv("POINTS_PER_PIP", "1") or 1.0)
                point = 0.01
                pip = point * pip_div
                if side == "LONG":
                    sl_in = sl_in or (entry_px - 1 * pip)
                    tp_in = tp_in or (entry_px + 1 * pip)
                else:
                    sl_in = sl_in or (entry_px + 1 * pip)
                    tp_in = tp_in or (entry_px - 1 * pip)

            res["sl_price"] = float(sl_in)
            res["tp_price"] = float(tp_in)
            sl_price = res["sl_price"]
            tp_price = res["tp_price"]
        except Exception as e:
            print("[RCA] WARN auto-fill(final):", e)
            # --- /AUTO FILL ---
            print(f"[RCA][{tf_used}] DROP: {_why}")
            return None

        # --- /PRE-GATE DIST CHECK ---

        # --- REAL SIGNAL GATE ---
        # Circuit breaker (optional)

        _block, _why_cb = (False, "ok")

        if _block:
            reasons.append(_why_cb)

        reasons = []
        need = get_confirm_threshold(tf_used)
        got = sum(
            1
            for k, v in (res.items() if isinstance(res, dict) else [])
            if isinstance(v, bool) and v
        )
        if got < need:
            reasons.append(f"confirm {got}/{need}")
        try:
            if not allow:
                reasons.append(f"spread:{why}")
        except Exception:
            pass

        try:
            min_rr = 0.10
            if rr_ratio is None or rr_ratio < min_rr:
                reasons.append(
                    f"rr:{(0.0 if rr_ratio is None else rr_ratio):.2f}<{min_rr}"
                )
        except Exception:
            reasons.append("rr_err")

        try:
            if not check_tp_bucket(tf_used, entry_price, tp_price):
                reasons.append("tp_bucket")
        except Exception:
            reasons.append("tp_bucket_err")

        if (lot is None) or (lot <= 0):
            reasons.append(f"lot:{lot}")

        tf_used = res.get("timeframe", tf)

        # √∂zet -> sadece terminal
        try:
            summary = build_signal_msg(tf_used, res)
            debug_log(summary)
        except Exception as e:
            debug_log(f"[{tf_used}] build_signal_msg err: {e}")

        # --- ƒ∞STEƒûE BAƒûLI: her turda te≈ühis bas (dry-run) ---
        if os.getenv("DIAG_ALWAYS", "0") == "1":
            diagnose_and_maybe_order(
                tf_used, res, send=False
            )  # order denemez, sadece nedenleri basar
        else:
            send_flag = mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1
            diagnose_and_maybe_order(tf_used, res, send=send_flag)

        #  a≈üaƒüƒ±da istersen info'yu kullanarak konsola kƒ±sa √∂zet basabilirsin
        if not (isinstance(info, dict) and info.get("ok")):
            print(
                f"[DIAG][{tf_used}] SKIP -> "
                + " , ".join((res or {}).get("reasons", []))
            )
        else:
            req = info.get("request", {}) or {}
            debug_log(
                f"[DIAG][{tf_used}] OK (send={send_flag}) price={req.get('price')} sl={req.get('sl')} tp={req.get('tp')}"
            )

    # ---- PASS sonrasƒ±: se√ßilen TF te≈ühis ----
    entry_price = float(res.get("entry_price", 0.0))

    try:
        msg_text = build_signal_msg(tf_used, res) or ""
    except Exception as e:
        debug_log(f"[{tf_used}] build_signal_msg err: {e}")
        msg_text = ""

        debug_log(msg_text or f"[{tf_used}] bo≈ü sinyal metni √ºretildi)")

    # (suppressed) build_signal_msg is internal; do not send
    send_flag = mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1
    diagnose_and_maybe_order(tf_used, res, send=send_flag)

    # Konsola okunur √∂zet
    ok_flag = info.get("ok") if isinstance(info, dict) else True

    _reasons = info.get("reasons", []) if isinstance(info, dict) else []
    print(f"[DIAG][{tf_used}] SKIP -> " + ", ".join(_reasons))

    print(f"[DIAG][{tf_used}] OK (send={send_flag})")
    req = (res or {}).get("request", {})
    debug_log(
        f"[DIAG][{tf_used}] price={req.get('price')} sl={req.get('sl')} tp={req.get('tp')}"
    )

    symbol = (
        res.get("symbol") or os.getenv("GOLD_SYMBOL") or os.getenv("SYMBOL") or "GOLD"
    )

    # Sembol se√ß ve tick al
    if not mt5.symbol_select(symbol, True):
        debug_log(f"[ORDER?] SKIP: symbol not tradable -> {symbol}")
        return

    entry = float(res.get("entry_price") or 0.0)
    sl = float(res.get("sl_price") or 0.0)
    tp = float(res.get("tp_price") or 0.0)

    if entry == 0.0 or sl == 0.0 or tp == 0.0:
        debug_log(f"[ORDER?] SKIP: sl/tp missing -> sl={sl} tp={tp}")
        return

    si = mt5.symbol_info(symbol)
    point = si.point or 0.01
    digits = si.digits or 2

    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        debug_log(f"[ORDER?] SKIP: no tick -> {symbol}")
        return

    dir_val = str(res.get("direction", "")).upper()
    side = mt5.ORDER_TYPE_SELL if dir_val == "SHORT" else mt5.ORDER_TYPE_BUY
    price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask

    # 5) min stop / freeze + ENV guard
    si = mt5.symbol_info(symbol)
    point = si.point or 0.01
    digits = si.digits or 2
    min_stop = si.trade_stops_level * point

    # k√º√ß√ºk tampon: 1 point
    buf = point

    # SL/TP bo≈ü kalmasƒ±n (ATR veya hard 1 pip fallback + min_stop ekle)
    if not sl_price or sl_price == 0:
        sl_price = entry - atr * 1 if direction == "LONG" else entry + atr * 1
        # broker tamponu ekle
        if direction == "LONG":
            sl_price = min(sl_price, entry - min_stop)
        else:
            sl_price = max(sl_price, entry + min_stop)
        sl_source = "ATR-FALLBACK"

    if not tp_price or tp_price == 0:
        tp_price = entry + atr * 2 if direction == "LONG" else entry - atr * 2
        # broker tamponu ekle
        if direction == "LONG":
            tp_price = max(tp_price, entry + min_stop)
        else:
            tp_price = min(tp_price, entry - min_stop)

    # broker basamaklarƒ±na yuvarla
    sl_price = round(sl_price, digits)
    tp_price = round(tp_price, digits)

    debug_log(
        f"[ORDER GUARD] price={price:.{digits}f} sl={sl_price:.{digits}f} tp={tp_price:.{digits}f}"
    )

    # 6) BURADAN SONRASI senin mevcut kodun:
    deviation = int(os.getenv("FORCE_DEVIATION", "50"))
    magic = int(os.getenv("MAGIC", "20250918"))

    request = {
        "action": mt5.TRADE_ACTION_DEAL,
        "symbol": symbol,
        "volume": float(os.getenv("LOT_SIZE", "0.1")),
        "type": side,
        "entry": float(entry_price),
        "sl": float(sl_price),
        "tp": float(tp_price),
        "deviation": 20,
        "magic": 123456,
        "comment": "Gold Bot",
        "type_time": mt5.ORDER_TIME_GTC,
        "type_filling": mt5.ORDER_FILLING_FOK,
    }
    result = RAW_ORDER_SEND(request)
    # print(f"[ORDER] retcode={getattr(result,'retcode',None)} comment={getattr(result,'comment','')}")
    try:
        info["request"] = request  # (may be None; safe)
    except Exception:
        pass

    # --- RCA: ORDER_CHECK √ñNCESƒ∞ (erken te≈ühis & erken kesme) ---
    tf_used = str((res or {}).get("timeframe") or "?")  # garanti olsun
    rca = rca_order(symbol, res, tf=tf_used, request=request)
    if rca.get("block"):
        info["reasons"] = info.get("reasons", []) + rca["reasons"]
        print(f"[RCA][{tf_used}] DROP before order_check")
        # (return avoided to continue summary)
    # Emir g√∂nder (mode=trade ve SEND_ORDERS=1 ise)
    if mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1:

        symbol = (
            res.get("symbol")
            or os.getenv("GOLD_SYMBOL")
            or os.getenv("SYMBOL")
            or "GOLD"
        )
        dir_val = str(res.get("direction", "")).upper()
        side = mt5.ORDER_TYPE_SELL if dir_val == "SHORT" else mt5.ORDER_TYPE_BUY

        tick = mt5.symbol_info_tick(symbol)
        if not tick:
            debug_log(f"[EVAL][ORDER] tick yok ({symbol})")
        else:
            price = tick.bid if side == mt5.ORDER_TYPE_SELL else tick.ask

            rp = float(os.getenv("RISK_PERCENT", "0"))
            if rp > 0:
                try:
                    volume = calc_volume_by_risk(symbol, entry_price, sl_price, rp)
                except Exception:
                    volume = float(os.getenv("LOT", "0.10"))
            else:
                volume = float(os.getenv("LOT", "0.10"))

            deviation = int(os.getenv("FORCE_DEVIATION", "50"))
            magic = int(os.getenv("MAGIC", "20250918"))

            request = {
                "action": mt5.TRADE_ACTION_DEAL,
                "symbol": symbol,
                "volume": float(os.getenv("LOT_SIZE", "0.1")),
                "type": side,
                "entry": float(entry_price),
                "sl": float(sl_price),
                "tp": float(tp_price),
                "deviation": 20,
                "magic": 123456,
                "comment": "Gold Bot",
                "type_time": mt5.ORDER_TIME_GTC,
                "type_filling": mt5.ORDER_FILLING_FOK,
            }

            debug_log(
                f"[EVAL][ORDER] sending {symbol} {dir_val} vol={volume} price={price}"
            )
            request = fix_order_price(
                request, guard=res.get("guard") or res.get("sl_tp_guard")
            )
            result = RAW_ORDER_SEND(request)
            rc_send = int(getattr(result, "retcode", -1))
            debug_log(f"[ORDER][{tf_used}] retcode={rc_send}")
            OKS = (0, 1, getattr(mt5, "TRADE_RETCODE_DONE", 10009))
            if rc_send not in OKS:
                debug_log(f"[ORDER][{tf_used}] retcode={rc_send} -> RCA:")
                rca_order(symbol, res, tf=tf_used, request=request)
            reasons.append(f"order_send_retcode={rc_send}")
            # (return avoided to continue summary)
    # --- SHORT ---
    elif direction == "SHORT":
        if teyit_sayisi_short < th:
            return None

            # default'lar (her durumda tanƒ±mlƒ± olsun)
        warn_tag = ""
        why = None
        spread_pts = 0.0
        rr_ratio = 0.0
        entry_price = None
        tp_price = None
        sl_price = None
        sl_source = ""

        entry_price = last_close
        tp_price = entry_price - target_pips * PIP_VALUE
        sl_price, sl_source = choose_stop_loss(tf_df, "SHORT", levels)

        if isinstance(sl_price, pd.Series):
            sl_price = float(sl_price.iloc[-1])
        else:
            sl_price = float(sl_price)

        # --- SPREAD Fƒ∞LTRESƒ∞ ---
        allow, why, spread_pts, ratio = spread_gate(SYMBOL, entry_price, sl_price)
        if not allow:
            debug_log(
                f"[SPREAD] BLOCK ‚Üí mode={SPREAD_MODE} spread_pts={spread_pts:.1f} ratio={ratio:.2f} ({why})"
            )
            return None

        risk = abs(entry_price - sl_price)
        reward = abs(entry_price - tp_price)
        if risk <= 0:
            return None
        rr_ratio = reward / risk

        # Uyarƒ± etiketi (opsiyonel)
        warn_tag = (
            ""
            if why in ("OK", "NO-SPREAD-DATA", None)
            else f"\nWARN:SPREAD:{why} (spread={spread_pts:.0f}pt, ratio={ratio:.2f})"
        )

        min_rr = float(os.getenv("MIN_RR", "0"))
        tol = float(os.getenv("RR_TOL", "1e-9"))  # .env‚Äôde opsiyonel

        if rr_ratio + tol < min_rr:
            debug_log(
                f"‚ùå {('LONG' if entry_price > sl_price else 'SHORT')} i√ßin RR {_rr_text()} < {min_rr:.6f} ‚Üí ƒ∞ptal"
            )
            return None

        if not check_tp_bucket(tf_used, entry_price, tp_price):
            hedef_pip = round(abs(tp_price - entry_price) / PIP_VALUE, 1)
            debug_log(
                f"[DEBUG] TP KOVASI REDDEDƒ∞LDƒ∞ ‚Üí hedef_pip={hedef_pip:.1f}, entry={entry_price}, tp={tp_price}"
            )
            return None

        lot = calculate_lot(entry_price, sl_price, risk_percent=0.02)
        if lot <= 0:
            debug_log(
                f"[DEBUG] LOT REDDEDƒ∞LDƒ∞ ‚Üí hesaplanan lot={lot}, entry={entry_price}, sl={sl_price}, tp={tp_price}"
            )
            return None

        msg = (
            f"üü•üö®XAUUSD SHORT Gƒ∞R HEDEF {target_pips} Pƒ∞P ({tf_used}) | "
            f"ZAMAN: {now_tr()} ({formasyon}) | "
            f"ENTRY: {entry_price:.2f} | "
            f"TP: {tp_price:.2f} | "
            f"SL: {sl_price:.2f} ({sl_source}) | "
            f"RR: {rr_ratio:.2f} | "
        )
        send_telegram_message(msg)
        place_order(
            symbol="GOLD",
            order_type=direction,
            lot=LOT_SIZE,
            entry_price=entry_price,
            sl_price=sl_price,
            tp_price=tp_price,
        )

        # --- PRE-GATE DIST CHECK ---
        # --- PRE-GATE DIST CHECK (RR-ONLY: mesafe guard'larƒ± kapalƒ±) ---

        _ok_dist, _why = True, "ok"
        # --- REAL SIGNAL GATE ---
        # Circuit breaker (optional)

        _block, _why_cb = (False, "ok")

        if _block:
            reasons.append(_why_cb)

        reasons = []
        need = get_confirm_threshold(tf_used)
        got = sum(
            1
            for k, v in (res.items() if isinstance(res, dict) else [])
            if isinstance(v, bool) and v
        )
        if got < need:
            reasons.append(f"confirm {got}/{need}")
        try:
            if not allow:
                reasons.append(f"spread:{why}")
        except Exception:
            try:
                min_rr = 0.10
                if rr_ratio is None or rr_ratio < min_rr:
                    reasons.append(
                        f"rr:{(0.0 if rr_ratio is None else rr_ratio):.2f}<{min_rr}"
                    )
            except Exception:
                reasons.append("rr_err")

            if not check_tp_bucket(tf_used, entry_price, tp_price):
                reasons.append("tp_bucket")
        except Exception:
            reasons.append("tp_bucket_err")

        if (lot is None) or (lot <= 0):
            reasons.append(f"lot:{lot}")
        # varsa duplicate kontrol√ºn√º de burada ekleyebilirsin
        # if is_duplicate_msg(tf_used, res): reasons.append("duplicate")

        # --- PASS: yalnƒ±zca burada Telegram'a g√∂nder ---
        # send_signal_message(tf_used, msg)

        # (Emir a√ßma kƒ±smƒ± opsiyonel; SEND_ORDERS vb. ile anahtarlarsƒ±n)

        # ensure SHORT branch triggers diagnose/order
        info = diagnose_and_maybe_order(
            tf_used,
            res,
            send=(mode == "trade" and int(os.getenv("SEND_ORDERS", "0")) == 1),
        )


def run_bot():
    while True:

        try:

            if not ensure_mt5_alive():

                time.sleep(1.0)

                continue

            time.sleep(float(os.getenv("MIN_LOOP_SLEEP_MS", "500")) / 1000.0)

        except Exception as _loop_err:

            debug_log(f"[LOOP] hata: {_loop_err}")
            time.sleep(1.0)
        now = get_server_time().strftime()
        minute = now.minute
        hour = now.hour
        second = now.second

        # --- M15 ---
        if minute % 15 == 14 and second == 0:
            check_all_timeframes(mode="scan")  # sadece tarama
        if minute % 15 == 0 and second == 0:
            check_all_timeframes(mode="signal")  # sinyal

        # --- M30 ---
        if minute % 30 == 29 and second == 0:
            check_all_timeframes(mode="scan")
        if minute % 30 == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- M45 (15+30 birle≈üim) ---
        if minute == 44 and second == 0:
            check_all_timeframes(mode="scan")
        if minute == 45 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H1 ---
        if minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H2 ---
        if hour % 2 == 1 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 2 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H3 ---
        if hour % 3 == 2 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 3 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H4 ---
        if hour % 4 == 3 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 4 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        # --- H12 ---
        if hour % 12 == 11 and minute == 59 and second == 0:
            check_all_timeframes(mode="scan")
        if hour % 12 == 0 and minute == 0 and second == 0:
            check_all_timeframes(mode="signal")

        time.sleep(1)


def paper_demo(direction="SHORT", sl_pips=35, tp_pips=60):
    symbol = os.getenv("GOLD_SYMBOL") or os.getenv("SYMBOL") or "GOLD"
    si = mt5.symbol_info(symbol)
    if not si:
        debug_log("[PAPER] symbol_info yok")
        return
    tick = mt5.symbol_info_tick(symbol)
    if not tick:
        debug_log("[PAPER] tick yok")
        return
    point = si.point or 0.01
    digits = si.digits or 2
    price = tick.bid if direction == "SHORT" else tick.ask

    # entry = anlƒ±k fiyat, SL/TP pips ile
    if direction == "SHORT":
        sl = price + sl_pips * point
        tp = price - tp_pips * point
    else:
        sl = price - sl_pips * point
        tp = price + tp_pips * point

    res = {
        "timeframe": "TEST",
        "direction": direction,
        "symbol": symbol,
        "entry_price": round(price, digits),
        "sl_price": round(sl, digits),
        "tp_price": round(tp, digits),
    }
    diagnose_and_maybe_order("TEST", res, send=True)


def session_gate(symbol: str, mode: str | None = None):
    try:
        cfg = (mode or os.getenv("SESSION_LOCK_MODE") or "HARD").upper()
    except Exception:
        cfg = "HARD"
    if cfg == "OFF":
        return True, None
    if cfg == "AUTO":
        cfg = "HARD"
    si = None
    try:
        si = mt5.symbol_info(symbol)
    except Exception:
        pass
    allow = True
    reason = None
    try:
        tm = int(getattr(si, "trade_mode", 2) or 2) if si else 2
        if tm != 2:
            allow = False
            reason = f"SESSION:MODE:{tm}"
    except Exception:
        pass
    try:
        hard_w = os.getenv("SESSION_HARD_WINDOWS", "")
        if _in_time_windows(now_tr()(ZoneInfo("Europe/Istanbul")), hard_w):
            allow = False
            reason = reason or "SESSION:WINDOW"
    except Exception:
        pass
    if cfg == "SOFT":
        return True, (reason or None)
    return allow, (reason or None)


if __name__ == "__main__":
    run_master_diagnostic()
    # .env vs.
    SYMBOL = os.getenv("SYMBOL", "GOLD")
    # MT5 sadece Bƒ∞R KERE burada initialize edilsin
    ok = mt5.initialize(login=MT5_LOGIN, password=MT5_PASSWORD, server=MT5_SERVER)
    if not ok:
        debug_log("‚ùå MT5 initialize ba≈üarƒ±sƒ±z:", mt5.last_error())
    else:
        debug_log("‚úÖ MT5 baƒülantƒ±sƒ± ba≈üarƒ±lƒ±")
    symbol = resolve_gold_symbol()
    if not symbol:
        debug_log(
            "[BOOT] GOLD/XAU sembol√º bulunamadƒ±. Market Watch'ta g√∂r√ºn√ºr yapƒ±n.",
            force=True,
        )
        raise SystemExit("Symbol not found")

    # global/ENV senkronize et ki t√ºm fonksiyonlar aynƒ± sembol√º kullansƒ±n
    globals()["SYMBOL"] = symbol
    os.environ["SYMBOL"] = symbol

    # garanti: se√ßili olsun
    try:
        mt5.symbol_select(symbol, True)
    except Exception:
        pass

    debug_log(f"[BOOT] SYMBOL = {symbol}", force=True)

    if DEBUG:
        try:
            sanity_startup_check(SYMBOL)
        except Exception as e:
            debug_log("[CHECK] sanitary_startup_check ERROR:", e)

paper_demo("SHORT", sl_pips=35, tp_pips=60)
paper_demo("LONG", 35, 60)
send_boot_once()
# --- PIP/POINT sanity check ---
info = mt5.symbol_info(SYMBOL)
if not info:
    debug_log("[WARN] symbol_info alƒ±namadƒ±:", SYMBOL)
else:
    point = float(info.point or 0.0)
    try:
        ratio = (PIP_VALUE / point) if point > 0 else 0
    except Exception:
        ratio = 0
    ok = abs(round(ratio) - ratio) < 1e-6 and ratio > 0
    if not ok:
        debug_log(
            f"[WARN] PIP_VALUE({PIP_VALUE}) point({point}) ile uyumlu deƒüil! "
            f"ratio={ratio:.6f} (pip ka√ß point?)"
        )
    else:
        POINTS_PER_PIP = int(round(ratio))
        debug_log(f"[OK] PIP/POINT: 1 pip = {POINTS_PER_PIP} point (point={point})")


try:
    rows = get_ohlc(SYMBOL, timeframe=mt5.TIMEFRAME_M15, bars=20)[
        ["time", "open", "high", "low", "close", "spread"]
    ]
    if rows is not None:
        debug_log("=" * 108 + " OHLC LAST 20 (once) " + "=" * 108)
        debug_log(f"{'time':<20} {'open':>22} {'high':>22} {'low':>22} {'close':>22}")
        for _, r in rows.iterrows():
            t = (
                pd.to_datetime(r["time"])
                .tz_localize("UTC")
                .astimezone(ZoneInfo("Europe/Istanbul"))
                .strftime("%Y-%m-%d %H:%M")
            )
            debug_log(
                f"{t:<20} {r['open']:>22f} {r['high']:>22f} {r['low']:>22f} {r['close']:>22f}"
            )
except Exception as e:
    debug_log(f"OHLC preview error: {e}")

run_boot(SYMBOL, sleep_sec=5)


def ensure_mt5_alive() -> bool:
    """Basit MT5 saƒülƒ±k kontrol√º ve yeniden ba≈ülatma."""
    try:
        ok = mt5.initialize()
    except Exception:
        ok = False
    if not ok:
        try:
            login = int(os.getenv("MT5_LOGIN", "0") or 0)
            password = os.getenv("MT5_PASSWORD") or ""
            server = os.getenv("MT5_SERVER") or ""
            if login and password and server:
                mt5.shutdown()
                if mt5.initialize():
                    mt5.login(login, password=password, server=server)
                    return True
                return False
            return mt5.initialize()
        except Exception:
            return False
    return True


# --- Session Lock Helpers ---
def _parse_time_hhmm(tstr: str):
    try:
        hh, mm = tstr.strip().split(":")
        return int(hh), int(mm)
    except Exception:
        return None


def _in_time_windows(now_dt, windows_str: str) -> bool:
    try:
        if not windows_str:
            return False
        hm = now_dt.hour * 60 + now_dt.minute
        for win in windows_str.split(","):
            win = win.strip()
            if not win or "-" not in win:
                continue
            a, b = win.split("-")
            pa = _parse_time_hhmm(a)
            pb = _parse_time_hhmm(b)
            if not pa or not pb:
                continue
            sa = pa[0] * 60 + pa[1]
            sb = pb[0] * 60 + pb[1]
            if sa <= sb:
                if sa <= hm <= sb:
                    return True
            else:
                if hm >= sa or hm <= sb:
                    return True
        return False
    except Exception:
        return False


# ===== Minimal Stability Helpers (Contract / RCA / Circuit Breaker) =====

# Global counters (lightweight; can be extended by order/closure hooks)
_TRADES_TODAY_BY_TF = {}
_CONSEC_LOSSES = 0
_DAILY_PNL_USD = 0.0


def _env_int(key, default):
    try:
        return int(os.getenv(key, str(default)))
    except Exception:
        return default


def _env_float(key, default):
    try:
        return float(os.getenv(key, str(default)))
    except Exception:
        return default


def normalize_signal(res: dict) -> dict:
    """Field normalization to stabilize downstream usage."""
    try:
        res = dict(res or {})
        # direction
        d = str(res.get("direction", "-")).upper()
        res["direction"] = d if d in ("LONG", "SHORT", "-") else "-"
        # symbol
        res["symbol"] = (
            res.get("symbol")
            or os.getenv("FORCE_SYMBOL")
            or globals().get("SYMBOL")
            or "GOLD"
        )
        # timeframe
        res["timeframe"] = res.get("timeframe") or "-"
        # formasyon
        res["formasyon"] = res.get("formasyon") or res.get("formation") or "-"
        # prices
        if "sl" in res and "sl_price" not in res:
            res["sl_price"] = res.get("sl")
        if "tp" in res and "tp_price" not in res:
            res["tp_price"] = res.get("tp")
        # rr
        if "rr" not in res and "RR" in res:
            res["rr"] = res.get("RR")
        # spread_why
        res["spread_why"] = res.get("spread_why") or "OK"
        return res
    except Exception:
        return res or {}


def assert_contract(res: dict) -> bool:
    """Fail-fast checks for mandatory fields. Returns True if ok."""
    try:
        keys = ["symbol", "timeframe", "direction", "formasyon"]
        for k in keys:
            if not str(res.get(k, "")).strip():
                debug_log(f"[CONTRACT] missing field: {k}")
                return False
        # Price coherence if present
        entry = res.get("entry") or res.get("entry_price")
        sl = res.get("sl_price")
        tp = res.get("tp_price")
        if entry and sl and tp:
            try:
                entry, sl, tp = float(entry), float(sl), float(tp)
                if not (abs(entry - sl) > 0 and abs(tp - entry) > 0):
                    debug_log("[CONTRACT] non-positive distances entry/sl/tp")
                    return False
            except Exception:
                pass
        return True
    except Exception as e:
        debug_log(f"[CONTRACT] exception: {e}")
        return False


def rca_line(tf: str, status: str, reasons: list, regime: str = "-", rr=None):
    """One-line structured RCA for observability."""
    try:
        rr_txt = (
            "-"
            if rr is None
            else (f"{rr:.2f}" if isinstance(rr, (int, float)) else str(rr))
        )
        line = f"RCA tf={tf} status={status} reasons={list(reasons or [])} regime={regime} rr={rr_txt}"
        debug_log(line, force=True)
    except Exception as e:
        debug_log(f"[RCA-LINE ERR] {e}")


def _validate_positive_distances(
    res: dict, entry_price, sl_price, tp_price
) -> tuple[bool, str]:
    """Return (ok, reason). Ensures SL/TP distances are positive."""
    try:
        if entry_price is None or sl_price is None or tp_price is None:
            return False, "dist_missing"
        e = float(entry_price)
        s = float(sl_price)
        t = float(tp_price)
        if not (abs(e - s) > 0 and abs(t - e) > 0):
            return False, "dist_nonpositive"
        return True, "ok"
    except Exception as exc:
        return False, f"dist_exc:{exc}"


try:
    _orig_spread_gate = spread_gate

    def spread_gate(*a, **k):
        allow, why, pts, ratio, mode = _orig_spread_gate(*a, **k)
        mode_u = str(mode or os.getenv("SPREAD_MODE", "OFF")).upper()
        if mode_u != "HARD":
            allow = True
        return allow, why, pts, ratio, mode_u

except NameError:
    pass
